import {
  S
} from "./chunk-UXMIMDPI.js";
import {
  r
} from "./chunk-IV2EBUV2.js";
import {
  HvTypography,
  useMediaQuery,
  useTheme
} from "./chunk-WUKK7SNM.js";
import {
  createStyled,
  jsx,
  jsxs,
  theme
} from "./chunk-3L5C4PYA.js";
import {
  Trans2 as Trans,
  useTranslation
} from "./chunk-XCL2IQD6.js";
import {
  require_react
} from "./chunk-QV6VW2LK.js";
import {
  __toESM
} from "./chunk-HM4MQYWN.js";

// node_modules/@hitachivantara/app-shell/dist/esm/lib/hooks/useNavigation.js
var import_react5 = __toESM(require_react(), 1);

// node_modules/react-router-dom/dist/index.js
var React2 = __toESM(require_react());

// node_modules/react-router/dist/index.js
var React = __toESM(require_react());

// node_modules/@remix-run/router/dist/router.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url = createURL(to);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    matches = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b) => a2.score !== b.score ? b.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b.routesMeta.map((meta) => meta.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s3) => s3 === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s3) => !isSplat(s3)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b) {
  let siblings = a2.length === b.length && a2.slice(0, -1).every((n2, i2) => n2 === b[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b[b.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match)
      return null;
    Object.assign(matchedParams, match.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match = pathname.match(matcher);
  if (!match)
    return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (isPathRelative || toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
var validMutationMethodsArr = ["post", "put", "patch", "delete"];
var validMutationMethods = new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["get", ...validMutationMethodsArr];
var validRequestMethods = new Set(validRequestMethodsArr);
var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");

// node_modules/react-router/dist/index.js
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var DataRouterContext = React.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
var DataRouterStateContext = React.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
var AwaitContext = React.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
var NavigationContext = React.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = React.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = React.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
if (true) {
  RouteContext.displayName = "Route";
}
var RouteErrorContext = React.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    basename,
    navigator
  } = React.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return React.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  return React.useContext(LocationContext).location;
}
var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function useIsomorphicLayoutEffect(cb) {
  let isStatic = React.useContext(NavigationContext).static;
  if (!isStatic) {
    React.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = React.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let dataRouterContext = React.useContext(DataRouterContext);
  let {
    basename,
    navigator
  } = React.useContext(NavigationContext);
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  let activeRef = React.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, navigateEffectWarning) : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);
  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
var OutletContext = React.createContext(null);
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = React.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match) => match.pathnameBase));
  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? true ? invariant(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : invariant(false) : void 0;
  let {
    navigator
  } = React.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = React.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  let renderedMatches = _renderMatches(matches && matches.map((match) => Object.assign({}, match, {
    params: Object.assign({}, parentParams, match.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname
    ]),
    pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return React.createElement(LocationContext.Provider, {
      value: {
        location: _extends2({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (true) {
    console.error("Error handled by React Router default ErrorBoundary:", error);
    devInfo = React.createElement(React.Fragment, null, React.createElement("p", null, "💿 Hey developer 👋"), React.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", React.createElement("code", {
      style: codeStyles
    }, "ErrorBoundary"), " or", " ", React.createElement("code", {
      style: codeStyles
    }, "errorElement"), " prop on your route."));
  }
  return React.createElement(React.Fragment, null, React.createElement("h2", null, "Unexpected Application Error!"), React.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? React.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
var defaultErrorElement = React.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? React.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, React.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
function RenderedRoute(_ref) {
  let {
    routeContext,
    match,
    children
  } = _ref;
  let dataRouterContext = React.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return React.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? true ? invariant(false, "Could not find a matching route for errors on route IDs: " + Object.keys(errors).join(",")) : invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match, index) => {
    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match.route.errorElement || defaultErrorElement;
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match.route.Component) {
        children = React.createElement(match.route.Component, null);
      } else if (match.route.element) {
        children = match.route.element;
      } else {
        children = outlet;
      }
      return React.createElement(RenderedRoute, {
        match,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? React.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook;
(function(DataRouterHook3) {
  DataRouterHook3["UseBlocker"] = "useBlocker";
  DataRouterHook3["UseRevalidator"] = "useRevalidator";
  DataRouterHook3["UseNavigateStable"] = "useNavigate";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseBlocker"] = "useBlocker";
  DataRouterStateHook3["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook3["UseActionData"] = "useActionData";
  DataRouterStateHook3["UseRouteError"] = "useRouteError";
  DataRouterStateHook3["UseNavigation"] = "useNavigation";
  DataRouterStateHook3["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook3["UseMatches"] = "useMatches";
  DataRouterStateHook3["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook3["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook3["UseRouteId"] = "useRouteId";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = React.useContext(DataRouterContext);
  !ctx ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = React.useContext(RouteContext);
  !route ? true ? invariant(false, getDataRouterConsoleError(hookName)) : invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? true ? invariant(false, hookName + ' can only be used on routes that contain a unique "id"') : invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(DataRouterStateHook.UseRouteId);
}
function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React.useMemo(() => matches.map((match) => {
    let {
      pathname,
      params
    } = match;
    return {
      id: match.route.id,
      pathname,
      params,
      data: loaderData[match.route.id],
      handle: match.route.handle
    };
  }), [matches, loaderData]);
}
function useRouteError() {
  var _state$errors;
  let error = React.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook.UseNavigateStable);
  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);
  let activeRef = React.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning(activeRef.current, navigateEffectWarning) : void 0;
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      router.navigate(to);
    } else {
      router.navigate(to, _extends2({
        fromRouteId: id
      }, options));
    }
  }, [router, id]);
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning(false, message) : void 0;
  }
}
var START_TRANSITION = "startTransition";
var startTransitionImpl = React[START_TRANSITION];
function Route(_props) {
  true ? invariant(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? true ? invariant(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React.useMemo(() => ({
    basename,
    navigator,
    static: staticProp
  }), [basename, navigator, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = React.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  true ? warning(locationContext != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (locationContext == null) {
    return null;
  }
  return React.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, React.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
var neverSettledPromise = new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  React.Children.forEach(children, (element, index) => {
    if (!React.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === React.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? true ? invariant(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? true ? invariant(false, "An index route cannot have child routes.") : invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}

// node_modules/react-router-dom/dist/index.js
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return object != null && typeof object.tagName === "string";
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e2) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    true ? warning(false, '"' + encType + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + defaultEncType + '"')) : void 0;
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let {
        name,
        type,
        value
      } = target;
      if (type === "image") {
        let prefix = name ? name + "." : "";
        formData.append(prefix + "x", "0");
        formData.append(prefix + "y", "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return {
    action,
    method: method.toLowerCase(),
    encType,
    formData,
    body
  };
}
var _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
var _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
var _excluded3 = ["reloadDocument", "replace", "state", "method", "action", "onSubmit", "submit", "relative", "preventScrollReset"];
var START_TRANSITION2 = "startTransition";
var startTransitionImpl2 = React2[START_TRANSITION2];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref;
  let historyRef = React2.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = React2.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React2.useCallback((newState) => {
    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return React2.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    future,
    history
  } = _ref3;
  let [state, setStateImpl] = React2.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = React2.useCallback((newState) => {
    v7_startTransition && startTransitionImpl2 ? startTransitionImpl2(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  React2.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return React2.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = React2.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded);
  let {
    basename
  } = React2.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
        true ? warning(false, '<Link to="' + to + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.') : void 0;
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React2.createElement("a", _extends3({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = React2.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React2.useContext(DataRouterStateContext);
  let {
    navigator
  } = React2.useContext(NavigationContext);
  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return React2.createElement(Link, _extends3({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style,
    to
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
var Form = React2.forwardRef((props, ref) => {
  let submit = useSubmit();
  return React2.createElement(FormImpl, _extends3({}, props, {
    submit,
    ref
  }));
});
if (true) {
  Form.displayName = "Form";
}
var FormImpl = React2.forwardRef((_ref6, forwardedRef) => {
  let {
    reloadDocument,
    replace,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    submit,
    relative,
    preventScrollReset
  } = _ref6, props = _objectWithoutPropertiesLoose(_ref6, _excluded3);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });
  let submitHandler = (event) => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented)
      return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      method: submitMethod,
      replace,
      state,
      relative,
      preventScrollReset
    });
  };
  return React2.createElement("form", _extends3({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  FormImpl.displayName = "FormImpl";
}
function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
}
var DataRouterHook2;
(function(DataRouterHook3) {
  DataRouterHook3["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook3["UseSubmit"] = "useSubmit";
  DataRouterHook3["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook3["UseFetcher"] = "useFetcher";
})(DataRouterHook2 || (DataRouterHook2 = {}));
var DataRouterStateHook2;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseFetchers"] = "useFetchers";
  DataRouterStateHook3["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
function getDataRouterConsoleError2(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext2(hookName) {
  let ctx = React2.useContext(DataRouterContext);
  !ctx ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = React2.useContext(DataRouterStateContext);
  !state ? true ? invariant(false, getDataRouterConsoleError2(hookName)) : invariant(false) : void 0;
  return state;
}
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return React2.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
function validateClientSideSubmission() {
  if (typeof document === "undefined") {
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
  }
}
function useSubmit() {
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseSubmit);
  let {
    basename
  } = React2.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  return React2.useCallback(function(target, options) {
    if (options === void 0) {
      options = {};
    }
    validateClientSideSubmission();
    let {
      action,
      method,
      encType,
      formData,
      body
    } = getFormSubmissionInfo(target, basename);
    router.navigate(options.action || action, {
      preventScrollReset: options.preventScrollReset,
      formData,
      body,
      formMethod: options.method || method,
      formEncType: options.encType || encType,
      replace: options.replace,
      state: options.state,
      fromRouteId: currentRouteId
    });
  }, [router, basename, currentRouteId]);
}
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = React2.useContext(NavigationContext);
  let routeContext = React2.useContext(RouteContext);
  !routeContext ? true ? invariant(false, "useFormAction must be used inside a RouteContext") : invariant(false) : void 0;
  let [match] = routeContext.matches.slice(-1);
  let path = _extends3({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    path.hash = location.hash;
    if (match.route.index) {
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = useDataRouterContext2(DataRouterHook2.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);
  let {
    basename
  } = React2.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  React2.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(React2.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches]));
  if (typeof document !== "undefined") {
    React2.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e2) {
      }
    }, [storageKey]);
    React2.useLayoutEffect(() => {
      let getKeyWithoutBasename = getKey && basename !== "/" ? (location2, matches2) => getKey(
        // Strip the basename to match useLocation()
        _extends3({}, location2, {
          pathname: stripBasename(location2.pathname, basename) || location2.pathname
        }),
        matches2
      ) : getKey;
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    React2.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function useBeforeUnload(callback, options) {
  let {
    capture
  } = options || {};
  React2.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("beforeunload", callback, opts);
    return () => {
      window.removeEventListener("beforeunload", callback, opts);
    };
  }, [callback, capture]);
}
function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  React2.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}

// node_modules/@hitachivantara/app-shell-shared/dist/esm/AppShellContext.js
var import_react = __toESM(require_react(), 1);
var e = (0, import_react.createContext)(void 0);

// node_modules/@hitachivantara/app-shell-shared/dist/esm/AppShellViewContext.js
var import_react2 = __toESM(require_react(), 1);
var o = (0, import_react2.createContext)(void 0);

// node_modules/@hitachivantara/app-shell-shared/dist/esm/AppShellRuntimeContext.js
var import_react3 = __toESM(require_react(), 1);
var o2 = (0, import_react3.createContext)(void 0);

// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
  var tokens = [];
  var i2 = 0;
  while (i2 < str.length) {
    var char = str[i2];
    if (char === "*" || char === "+" || char === "?") {
      tokens.push({ type: "MODIFIER", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "\\") {
      tokens.push({ type: "ESCAPED_CHAR", index: i2++, value: str[i2++] });
      continue;
    }
    if (char === "{") {
      tokens.push({ type: "OPEN", index: i2, value: str[i2++] });
      continue;
    }
    if (char === "}") {
      tokens.push({ type: "CLOSE", index: i2, value: str[i2++] });
      continue;
    }
    if (char === ":") {
      var name = "";
      var j2 = i2 + 1;
      while (j2 < str.length) {
        var code = str.charCodeAt(j2);
        if (
          // `0-9`
          code >= 48 && code <= 57 || // `A-Z`
          code >= 65 && code <= 90 || // `a-z`
          code >= 97 && code <= 122 || // `_`
          code === 95
        ) {
          name += str[j2++];
          continue;
        }
        break;
      }
      if (!name)
        throw new TypeError("Missing parameter name at ".concat(i2));
      tokens.push({ type: "NAME", index: i2, value: name });
      i2 = j2;
      continue;
    }
    if (char === "(") {
      var count = 1;
      var pattern = "";
      var j2 = i2 + 1;
      if (str[j2] === "?") {
        throw new TypeError('Pattern cannot start with "?" at '.concat(j2));
      }
      while (j2 < str.length) {
        if (str[j2] === "\\") {
          pattern += str[j2++] + str[j2++];
          continue;
        }
        if (str[j2] === ")") {
          count--;
          if (count === 0) {
            j2++;
            break;
          }
        } else if (str[j2] === "(") {
          count++;
          if (str[j2 + 1] !== "?") {
            throw new TypeError("Capturing groups are not allowed at ".concat(j2));
          }
        }
        pattern += str[j2++];
      }
      if (count)
        throw new TypeError("Unbalanced pattern at ".concat(i2));
      if (!pattern)
        throw new TypeError("Missing pattern at ".concat(i2));
      tokens.push({ type: "PATTERN", index: i2, value: pattern });
      i2 = j2;
      continue;
    }
    tokens.push({ type: "CHAR", index: i2, value: str[i2++] });
  }
  tokens.push({ type: "END", index: i2, value: "" });
  return tokens;
}
function parse(str, options) {
  if (options === void 0) {
    options = {};
  }
  var tokens = lexer(str);
  var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
  var defaultPattern = "[^".concat(escapeString(options.delimiter || "/#?"), "]+?");
  var result = [];
  var key = 0;
  var i2 = 0;
  var path = "";
  var tryConsume = function(type) {
    if (i2 < tokens.length && tokens[i2].type === type)
      return tokens[i2++].value;
  };
  var mustConsume = function(type) {
    var value2 = tryConsume(type);
    if (value2 !== void 0)
      return value2;
    var _a2 = tokens[i2], nextType = _a2.type, index = _a2.index;
    throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
  };
  var consumeText = function() {
    var result2 = "";
    var value2;
    while (value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
      result2 += value2;
    }
    return result2;
  };
  while (i2 < tokens.length) {
    var char = tryConsume("CHAR");
    var name = tryConsume("NAME");
    var pattern = tryConsume("PATTERN");
    if (name || pattern) {
      var prefix = char || "";
      if (prefixes.indexOf(prefix) === -1) {
        path += prefix;
        prefix = "";
      }
      if (path) {
        result.push(path);
        path = "";
      }
      result.push({
        name: name || key++,
        prefix,
        suffix: "",
        pattern: pattern || defaultPattern,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    var value = char || tryConsume("ESCAPED_CHAR");
    if (value) {
      path += value;
      continue;
    }
    if (path) {
      result.push(path);
      path = "";
    }
    var open = tryConsume("OPEN");
    if (open) {
      var prefix = consumeText();
      var name_1 = tryConsume("NAME") || "";
      var pattern_1 = tryConsume("PATTERN") || "";
      var suffix = consumeText();
      mustConsume("CLOSE");
      result.push({
        name: name_1 || (pattern_1 ? key++ : ""),
        pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
        prefix,
        suffix,
        modifier: tryConsume("MODIFIER") || ""
      });
      continue;
    }
    mustConsume("END");
  }
  return result;
}
function compile(str, options) {
  return tokensToFunction(parse(str, options), options);
}
function tokensToFunction(tokens, options) {
  if (options === void 0) {
    options = {};
  }
  var reFlags = flags(options);
  var _a = options.encode, encode = _a === void 0 ? function(x) {
    return x;
  } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
  var matches = tokens.map(function(token) {
    if (typeof token === "object") {
      return new RegExp("^(?:".concat(token.pattern, ")$"), reFlags);
    }
  });
  return function(data) {
    var path = "";
    for (var i2 = 0; i2 < tokens.length; i2++) {
      var token = tokens[i2];
      if (typeof token === "string") {
        path += token;
        continue;
      }
      var value = data ? data[token.name] : void 0;
      var optional = token.modifier === "?" || token.modifier === "*";
      var repeat = token.modifier === "*" || token.modifier === "+";
      if (Array.isArray(value)) {
        if (!repeat) {
          throw new TypeError('Expected "'.concat(token.name, '" to not repeat, but got an array'));
        }
        if (value.length === 0) {
          if (optional)
            continue;
          throw new TypeError('Expected "'.concat(token.name, '" to not be empty'));
        }
        for (var j2 = 0; j2 < value.length; j2++) {
          var segment = encode(value[j2], token);
          if (validate && !matches[i2].test(segment)) {
            throw new TypeError('Expected all "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
          }
          path += token.prefix + segment + token.suffix;
        }
        continue;
      }
      if (typeof value === "string" || typeof value === "number") {
        var segment = encode(String(value), token);
        if (validate && !matches[i2].test(segment)) {
          throw new TypeError('Expected "'.concat(token.name, '" to match "').concat(token.pattern, '", but got "').concat(segment, '"'));
        }
        path += token.prefix + segment + token.suffix;
        continue;
      }
      if (optional)
        continue;
      var typeOfMessage = repeat ? "an array" : "a string";
      throw new TypeError('Expected "'.concat(token.name, '" to be ').concat(typeOfMessage));
    }
    return path;
  };
}
function escapeString(str) {
  return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options) {
  return options && options.sensitive ? "" : "i";
}

// node_modules/@hitachivantara/app-shell/dist/esm/lib/utils/navigationUtil.js
var m = (t7) => {
  const {
    target: e2
  } = t7;
  return e2 || (t7.submenus ? m(t7.submenus[0]) : "");
};
var z = (t7, e2, r2, n2) => r2 !== void 0 && r2 <= 0 ? [] : (e2 == null ? void 0 : e2.reduce((o5, s3, l) => {
  var d3;
  const i2 = {
    id: n2 ? `${n2.id}-${l}` : `${l}`,
    label: t7(s3.label),
    href: m(s3),
    icon: s3.icon ? jsx(r, { name: ((d3 = s3.icon) == null ? void 0 : d3.name) || "" }) : null,
    parent: n2
  };
  if (s3.submenus) {
    const f2 = r2 !== void 0 ? r2 - 1 : void 0, a2 = z(t7, s3.submenus, f2, i2);
    a2.length > 0 && (i2.data = a2);
  }
  return o5.push(i2), o5;
}, [])) || [];
var H = (t7) => t7.reduce((e2, r2) => (r2.data ? e2.push(...H(r2.data)) : e2.push(r2), e2), []);
var L = (t7) => {
  const e2 = t7.split("/").reduce((r2, n2) => {
    if (n2 === "")
      return r2;
    const s3 = `${r2.length === 0 ? "" : r2[0]}/${n2}`;
    return r2.unshift(s3), r2;
  }, []);
  return e2.push("/"), e2;
};
var w = (t7, e2, r2) => {
  let n2, o5;
  const s3 = L(e2);
  return H(t7).some((l) => {
    var c2, h3, g, p2;
    let i2, d3;
    const f2 = (c2 = l.href) == null ? void 0 : c2.indexOf("?");
    if (f2 !== -1 ? (i2 = (h3 = l.href) == null ? void 0 : h3.slice(0, f2).toLowerCase(), d3 = (g = l.href) == null ? void 0 : g.slice(f2, l.href.length).toLowerCase()) : (i2 = (p2 = l.href) == null ? void 0 : p2.toLowerCase(), d3 = ""), i2 && i2.length > 1 && i2.endsWith("/") && (i2 = i2.slice(0, i2.length - 1)), `${i2}${d3}` === r2)
      return n2 = l.id, true;
    const u = s3.find((I) => i2 === I);
    return u && (!o5 || u.length > (o5 == null ? void 0 : o5.length)) && (n2 = l.id, o5 = u), false;
  }), n2;
};
var A = (t7, e2, r2) => {
  if (!e2)
    return;
  const n2 = e2.length > 1 && e2.endsWith("/") ? e2.slice(0, e2.length - 1).toLowerCase() : e2.toLowerCase(), o5 = r2 ? n2.concat(r2.toLowerCase()) : n2;
  return w(t7, n2, o5);
};
var B = (t7, e2) => e2 ? compile(t7, {
  encode: encodeURIComponent,
  validate: false
})(e2) : t7;
var F = (t7, e2) => {
  let r2 = null;
  return t7.some((n2) => {
    const {
      id: o5,
      data: s3
    } = n2;
    return o5 === e2 ? (r2 = n2, true) : s3 && s3.length > 0 ? (r2 = F(s3, e2), r2 !== null) : false;
  }), r2;
};
var M = (t7) => {
  let e2 = null;
  return t7.some((r2) => !r2.data || r2.data.length === 0 ? (e2 = r2, true) : (e2 = M(r2.data), e2 !== null)), e2;
};
var R = (t7) => t7.split("-")[0];
var T = (t7, e2) => e2 ? `${t7}/${e2}`.replace(/([^:]\/)\/+/g, "$1") : t7;
var y = (t7) => t7.map((e2) => {
  const {
    href: r2,
    data: n2,
    ...o5
  } = e2;
  return n2 && n2.length > 0 ? {
    ...o5,
    data: y(n2)
  } : e2;
});

// node_modules/@hitachivantara/app-shell/dist/esm/lib/hooks/useAppShellConfig.js
var import_react4 = __toESM(require_react(), 1);
var t4 = () => (0, import_react4.useContext)(e);
var n = t4;

// node_modules/@hitachivantara/app-shell/dist/esm/lib/hooks/useNavigation.js
var N = (u) => u.viewBundle !== void 0;
var j = () => {
  const u = n(), s3 = (0, import_react5.useContext)(o), c2 = useNavigate(), f2 = (0, import_react5.useCallback)((e2) => {
    var $, v3;
    let t7, r2, l, g;
    N(e2) ? {
      viewBundle: t7,
      pathParams: r2,
      search: l,
      hash: g
    } = e2 : t7 = e2;
    const o5 = t7.replace(/\$/, "_");
    let p2, n2;
    if (o5.startsWith("/"))
      p2 = s3 == null ? void 0 : s3.id, n2 = o5.substring(1);
    else {
      const a2 = o5.split("/");
      a2[0].startsWith("@") ? (p2 = `${a2[0]}/${a2[1]}`, a2.splice(0, 2), n2 = a2.join("/")) : ([p2] = a2, a2.splice(0, 1), n2 = a2.join("/"));
    }
    const m2 = ($ = u.apps) == null ? void 0 : $.find((a2) => a2.id === p2);
    if (m2 == null)
      return;
    const i2 = (v3 = m2.views) == null ? void 0 : v3.find((a2) => a2.bundle === n2 || a2.bundle === `${n2}.js` || a2.bundle === `src/${n2}`);
    return i2 != null && i2.route ? `${B(i2 == null ? void 0 : i2.route, r2)}${l ?? ""}${g ?? ""}` : void 0;
  }, [u, s3 == null ? void 0 : s3.id]), h3 = (0, import_react5.useCallback)((e2, t7) => {
    if (!e2) {
      console.warn("Navigate request to an empty path. Skipping");
      return;
    }
    if (!t7) {
      c2(e2);
      return;
    }
    t7 != null && t7.replace ? c2(e2, {
      replace: true,
      state: t7.state
    }) : c2(e2, {
      state: t7 == null ? void 0 : t7.state
    });
  }, [c2]), k = (0, import_react5.useCallback)((e2, t7) => {
    let r2;
    if (typeof e2 == "string") {
      if (!e2) {
        console.warn("Navigate request to an empty path. Skipping");
        return;
      }
      r2 = e2;
    } else if (N(e2)) {
      const l = f2(e2.viewBundle);
      if (!l) {
        console.warn(`Navigate request to a non existing path [${e2.viewBundle}]. Skipping`);
        return;
      }
      r2 = `${B(l, e2.pathParams)}${e2.search ?? ""}${e2.hash ?? ""}`;
    } else
      r2 = `${e2.pathname}${e2.search ?? ""}${e2.hash ?? ""}`;
    h3(r2, t7);
  }, [f2, h3]);
  return {
    getViewRoute: f2,
    navigate: k
  };
};
var W = j;

// node_modules/@hitachivantara/app-shell/dist/esm/lib/hooks/useMenuItems.js
var import_react6 = __toESM(require_react(), 1);
var F2 = 2;
var L2 = () => {
  const {
    pathname: i2,
    search: u,
    state: n2
  } = useLocation(), m2 = n(), {
    navigate: I
  } = W(), {
    i18n: s3
  } = (0, import_react6.useContext)(o2) ?? {}, c2 = (0, import_react6.useMemo)(() => (s3 == null ? void 0 : s3.getFixedT(s3.language, S)) ?? // should not happen, but fallback if the i18n instance is not available
  ((o5) => o5), [s3]), e2 = (0, import_react6.useMemo)(() => {
    const o5 = m2.navigationMode === "ONLY_TOP" ? F2 : void 0;
    return z(c2, m2.menu, o5);
  }, [m2, c2]), [M2, r2] = (0, import_react6.useState)(void 0), [g, d3] = (0, import_react6.useState)(void 0);
  return (0, import_react6.useEffect)(() => {
    if (!e2.length)
      return;
    if (n2 && n2.selectedItemId) {
      d3(R(n2.selectedItemId));
      const t7 = F(e2, n2.selectedItemId);
      if (t7 != null && t7.data && t7.data.length > 0) {
        const a2 = M(t7.data);
        r2(a2 == null ? void 0 : a2.id);
      } else
        r2(t7 == null ? void 0 : t7.id);
      return;
    }
    const o5 = A(e2, i2, u);
    if (o5) {
      d3(R(o5)), r2(o5);
      return;
    }
    if (i2 === "/" && e2[0].href) {
      I(e2[0].href, {
        state: {
          selectedItemId: e2[0].id
        }
      });
      return;
    }
    d3(void 0), r2(void 0);
  }, [i2, u, n2, e2, I]), {
    items: e2,
    selectedMenuItemId: M2,
    rootMenuItemId: g
  };
};
var U = L2;

// node_modules/@hitachivantara/app-shell/dist/esm/providers/hooks/useNavigationContext.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/@hitachivantara/app-shell/dist/esm/providers/NavigationProvider.js
var import_react7 = __toESM(require_react(), 1);
var w2 = import_react7.default.createContext({
  selectedMenuItemId: void 0,
  rootMenuItemId: void 0,
  items: [],
  verticalNavigationItems: [],
  hasVerticalNavigation: false,
  showHeaderSubMenu: false,
  isCompactMode: false,
  verticalNavigationMode: "EXPANDED",
  switchVerticalNavigationMode: () => {
  }
});
var T2 = ({
  children: E3
}) => {
  const {
    navigationMode: i2
  } = n(), {
    items: t7,
    selectedMenuItemId: u,
    rootMenuItemId: r2
  } = U(), g = useTheme(), e2 = useMediaQuery(g.breakpoints.down("md")), [c2, n2] = (0, import_react7.useState)(e2 ? "CLOSED" : "EXPANDED"), [m2, D] = (0, import_react7.useState)(false), a2 = (0, import_react7.useMemo)(() => {
    var f2;
    if (e2)
      return t7;
    if (i2 === "ONLY_LEFT")
      return y(t7);
    const o5 = r2 && ((f2 = F(t7, r2)) == null ? void 0 : f2.data) || [];
    return y(o5);
  }, [t7, i2, r2, e2]), d3 = (0, import_react7.useMemo)(() => e2 ? true : i2 === "ONLY_TOP" ? false : a2 && a2.length > 0, [i2, a2, e2]);
  (0, import_react7.useEffect)(() => {
    n2(e2 ? "CLOSED" : "EXPANDED");
  }, [e2]), (0, import_react7.useEffect)(() => {
    D(i2 === "ONLY_TOP" && t7.some((o5) => o5.data && o5.data.length > 0));
  }, [i2, t7]);
  const l = (0, import_react7.useCallback)(() => {
    n2((o5) => e2 ? o5 === "CLOSED" ? "EXPANDED" : "CLOSED" : o5 === "COLLAPSED" ? "EXPANDED" : "COLLAPSED");
  }, [e2]), h3 = (0, import_react7.useMemo)(() => ({
    selectedMenuItemId: u,
    rootMenuItemId: r2,
    items: t7,
    verticalNavigationItems: a2,
    hasVerticalNavigation: d3,
    showHeaderSubMenu: m2,
    isCompactMode: e2,
    verticalNavigationMode: c2,
    switchVerticalNavigationMode: l
  }), [u, r2, t7, a2, d3, m2, e2, c2, l]);
  return jsx(w2.Provider, { value: h3, children: E3 });
};
var _ = T2;

// node_modules/@hitachivantara/app-shell/dist/esm/providers/hooks/useNavigationContext.js
var i = () => {
  const t7 = (0, import_react8.useContext)(w2);
  return t7 === void 0 && console.error("NavigationContext was used outside of its Provider"), t7;
};
var s2 = i;

// node_modules/@hitachivantara/app-shell/dist/esm/components/layout/Main/styles.js
var W2 = 68;
var B2 = createStyled("div", false ? {
  target: "e19vcsjw1"
} : {
  target: "e19vcsjw1",
  label: "StyledContainer"
})("display:flex;margin-top:", (l) => l.showHeaderSubMenu && !l.isCompactMode ? `calc(${theme.header.height} + ${W2}px)` : theme.header.height, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrQndEIiwiZmlsZSI6Ii9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSBcIkBlbW90aW9uL3N0eWxlZFwiO1xuXG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gXCJAaGl0YWNoaXZhbnRhcmEvdWlraXQtcmVhY3QtY29yZVwiO1xuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiB0aGUgc3ViIGhlYWRlciBzaG91bGQgYmUgY29taW5nIGZyb20gVUktS0lULCBhdCB0aGlzIHRpbWUgaXQgaXMgbm90LCBzbyB3ZSBhcmUgaGFyZGNvZGluZyB0aGUgdmFsdWVcbiAqIGhlcmUuIDY0cHggZm9yIHRoZSBoZWlnaHQgYW5kIGFuIGV4dHJhIDRweCBmb3IgdGhlIHRvcCBwYWRkaW5nLlxuICovXG5leHBvcnQgY29uc3QgU1VCX0hFQURFUl9IRUlHSFQgPSA2ODtcblxuaW50ZXJmYWNlIFN0eWxlZENvbnRhaW5lclByb3BzIHtcbiAgc2hvd0hlYWRlclN1Yk1lbnU/OiBib29sZWFuO1xuICBpc0NvbXBhY3RNb2RlPzogYm9vbGVhbjtcbn1cbmludGVyZmFjZSBTdHlsZWRNYWluUHJvcHMge1xuICBwYWRkaW5nVG9wPzogbnVtYmVyO1xufVxuXG5jb25zdCBTdHlsZWRDb250YWluZXIgPSBzdHlsZWQuZGl2PFN0eWxlZENvbnRhaW5lclByb3BzPmBcbiAgZGlzcGxheTogZmxleDtcbiAgbWFyZ2luLXRvcDogJHtwcm9wcyA9PiB7XG4gICAgaWYgKHByb3BzLnNob3dIZWFkZXJTdWJNZW51ICYmICFwcm9wcy5pc0NvbXBhY3RNb2RlKSB7XG4gICAgICByZXR1cm4gYGNhbGMoJHt0aGVtZS5oZWFkZXIuaGVpZ2h0fSArICR7U1VCX0hFQURFUl9IRUlHSFR9cHgpYDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhlbWUuaGVhZGVyLmhlaWdodDtcbiAgfX07XG5gO1xuXG5jb25zdCBTdHlsZWRNYWluID0gc3R5bGVkLm1haW48U3R5bGVkTWFpblByb3BzPmBcbiAgZmxleDogMTtcbiAgcGFkZGluZy10b3A6ICR7cHJvcHMgPT4ge1xuICAgIHJldHVybiBgJHtwcm9wcy5wYWRkaW5nVG9wfXB4YDtcbiAgfX07XG5gO1xuXG5leHBvcnQgeyBTdHlsZWRDb250YWluZXIsIFN0eWxlZE1haW4gfTtcbiJdfQ== */"));
var G = createStyled("main", false ? {
  target: "e19vcsjw0"
} : {
  target: "e19vcsjw0",
  label: "StyledMain"
})("flex:1;padding-top:", (l) => `${l.paddingTop}px`, ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUE2QitDIiwiZmlsZSI6Ii9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlcy50cyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHlsZWQgZnJvbSBcIkBlbW90aW9uL3N0eWxlZFwiO1xuXG5pbXBvcnQgeyB0aGVtZSB9IGZyb20gXCJAaGl0YWNoaXZhbnRhcmEvdWlraXQtcmVhY3QtY29yZVwiO1xuXG4vKipcbiAqIFRoZSB2YWx1ZSBvZiB0aGUgc3ViIGhlYWRlciBzaG91bGQgYmUgY29taW5nIGZyb20gVUktS0lULCBhdCB0aGlzIHRpbWUgaXQgaXMgbm90LCBzbyB3ZSBhcmUgaGFyZGNvZGluZyB0aGUgdmFsdWVcbiAqIGhlcmUuIDY0cHggZm9yIHRoZSBoZWlnaHQgYW5kIGFuIGV4dHJhIDRweCBmb3IgdGhlIHRvcCBwYWRkaW5nLlxuICovXG5leHBvcnQgY29uc3QgU1VCX0hFQURFUl9IRUlHSFQgPSA2ODtcblxuaW50ZXJmYWNlIFN0eWxlZENvbnRhaW5lclByb3BzIHtcbiAgc2hvd0hlYWRlclN1Yk1lbnU/OiBib29sZWFuO1xuICBpc0NvbXBhY3RNb2RlPzogYm9vbGVhbjtcbn1cbmludGVyZmFjZSBTdHlsZWRNYWluUHJvcHMge1xuICBwYWRkaW5nVG9wPzogbnVtYmVyO1xufVxuXG5jb25zdCBTdHlsZWRDb250YWluZXIgPSBzdHlsZWQuZGl2PFN0eWxlZENvbnRhaW5lclByb3BzPmBcbiAgZGlzcGxheTogZmxleDtcbiAgbWFyZ2luLXRvcDogJHtwcm9wcyA9PiB7XG4gICAgaWYgKHByb3BzLnNob3dIZWFkZXJTdWJNZW51ICYmICFwcm9wcy5pc0NvbXBhY3RNb2RlKSB7XG4gICAgICByZXR1cm4gYGNhbGMoJHt0aGVtZS5oZWFkZXIuaGVpZ2h0fSArICR7U1VCX0hFQURFUl9IRUlHSFR9cHgpYDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhlbWUuaGVhZGVyLmhlaWdodDtcbiAgfX07XG5gO1xuXG5jb25zdCBTdHlsZWRNYWluID0gc3R5bGVkLm1haW48U3R5bGVkTWFpblByb3BzPmBcbiAgZmxleDogMTtcbiAgcGFkZGluZy10b3A6ICR7cHJvcHMgPT4ge1xuICAgIHJldHVybiBgJHtwcm9wcy5wYWRkaW5nVG9wfXB4YDtcbiAgfX07XG5gO1xuXG5leHBvcnQgeyBTdHlsZWRDb250YWluZXIsIFN0eWxlZE1haW4gfTtcbiJdfQ== */"));

// node_modules/@hitachivantara/app-shell/dist/esm/pages/ErrorPage/styles.js
function W3() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var X = ({
  showHeaderSubMenu: l,
  isCompactMode: Z,
  fullPage: G2
}) => G2 ? "100vh" : l && !Z ? `calc(100vh - (${theme.header.height} + ${W2}px + ${theme.space.lg} + ${theme.space.lg}))` : `calc(100vh - (${theme.header.height} + ${theme.space.lg} + ${theme.space.lg}))`;
var d2 = createStyled("div", false ? {
  target: "e9ctq072"
} : {
  target: "e9ctq072",
  label: "StyledErrorPage"
})("flex:1;display:flex;flex-direction:column;margin-top:", theme.space.lg, ";height:", (l) => X(l), ";" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9wYWdlcy9FcnJvclBhZ2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlDd0QiLCJmaWxlIjoiL19fdy9odi1hcHAtc2hlbGwvaHYtYXBwLXNoZWxsL2NsaWVudC9wYWNrYWdlcy9hcHAtc2hlbGwvc3JjL3BhZ2VzL0Vycm9yUGFnZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJAZW1vdGlvbi9zdHlsZWRcIjtcclxuXHJcbmltcG9ydCB7IHRoZW1lIH0gZnJvbSBcIkBoaXRhY2hpdmFudGFyYS91aWtpdC1yZWFjdC1jb3JlXCI7XHJcblxyXG5pbXBvcnQgeyBTVUJfSEVBREVSX0hFSUdIVCB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlc1wiO1xyXG5cclxuaW50ZXJmYWNlIFN0eWxlZEVycm9yUGFnZVByb3BzIHtcclxuICBzaG93SGVhZGVyU3ViTWVudT86IGJvb2xlYW47XHJcbiAgaXNDb21wYWN0TW9kZT86IGJvb2xlYW47XHJcbiAgZnVsbFBhZ2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3R5bGVkSW1hZ2VXcmFwcGVyUHJvcHMge1xyXG4gIGJhY2tncm91bmRJbWFnZTogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSB3cmFwcGVyIGJhc2VkIG9uIHRoZSBoZWFkZXIgc3ViIG1lbnUgYW5kIGNvbXBhY3QgbW9kZS5cclxuICovXHJcbmNvbnN0IGNhbGNIZWlnaHQgPSAoe1xyXG4gIHNob3dIZWFkZXJTdWJNZW51LFxyXG4gIGlzQ29tcGFjdE1vZGUsXHJcbiAgZnVsbFBhZ2VcclxufTogU3R5bGVkRXJyb3JQYWdlUHJvcHMpID0+IHtcclxuICBpZiAoZnVsbFBhZ2UpIHtcclxuICAgIHJldHVybiBgMTAwdmhgO1xyXG4gIH1cclxuICBpZiAoc2hvd0hlYWRlclN1Yk1lbnUgJiYgIWlzQ29tcGFjdE1vZGUpIHtcclxuICAgIHJldHVybiBgY2FsYygxMDB2aCAtICgke3RoZW1lLmhlYWRlci5oZWlnaHR9ICsgJHtTVUJfSEVBREVSX0hFSUdIVH1weCArICR7dGhlbWUuc3BhY2UubGd9ICsgJHt0aGVtZS5zcGFjZS5sZ30pKWA7XHJcbiAgfVxyXG4gIHJldHVybiBgY2FsYygxMDB2aCAtICgke3RoZW1lLmhlYWRlci5oZWlnaHR9ICsgJHt0aGVtZS5zcGFjZS5sZ30gKyAke3RoZW1lLnNwYWNlLmxnfSkpYDtcclxufTtcclxuXHJcbmNvbnN0IFN0eWxlZEVycm9yUGFnZSA9IHN0eWxlZC5kaXY8U3R5bGVkRXJyb3JQYWdlUHJvcHM+YFxyXG4gIGZsZXg6IDE7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2UubGd9O1xyXG4gIGhlaWdodDogJHsocHJvcHM6IFN0eWxlZEVycm9yUGFnZVByb3BzKSA9PiBjYWxjSGVpZ2h0KHByb3BzKX07XHJcbmA7XHJcblxyXG5jb25zdCBTdHlsZWRJbWFnZVdyYXBwZXIgPSBzdHlsZWQuZGl2PFN0eWxlZEltYWdlV3JhcHBlclByb3BzPmBcclxuICBmbGV4OiAxO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgYmFja2dyb3VuZC1pbWFnZTogJHtwcm9wcyA9PiBwcm9wcy5iYWNrZ3JvdW5kSW1hZ2V9O1xyXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcclxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyO1xyXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbmA7XHJcblxyXG5jb25zdCBTdHlsZWRUaXRsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxyXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcclxuYDtcclxuXHJcbmV4cG9ydCB7IFN0eWxlZFRpdGxlV3JhcHBlciwgU3R5bGVkRXJyb3JQYWdlLCBTdHlsZWRJbWFnZVdyYXBwZXIgfTtcclxuIl19 */"));
var t5 = createStyled("div", false ? {
  target: "e9ctq071"
} : {
  target: "e9ctq071",
  label: "StyledImageWrapper"
})("flex:1;display:flex;background-image:", (l) => l.backgroundImage, ";background-size:contain;background-position:center center;background-repeat:no-repeat;flex-direction:column;height:100%;" + (false ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9wYWdlcy9FcnJvclBhZ2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQXlDOEQiLCJmaWxlIjoiL19fdy9odi1hcHAtc2hlbGwvaHYtYXBwLXNoZWxsL2NsaWVudC9wYWNrYWdlcy9hcHAtc2hlbGwvc3JjL3BhZ2VzL0Vycm9yUGFnZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJAZW1vdGlvbi9zdHlsZWRcIjtcclxuXHJcbmltcG9ydCB7IHRoZW1lIH0gZnJvbSBcIkBoaXRhY2hpdmFudGFyYS91aWtpdC1yZWFjdC1jb3JlXCI7XHJcblxyXG5pbXBvcnQgeyBTVUJfSEVBREVSX0hFSUdIVCB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlc1wiO1xyXG5cclxuaW50ZXJmYWNlIFN0eWxlZEVycm9yUGFnZVByb3BzIHtcclxuICBzaG93SGVhZGVyU3ViTWVudT86IGJvb2xlYW47XHJcbiAgaXNDb21wYWN0TW9kZT86IGJvb2xlYW47XHJcbiAgZnVsbFBhZ2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3R5bGVkSW1hZ2VXcmFwcGVyUHJvcHMge1xyXG4gIGJhY2tncm91bmRJbWFnZTogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSB3cmFwcGVyIGJhc2VkIG9uIHRoZSBoZWFkZXIgc3ViIG1lbnUgYW5kIGNvbXBhY3QgbW9kZS5cclxuICovXHJcbmNvbnN0IGNhbGNIZWlnaHQgPSAoe1xyXG4gIHNob3dIZWFkZXJTdWJNZW51LFxyXG4gIGlzQ29tcGFjdE1vZGUsXHJcbiAgZnVsbFBhZ2VcclxufTogU3R5bGVkRXJyb3JQYWdlUHJvcHMpID0+IHtcclxuICBpZiAoZnVsbFBhZ2UpIHtcclxuICAgIHJldHVybiBgMTAwdmhgO1xyXG4gIH1cclxuICBpZiAoc2hvd0hlYWRlclN1Yk1lbnUgJiYgIWlzQ29tcGFjdE1vZGUpIHtcclxuICAgIHJldHVybiBgY2FsYygxMDB2aCAtICgke3RoZW1lLmhlYWRlci5oZWlnaHR9ICsgJHtTVUJfSEVBREVSX0hFSUdIVH1weCArICR7dGhlbWUuc3BhY2UubGd9ICsgJHt0aGVtZS5zcGFjZS5sZ30pKWA7XHJcbiAgfVxyXG4gIHJldHVybiBgY2FsYygxMDB2aCAtICgke3RoZW1lLmhlYWRlci5oZWlnaHR9ICsgJHt0aGVtZS5zcGFjZS5sZ30gKyAke3RoZW1lLnNwYWNlLmxnfSkpYDtcclxufTtcclxuXHJcbmNvbnN0IFN0eWxlZEVycm9yUGFnZSA9IHN0eWxlZC5kaXY8U3R5bGVkRXJyb3JQYWdlUHJvcHM+YFxyXG4gIGZsZXg6IDE7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2UubGd9O1xyXG4gIGhlaWdodDogJHsocHJvcHM6IFN0eWxlZEVycm9yUGFnZVByb3BzKSA9PiBjYWxjSGVpZ2h0KHByb3BzKX07XHJcbmA7XHJcblxyXG5jb25zdCBTdHlsZWRJbWFnZVdyYXBwZXIgPSBzdHlsZWQuZGl2PFN0eWxlZEltYWdlV3JhcHBlclByb3BzPmBcclxuICBmbGV4OiAxO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgYmFja2dyb3VuZC1pbWFnZTogJHtwcm9wcyA9PiBwcm9wcy5iYWNrZ3JvdW5kSW1hZ2V9O1xyXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcclxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyO1xyXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbmA7XHJcblxyXG5jb25zdCBTdHlsZWRUaXRsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxyXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcclxuYDtcclxuXHJcbmV4cG9ydCB7IFN0eWxlZFRpdGxlV3JhcHBlciwgU3R5bGVkRXJyb3JQYWdlLCBTdHlsZWRJbWFnZVdyYXBwZXIgfTtcclxuIl19 */"));
var J = createStyled("div", false ? {
  target: "e9ctq070"
} : {
  target: "e9ctq070",
  label: "StyledTitleWrapper"
})(false ? {
  name: "1azakc",
  styles: "text-align:center"
} : {
  name: "1azakc",
  styles: "text-align:center",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9wYWdlcy9FcnJvclBhZ2Uvc3R5bGVzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQW9EcUMiLCJmaWxlIjoiL19fdy9odi1hcHAtc2hlbGwvaHYtYXBwLXNoZWxsL2NsaWVudC9wYWNrYWdlcy9hcHAtc2hlbGwvc3JjL3BhZ2VzL0Vycm9yUGFnZS9zdHlsZXMudHMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgc3R5bGVkIGZyb20gXCJAZW1vdGlvbi9zdHlsZWRcIjtcclxuXHJcbmltcG9ydCB7IHRoZW1lIH0gZnJvbSBcIkBoaXRhY2hpdmFudGFyYS91aWtpdC1yZWFjdC1jb3JlXCI7XHJcblxyXG5pbXBvcnQgeyBTVUJfSEVBREVSX0hFSUdIVCB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL2xheW91dC9NYWluL3N0eWxlc1wiO1xyXG5cclxuaW50ZXJmYWNlIFN0eWxlZEVycm9yUGFnZVByb3BzIHtcclxuICBzaG93SGVhZGVyU3ViTWVudT86IGJvb2xlYW47XHJcbiAgaXNDb21wYWN0TW9kZT86IGJvb2xlYW47XHJcbiAgZnVsbFBhZ2U/OiBib29sZWFuO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU3R5bGVkSW1hZ2VXcmFwcGVyUHJvcHMge1xyXG4gIGJhY2tncm91bmRJbWFnZTogc3RyaW5nO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSB3cmFwcGVyIGJhc2VkIG9uIHRoZSBoZWFkZXIgc3ViIG1lbnUgYW5kIGNvbXBhY3QgbW9kZS5cclxuICovXHJcbmNvbnN0IGNhbGNIZWlnaHQgPSAoe1xyXG4gIHNob3dIZWFkZXJTdWJNZW51LFxyXG4gIGlzQ29tcGFjdE1vZGUsXHJcbiAgZnVsbFBhZ2VcclxufTogU3R5bGVkRXJyb3JQYWdlUHJvcHMpID0+IHtcclxuICBpZiAoZnVsbFBhZ2UpIHtcclxuICAgIHJldHVybiBgMTAwdmhgO1xyXG4gIH1cclxuICBpZiAoc2hvd0hlYWRlclN1Yk1lbnUgJiYgIWlzQ29tcGFjdE1vZGUpIHtcclxuICAgIHJldHVybiBgY2FsYygxMDB2aCAtICgke3RoZW1lLmhlYWRlci5oZWlnaHR9ICsgJHtTVUJfSEVBREVSX0hFSUdIVH1weCArICR7dGhlbWUuc3BhY2UubGd9ICsgJHt0aGVtZS5zcGFjZS5sZ30pKWA7XHJcbiAgfVxyXG4gIHJldHVybiBgY2FsYygxMDB2aCAtICgke3RoZW1lLmhlYWRlci5oZWlnaHR9ICsgJHt0aGVtZS5zcGFjZS5sZ30gKyAke3RoZW1lLnNwYWNlLmxnfSkpYDtcclxufTtcclxuXHJcbmNvbnN0IFN0eWxlZEVycm9yUGFnZSA9IHN0eWxlZC5kaXY8U3R5bGVkRXJyb3JQYWdlUHJvcHM+YFxyXG4gIGZsZXg6IDE7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xyXG4gIG1hcmdpbi10b3A6ICR7dGhlbWUuc3BhY2UubGd9O1xyXG4gIGhlaWdodDogJHsocHJvcHM6IFN0eWxlZEVycm9yUGFnZVByb3BzKSA9PiBjYWxjSGVpZ2h0KHByb3BzKX07XHJcbmA7XHJcblxyXG5jb25zdCBTdHlsZWRJbWFnZVdyYXBwZXIgPSBzdHlsZWQuZGl2PFN0eWxlZEltYWdlV3JhcHBlclByb3BzPmBcclxuICBmbGV4OiAxO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgYmFja2dyb3VuZC1pbWFnZTogJHtwcm9wcyA9PiBwcm9wcy5iYWNrZ3JvdW5kSW1hZ2V9O1xyXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcclxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyO1xyXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBoZWlnaHQ6IDEwMCU7XHJcbmA7XHJcblxyXG5jb25zdCBTdHlsZWRUaXRsZVdyYXBwZXIgPSBzdHlsZWQuZGl2YFxyXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcclxuYDtcclxuXHJcbmV4cG9ydCB7IFN0eWxlZFRpdGxlV3JhcHBlciwgU3R5bGVkRXJyb3JQYWdlLCBTdHlsZWRJbWFnZVdyYXBwZXIgfTtcclxuIl19 */",
  toString: W3
});

// node_modules/react-error-boundary/dist/react-error-boundary.esm.js
var import_react9 = __toESM(require_react());
var ErrorBoundaryContext = (0, import_react9.createContext)(null);
var initialState = {
  didCatch: false,
  error: null
};
var ErrorBoundary = class extends import_react9.Component {
  constructor(props) {
    super(props);
    this.resetErrorBoundary = this.resetErrorBoundary.bind(this);
    this.state = initialState;
  }
  static getDerivedStateFromError(error) {
    return {
      didCatch: true,
      error
    };
  }
  resetErrorBoundary() {
    const {
      error
    } = this.state;
    if (error !== null) {
      var _this$props$onReset, _this$props;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
        args,
        reason: "imperative-api"
      });
      this.setState(initialState);
    }
  }
  componentDidCatch(error, info) {
    var _this$props$onError, _this$props2;
    (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
  }
  componentDidUpdate(prevProps, prevState) {
    const {
      didCatch
    } = this.state;
    const {
      resetKeys
    } = this.props;
    if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
      var _this$props$onReset2, _this$props3;
      (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
        next: resetKeys,
        prev: prevProps.resetKeys,
        reason: "keys"
      });
      this.setState(initialState);
    }
  }
  render() {
    const {
      children,
      fallbackRender,
      FallbackComponent,
      fallback
    } = this.props;
    const {
      didCatch,
      error
    } = this.state;
    let childToRender = children;
    if (didCatch) {
      const props = {
        error,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if ((0, import_react9.isValidElement)(fallback)) {
        childToRender = fallback;
      } else if (typeof fallbackRender === "function") {
        childToRender = fallbackRender(props);
      } else if (FallbackComponent) {
        childToRender = (0, import_react9.createElement)(FallbackComponent, props);
      } else {
        throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
      }
    }
    return (0, import_react9.createElement)(ErrorBoundaryContext.Provider, {
      value: {
        didCatch,
        error,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, childToRender);
  }
};
function hasArrayChanged() {
  let a2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  let b = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return a2.length !== b.length || a2.some((item, index) => !Object.is(item, b[index]));
}
function assertErrorBoundaryContext(value) {
  if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") {
    throw new Error("ErrorBoundaryContext not found");
  }
  return true;
}
function useErrorBoundary() {
  const context = (0, import_react9.useContext)(ErrorBoundaryContext);
  assertErrorBoundaryContext(context);
  const [state, setState] = (0, import_react9.useState)({
    error: null,
    hasError: false
  });
  const memoized = (0, import_react9.useMemo)(() => ({
    resetBoundary: () => {
      context === null || context === void 0 ? void 0 : context.resetErrorBoundary();
      setState({
        error: null,
        hasError: false
      });
    },
    showBoundary: (error) => setState({
      error,
      hasError: true
    })
  }), [context === null || context === void 0 ? void 0 : context.resetErrorBoundary]);
  if (state.hasError) {
    throw state.error;
  }
  return memoized;
}

// node_modules/@hitachivantara/app-shell/dist/esm/pages/ErrorPage/Footer/styles.js
function c() {
  return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
}
var t6 = createStyled("div", false ? {
  target: "efun0d10"
} : {
  target: "efun0d10",
  label: "FooterWrapper"
})(false ? {
  name: "1azakc",
  styles: "text-align:center"
} : {
  name: "1azakc",
  styles: "text-align:center",
  map: "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9fX3cvaHYtYXBwLXNoZWxsL2h2LWFwcC1zaGVsbC9jbGllbnQvcGFja2FnZXMvYXBwLXNoZWxsL3NyYy9wYWdlcy9FcnJvclBhZ2UvRm9vdGVyL3N0eWxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFFdUMiLCJmaWxlIjoiL19fdy9odi1hcHAtc2hlbGwvaHYtYXBwLXNoZWxsL2NsaWVudC9wYWNrYWdlcy9hcHAtc2hlbGwvc3JjL3BhZ2VzL0Vycm9yUGFnZS9Gb290ZXIvc3R5bGVzLnRzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0eWxlZCBmcm9tIFwiQGVtb3Rpb24vc3R5bGVkXCI7XHJcblxyXG5leHBvcnQgY29uc3QgRm9vdGVyV3JhcHBlciA9IHN0eWxlZC5kaXZgXHJcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xyXG5gO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgRm9vdGVyV3JhcHBlcjtcclxuIl19 */",
  toString: c
});
var a = t6;

// node_modules/@hitachivantara/app-shell/dist/esm/pages/ErrorPage/Footer/Footer.js
var F3 = () => {
  const {
    t: a2
  } = useTranslation(), {
    navigate: i2
  } = W(), {
    navigationMode: l
  } = n(), {
    resetBoundary: s3
  } = useErrorBoundary(), {
    items: o5,
    verticalNavigationItems: r2,
    isCompactMode: m2
  } = s2(), t7 = (() => !m2 && l !== "ONLY_LEFT" ? o5.length > 0 ? o5[0] : null : r2.length > 0 ? r2[0] : null)(), c2 = (p2) => {
    p2.preventDefault(), t7 != null && t7.href && (s3(), i2(t7.href, {
      state: {
        selectedItemId: t7.id
      }
    }));
  };
  return t7 && jsx(a, { children: jsx(HvTypography, { variant: "body", children: jsx(Trans, { t: a2, i18nKey: "errors.footer", values: {
    label: t7.label
  }, components: {
    navigate: jsx(HvTypography, { link: true, component: "a", href: t7.href, variant: "label", onClick: c2, children: t7.label })
  } }) }) });
};
var E = F3;

// node_modules/@hitachivantara/app-shell/dist/esm/pages/ErrorPage/ErrorPage.js
var h2 = ({
  code: e2 = void 0,
  title: i2,
  background: l,
  backgroundLabel: m2,
  fullPage: n2 = false,
  includeFooter: p2 = true
}) => {
  const {
    isCompactMode: o5,
    showHeaderSubMenu: s3
  } = s2();
  return jsxs(d2, { showHeaderSubMenu: s3, isCompactMode: o5, fullPage: n2, children: [
    jsxs(J, { children: [
      e2 && jsx(HvTypography, { variant: "title1", children: e2 }),
      jsx(HvTypography, { variant: o5 ? "xsTitle" : "display", children: i2 })
    ] }),
    jsx(t5, { backgroundImage: l, role: "img", "aria-label": m2 }),
    p2 && jsx(E, {})
  ] });
};
var E2 = h2;

export {
  useLocation,
  Route,
  Routes,
  BrowserRouter,
  useBeforeUnload,
  e,
  o,
  o2,
  T,
  n,
  W,
  U,
  ErrorBoundary,
  _,
  s2 as s,
  W2,
  B2 as B,
  G,
  E2 as E
};
/*! Bundled license information:

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.7.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.14.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.14.2
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=chunk-EOJNCN7I.js.map

{"version":3,"file":"navigationUtil.js","sources":["../../../../src/lib/utils/navigationUtil.tsx"],"sourcesContent":["import { HvAppShellMenuConfig } from \"@hitachivantara/app-shell-shared\";\nimport { compile } from \"path-to-regexp\";\nimport { MenuItem } from \"../types\";\nimport IconUiKit from \"../../components/IconUiKit\";\n\n/**\n * Compute the target href for menu item.\n *\n * @param menuItem The root target href.\n *\n * @returns The menu item target href. If empty, returns the first child that has it defined or empty string if none.\n */\nconst getMenuTargetHref = (menuItem: HvAppShellMenuConfig): string => {\n  const { target } = menuItem;\n  if (target) {\n    return target;\n  }\n\n  if (menuItem.submenus) {\n    return getMenuTargetHref(menuItem.submenus[0]);\n  }\n\n  return \"\";\n};\n\n/**\n * Creates a navigation data structure ({@link MenuItem}) from the provided menu configuration ({@link HvAppShellMenuConfig}).\n *\n * @param t\n * @param menuItems The set of menu items from configuration.\n * @param maxDepth The maximum depth up until the recursiveness should occur for the creation of the menu items.\n * @param parentMenuItem The parent menu item of the set of menu items.\n *\n * @returns An array of {@link MenuItem}.\n */\nconst createMenuItems = (\n  t: (key: string) => string,\n  menuItems?: HvAppShellMenuConfig[],\n  maxDepth?: number,\n  parentMenuItem?: MenuItem\n): MenuItem[] => {\n  if (maxDepth !== undefined && maxDepth <= 0) {\n    return [];\n  }\n\n  return (\n    menuItems?.reduce<MenuItem[]>((accumulator, currentValue, index) => {\n      const navItem: MenuItem = {\n        id: parentMenuItem ? `${parentMenuItem.id}-${index}` : `${index}`,\n        label: t(currentValue.label),\n        href: getMenuTargetHref(currentValue),\n        icon: currentValue.icon\n          ? ((\n              <IconUiKit name={currentValue.icon?.name || \"\"} />\n            ) as React.ReactNode)\n          : null,\n\n        parent: parentMenuItem\n      };\n\n      if (currentValue.submenus) {\n        const updatedDepth = maxDepth !== undefined ? maxDepth - 1 : undefined;\n        const data = createMenuItems(\n          t,\n          currentValue.submenus,\n          updatedDepth,\n          navItem\n        );\n        if (data.length > 0) {\n          navItem.data = data;\n        }\n      }\n\n      accumulator.push(navItem);\n      return accumulator;\n    }, []) || []\n  );\n};\n\n/**\n * Removes the items that do not have path and replaces it by its children, recursively.\n *\n * @param items The list of {@link MenuItem}.\n *\n * @returns A flat array of {@link MenuItem}.\n */\nconst flatMenuItems = (items: MenuItem[]) => {\n  return items.reduce<MenuItem[]>((acc, item) => {\n    if (item.data) {\n      acc.push(...flatMenuItems(item.data));\n    } else {\n      acc.push(item);\n    }\n\n    return acc;\n  }, []);\n};\n\n/**\n * Helper function that uses a cumulative reduction to derive an array of cumulative hrefs based on the components\n * of the input string.\n * @example\n * // returns ['/', '/app', '/app/details', '/app/details/1']\n * // normalizedHref: \"/app/details/1\"\n *\n * @param normalizedHref The href string to be reduced.\n *\n * @returns the array of cumulative hrefs.\n */\nconst decomposeHrefStringToArray = (normalizedHref: string): string[] => {\n  const hrefArray = normalizedHref\n    .split(\"/\")\n    .reduce<string[]>((accumulator, currentValue) => {\n      if (currentValue === \"\") {\n        return accumulator;\n      }\n\n      const prefix = accumulator.length === 0 ? \"\" : accumulator[0];\n      const href = `${prefix}/${currentValue}`;\n      accumulator.unshift(href);\n      return accumulator;\n    }, []);\n\n  hrefArray.push(\"/\");\n\n  return hrefArray;\n};\n\n/**\n * Algorithm implementation of the searchHrefInMenuItems function.\n *\n * @returns An object containing an item id or empty, if no match is found, and a flag to indicate if a\n * full href match was found. If the id is filled but the flag is 'false', then only partial match was found.\n */\nconst searchHrefMatch = (\n  items: MenuItem[],\n  normalizedHref: string,\n  normalizedFullHref: string\n): string | undefined => {\n  let toBeSelectedId: string | undefined;\n  let toBeSelectedHref: string | undefined;\n\n  const reducedNormalizedHref = decomposeHrefStringToArray(normalizedHref);\n\n  flatMenuItems(items).some(item => {\n    let normalizedItemHref: string | undefined;\n    let normalizedItemHrefParams: string | undefined;\n\n    const idx = item.href?.indexOf(\"?\");\n    if (idx !== -1) {\n      normalizedItemHref = item.href?.slice(0, idx).toLowerCase();\n      normalizedItemHrefParams = item.href\n        ?.slice(idx, item.href.length)\n        .toLowerCase();\n    } else {\n      normalizedItemHref = item.href?.toLowerCase();\n      normalizedItemHrefParams = \"\";\n    }\n\n    if (\n      normalizedItemHref &&\n      normalizedItemHref.length > 1 &&\n      normalizedItemHref.endsWith(\"/\")\n    ) {\n      normalizedItemHref = normalizedItemHref.slice(\n        0,\n        normalizedItemHref.length - 1\n      );\n    }\n\n    const normalizedFullItemHref = `${normalizedItemHref}${normalizedItemHrefParams}`;\n\n    // if the normalized full href is met, then search is complete\n    if (normalizedFullItemHref === normalizedFullHref) {\n      toBeSelectedId = item.id;\n      return true;\n    }\n\n    // since it is not a full href match, we want to keep searching for a full href match,\n    // while storing only the first/longer partial match found\n    const matchedHref = reducedNormalizedHref.find(\n      (href: string) => normalizedItemHref === href\n    );\n    if (\n      matchedHref &&\n      (!toBeSelectedHref || matchedHref.length > toBeSelectedHref?.length)\n    ) {\n      toBeSelectedId = item.id;\n      toBeSelectedHref = matchedHref;\n    }\n\n    return false;\n  });\n\n  return toBeSelectedId;\n};\n\n/**\n * Searches for the href and parameters on all the menu items and its children until an exact match is found. If no\n * exact match is found but partial is, then the parent id for the first partial match found is returned.\n * @example\n * // returns '2'\n * // href: '/home', parameters: '?x=y', items: [{id:'1', href:'/home?z=v'},{id:'2', href:'/home'}\n *\n * For consistency purposes and based on the Router behavior, if either the href or the item href\n * (stripped of its query params) ends with a forward slash, then the comparison will ignore it\n * @example\n * // returns '1'\n * // href: '/home/', parameters: <empty>, items: [{id:'1', href:'/home'}]\n *\n * @param items The list of menu items to be searched.\n * @param href The url href after the domain up to the query parameters.\n * @param [parameters] The url query string after pathname.\n *\n * @returns The id of a parent menu item or an empty string.\n */\nconst searchHrefInMenuItems = (\n  items: MenuItem[],\n  href: string,\n  parameters?: string\n): string | undefined => {\n  if (!href) {\n    return undefined;\n  }\n\n  const normalizedHref =\n    href.length > 1 && href.endsWith(\"/\")\n      ? href.slice(0, href.length - 1).toLowerCase()\n      : href.toLowerCase();\n\n  const normalizedFullHref = parameters\n    ? normalizedHref.concat(parameters.toLowerCase())\n    : normalizedHref;\n\n  return searchHrefMatch(items, normalizedHref, normalizedFullHref);\n};\n\n/**\n * Utility that replaces the href placeholders with the href options provided.\n * The href parameter must not contain 'search' nor 'hash' parts.\n * @example\n * // returns '/home/2'\n * // href: '/home/:id', hrefOptions: '{id: 2}'\n *\n * @param href The string to be compiled.\n * @param hrefOptions The options to replace the placeholders on the href.\n *\n * @returns The compiled href\n */\nconst compileHref = (\n  href: string,\n  hrefOptions?: Record<string, string>\n): string => {\n  if (!hrefOptions) {\n    return href;\n  }\n\n  const compiler = compile(href, {\n    encode: encodeURIComponent,\n    validate: false\n  });\n\n  return compiler(hrefOptions);\n};\n\n/**\n * Searches for an item with the specified id.\n *\n * @param {MenuItem[]} data - The navigation data structure.\n * @param {string} itemId - The item id.\n * @returns The item with matching id.\n */\nconst findItemById = (data: MenuItem[], itemId: string): MenuItem | null => {\n  let foundItem: MenuItem | null = null;\n  data.some(obj => {\n    const { id: objId, data: childData } = obj;\n    if (objId === itemId) {\n      foundItem = obj;\n      return true;\n    }\n    if (childData && childData.length > 0) {\n      foundItem = findItemById(childData, itemId);\n      return foundItem !== null;\n    }\n    return false;\n  });\n  return foundItem;\n};\n\n/**\n * Finds the first leaf item (item with children) inside the received structure.\n *\n * @param {MenuItem[]} data - The navigation data structure.\n * @returns - The first leaf item inside the structure.\n */\nconst findFirstLeafItem = (data: MenuItem[]): MenuItem | null => {\n  let foundItem: MenuItem | null = null;\n  data.some(obj => {\n    if (!obj.data || obj.data.length === 0) {\n      foundItem = obj;\n      return true;\n    }\n    foundItem = findFirstLeafItem(obj.data);\n    return foundItem !== null;\n  });\n  return foundItem;\n};\n\nconst getRootIdFromItemId = (menuItemId: string): string => {\n  return menuItemId.split(\"-\")[0];\n};\n\n/**\n * Get the bundleURL, joining values and removing any possible remove double(or more) slashes\n * @param base Base value\n * @param bundle Bundle value\n */\nconst getBundleUrl = (base: string, bundle: string): string => {\n  if (!bundle) {\n    return base;\n  }\n\n  return `${base}/${bundle}`.replace(/([^:]\\/)\\/+/g, \"$1\");\n};\n\n/**\n * Recursively removes the href property from items in the array if they have a non-empty data property.\n *\n * @param items - The array of items.\n * @returns The new array with the href property removed from items with children.\n */\nconst removeHrefFromMenuItemsWithChildren = (items: MenuItem[]): MenuItem[] => {\n  return items.map((item: MenuItem) => {\n    const { href, data, ...rest } = item;\n    if (data && data.length > 0) {\n      return { ...rest, data: removeHrefFromMenuItemsWithChildren(data) };\n    }\n    return item;\n  });\n};\n\nexport {\n  createMenuItems,\n  searchHrefInMenuItems,\n  compileHref,\n  findItemById,\n  findFirstLeafItem,\n  getRootIdFromItemId,\n  getBundleUrl,\n  removeHrefFromMenuItemsWithChildren\n};\n"],"names":["getMenuTargetHref","menuItem","target","submenus","createMenuItems","t","menuItems","maxDepth","parentMenuItem","undefined","reduce","accumulator","currentValue","index","navItem","id","label","href","icon","jsx","IconUiKit","name","parent","updatedDepth","data","length","push","flatMenuItems","items","acc","item","decomposeHrefStringToArray","normalizedHref","hrefArray","split","unshift","searchHrefMatch","normalizedFullHref","toBeSelectedId","toBeSelectedHref","reducedNormalizedHref","some","normalizedItemHref","normalizedItemHrefParams","idx","indexOf","slice","toLowerCase","endsWith","matchedHref","find","searchHrefInMenuItems","parameters","concat","compileHref","hrefOptions","compile","encode","encodeURIComponent","validate","findItemById","itemId","foundItem","obj","objId","childData","findFirstLeafItem","getRootIdFromItemId","menuItemId","getBundleUrl","base","bundle","replace","removeHrefFromMenuItemsWithChildren","map","rest"],"mappings":"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"}
import { jsx as $ } from "@emotion/react/jsx-runtime";
import { compile as C } from "path-to-regexp";
import v from "../../components/IconUiKit/index.js";
const m = (t) => {
  const {
    target: e
  } = t;
  return e || (t.submenus ? m(t.submenus[0]) : "");
}, z = (t, e, r, n) => r !== void 0 && r <= 0 ? [] : (e == null ? void 0 : e.reduce((o, s, l) => {
  var d;
  const i = {
    id: n ? `${n.id}-${l}` : `${l}`,
    label: t(s.label),
    href: m(s),
    icon: s.icon ? /* @__PURE__ */ $(v, { name: ((d = s.icon) == null ? void 0 : d.name) || "" }) : null,
    parent: n
  };
  if (s.submenus) {
    const f = r !== void 0 ? r - 1 : void 0, a = z(t, s.submenus, f, i);
    a.length > 0 && (i.data = a);
  }
  return o.push(i), o;
}, [])) || [], H = (t) => t.reduce((e, r) => (r.data ? e.push(...H(r.data)) : e.push(r), e), []), L = (t) => {
  const e = t.split("/").reduce((r, n) => {
    if (n === "")
      return r;
    const s = `${r.length === 0 ? "" : r[0]}/${n}`;
    return r.unshift(s), r;
  }, []);
  return e.push("/"), e;
}, w = (t, e, r) => {
  let n, o;
  const s = L(e);
  return H(t).some((l) => {
    var c, h, g, p;
    let i, d;
    const f = (c = l.href) == null ? void 0 : c.indexOf("?");
    if (f !== -1 ? (i = (h = l.href) == null ? void 0 : h.slice(0, f).toLowerCase(), d = (g = l.href) == null ? void 0 : g.slice(f, l.href.length).toLowerCase()) : (i = (p = l.href) == null ? void 0 : p.toLowerCase(), d = ""), i && i.length > 1 && i.endsWith("/") && (i = i.slice(0, i.length - 1)), `${i}${d}` === r)
      return n = l.id, !0;
    const u = s.find((I) => i === I);
    return u && (!o || u.length > (o == null ? void 0 : o.length)) && (n = l.id, o = u), !1;
  }), n;
}, A = (t, e, r) => {
  if (!e)
    return;
  const n = e.length > 1 && e.endsWith("/") ? e.slice(0, e.length - 1).toLowerCase() : e.toLowerCase(), o = r ? n.concat(r.toLowerCase()) : n;
  return w(t, n, o);
}, B = (t, e) => e ? C(t, {
  encode: encodeURIComponent,
  validate: !1
})(e) : t, F = (t, e) => {
  let r = null;
  return t.some((n) => {
    const {
      id: o,
      data: s
    } = n;
    return o === e ? (r = n, !0) : s && s.length > 0 ? (r = F(s, e), r !== null) : !1;
  }), r;
}, M = (t) => {
  let e = null;
  return t.some((r) => !r.data || r.data.length === 0 ? (e = r, !0) : (e = M(r.data), e !== null)), e;
}, R = (t) => t.split("-")[0], T = (t, e) => e ? `${t}/${e}`.replace(/([^:]\/)\/+/g, "$1") : t, y = (t) => t.map((e) => {
  const {
    href: r,
    data: n,
    ...o
  } = e;
  return n && n.length > 0 ? {
    ...o,
    data: y(n)
  } : e;
});
export {
  B as compileHref,
  z as createMenuItems,
  M as findFirstLeafItem,
  F as findItemById,
  T as getBundleUrl,
  R as getRootIdFromItemId,
  y as removeHrefFromMenuItemsWithChildren,
  A as searchHrefInMenuItems
};
//# sourceMappingURL=navigationUtil.js.map

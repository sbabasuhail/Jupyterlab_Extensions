{"version":3,"file":"useNavigation.js","sources":["../../../../src/lib/hooks/useNavigation.tsx"],"sourcesContent":["import { useCallback, useContext } from \"react\";\nimport { useNavigate } from \"react-router-dom\";\n\nimport { HvAppShellViewContext } from \"@hitachivantara/app-shell-shared\";\n\nimport { compileHref } from \"../utils/navigationUtil\";\nimport { NavigationOptions, To, ViewDestination } from \"../types\";\nimport useAppShellConfig from \"./useAppShellConfig\";\n\nconst isViewDestination = (to: To): to is ViewDestination => {\n  return (to as ViewDestination).viewBundle !== undefined;\n};\n\nconst useNavigation = () => {\n  const config = useAppShellConfig();\n  const viewContext = useContext(HvAppShellViewContext);\n  const navigateReactRouter = useNavigate();\n\n  /**\n   * Utility to search for the route of an application view bundle directory on the App Shell configuration file.\n   *\n   * @param viewBundleDir The application view bundle directory name and optional route parameters.\n   *\n   * @returns The compiled route or undefined if none was found.\n   */\n  const getViewRoute = useCallback(\n    (viewBundleDir: string | ViewDestination): string | undefined => {\n      let viewBundle;\n      let pathParams;\n      let search;\n      let hash;\n\n      if (isViewDestination(viewBundleDir)) {\n        ({ viewBundle, pathParams, search, hash } = viewBundleDir);\n      } else {\n        viewBundle = viewBundleDir;\n      }\n      const bundleWithReplacedPlaceholders = viewBundle.replace(/\\$/, \"_\");\n\n      let appId: string | undefined;\n      let bundle: string;\n\n      // local navigation\n      if (bundleWithReplacedPlaceholders.startsWith(\"/\")) {\n        appId = viewContext?.id;\n        bundle = bundleWithReplacedPlaceholders.substring(1);\n      } else {\n        const viewBundleTokens = bundleWithReplacedPlaceholders.split(\"/\");\n\n        // scoped bundle\n        if (viewBundleTokens[0].startsWith(\"@\")) {\n          appId = `${viewBundleTokens[0]}/${viewBundleTokens[1]}`;\n          viewBundleTokens.splice(0, 2);\n          bundle = viewBundleTokens.join(\"/\");\n        } else {\n          [appId] = viewBundleTokens;\n          viewBundleTokens.splice(0, 1);\n          bundle = viewBundleTokens.join(\"/\");\n        }\n      }\n\n      const app = config.apps?.find(a => a.id === appId);\n      if (app == null) {\n        return undefined;\n      }\n\n      const view = app.views?.find(\n        v =>\n          v.bundle === bundle ||\n          v.bundle === `${bundle}.js` ||\n          v.bundle === `src/${bundle}`\n      );\n\n      return view?.route\n        ? `${compileHref(view?.route, pathParams)}${search ?? \"\"}${hash ?? \"\"}`\n        : undefined;\n    },\n    [config, viewContext?.id]\n  );\n  /**\n   * Utility function that performs the cross navigation between AppShell routes\n   *\n   * @param path The path of the URL.\n   * @param options The options to be used on the history object, See {@link NavigationOptions}.\n   * */\n  const performHistoryNavigation = useCallback(\n    (path: string | undefined, options?: Partial<NavigationOptions>) => {\n      if (!path) {\n        console.warn(`Navigate request to an empty path. Skipping`);\n        return;\n      }\n      if (!options) {\n        navigateReactRouter(path);\n        return;\n      }\n\n      if (options?.replace) {\n        navigateReactRouter(path, { replace: true, state: options.state });\n      } else {\n        navigateReactRouter(path, { state: options?.state });\n      }\n    },\n    [navigateReactRouter]\n  );\n\n  /**\n   * Performs navigation using the history push|replace methods (based on the 'options' parameter) for the given path.\n   *\n   * @param to The string to be compiled.\n   * @param options The options to be used on the history object, See {@link NavigationOptions}.\n   */\n  const navigate = useCallback(\n    (to: To, options?: Partial<NavigationOptions>) => {\n      let path;\n      if (typeof to === \"string\") {\n        if (!to) {\n          console.warn(`Navigate request to an empty path. Skipping`);\n          return;\n        }\n\n        path = to;\n      } else if (isViewDestination(to)) {\n        const route = getViewRoute(to.viewBundle);\n        // If route for given module is not found on the App Shell configuration file, do nothing.\n        if (!route) {\n          console.warn(\n            `Navigate request to a non existing path [${to.viewBundle}]. Skipping`\n          );\n          return;\n        }\n        path = `${compileHref(route, to.pathParams)}${to.search ?? \"\"}${\n          to.hash ?? \"\"\n        }`;\n      } else {\n        path = `${to.pathname}${to.search ?? \"\"}${to.hash ?? \"\"}`;\n      }\n\n      performHistoryNavigation(path, options);\n    },\n    [getViewRoute, performHistoryNavigation]\n  );\n\n  return { getViewRoute, navigate };\n};\nexport default useNavigation;\n"],"names":["isViewDestination","to","viewBundle","undefined","useNavigation","config","useAppShellConfig","viewContext","useContext","HvAppShellViewContext","navigateReactRouter","useNavigate","getViewRoute","useCallback","viewBundleDir","pathParams","search","hash","bundleWithReplacedPlaceholders","replace","appId","bundle","startsWith","id","substring","viewBundleTokens","split","splice","join","app","apps","find","a","view","views","v","route","compileHref","performHistoryNavigation","path","options","console","warn","state","navigate","pathname","useNavigation$1"],"mappings":"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"}
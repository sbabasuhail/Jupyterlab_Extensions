{"version":3,"file":"useMenuItems.js","sources":["../../../../src/lib/hooks/useMenuItems.tsx"],"sourcesContent":["import { useContext, useEffect, useMemo, useState } from \"react\";\nimport { useLocation } from \"react-router-dom\";\n\nimport { HvAppShellRuntimeContext } from \"@hitachivantara/app-shell-shared\";\nimport { MenuItemsContext } from \"../types\";\nimport {\n  createMenuItems,\n  findItemById,\n  findFirstLeafItem,\n  getRootIdFromItemId,\n  searchHrefInMenuItems\n} from \"../utils/navigationUtil\";\n\nimport useAppShellConfig from \"./useAppShellConfig\";\nimport useNavigation from \"./useNavigation\";\nimport { CONFIG_TRANSLATIONS_NAMESPACE } from \"../i18n\";\n\nconst MAX_TOP_MENU_DEPTH = 2;\n\nconst useMenuItems = (): MenuItemsContext => {\n  const { pathname, search, state: locationState } = useLocation();\n  const appShellContext = useAppShellConfig();\n  const { navigate } = useNavigation();\n\n  // use the i18n instance from the app shell runtime context to ensure we're using\n  // the app shell instance of i18n and not the one from the embedded app\n  const { i18n } = useContext(HvAppShellRuntimeContext) ?? {};\n  const tConfig = useMemo(\n    () =>\n      i18n?.getFixedT(i18n.language, CONFIG_TRANSLATIONS_NAMESPACE) ??\n      // should not happen, but fallback if the i18n instance is not available\n      ((l: string) => l),\n    [i18n]\n  );\n\n  const items = useMemo(() => {\n    const menuItemsDepth =\n      appShellContext.navigationMode === \"ONLY_TOP\"\n        ? MAX_TOP_MENU_DEPTH\n        : undefined;\n\n    return createMenuItems(tConfig, appShellContext.menu, menuItemsDepth);\n  }, [appShellContext, tConfig]);\n\n  const [selectedMenuItemId, setSelectedMenuItemId] = useState<\n    string | undefined\n  >(undefined);\n\n  const [rootMenuItemId, setRootMenuItemId] = useState<string | undefined>(\n    undefined\n  );\n\n  useEffect(() => {\n    // no menu items, nothing to select\n    if (!items.length) {\n      return;\n    }\n\n    // state property is used when we already know which menu is to be selected\n    if (locationState && locationState.selectedItemId) {\n      setRootMenuItemId(getRootIdFromItemId(locationState.selectedItemId));\n      // If the selected item has children we want to select the first child instead\n      const selectedItem = findItemById(items, locationState.selectedItemId);\n      if (selectedItem?.data && selectedItem.data.length > 0) {\n        const firstItemToSelect = findFirstLeafItem(selectedItem.data);\n        setSelectedMenuItemId(firstItemToSelect?.id);\n      } else {\n        setSelectedMenuItemId(selectedItem?.id);\n      }\n      return;\n    }\n\n    const toBeSelected = searchHrefInMenuItems(items, pathname, search);\n    if (toBeSelected) {\n      setRootMenuItemId(getRootIdFromItemId(toBeSelected));\n      setSelectedMenuItemId(toBeSelected);\n      return;\n    }\n\n    // First render (or a refresh) without written user url, then navigate to the first menu item\n    if (pathname === \"/\" && items[0].href) {\n      navigate(items[0].href, {\n        state: { selectedItemId: items[0].id }\n      });\n      return;\n    }\n\n    // if none of the previous scenarios, then nothing is marked as selected\n    setRootMenuItemId(undefined);\n    setSelectedMenuItemId(undefined);\n  }, [pathname, search, locationState, items, navigate]);\n\n  return {\n    items,\n    selectedMenuItemId,\n    rootMenuItemId\n  };\n};\n\nexport default useMenuItems;\n"],"names":["MAX_TOP_MENU_DEPTH","useMenuItems","pathname","search","state","locationState","useLocation","appShellContext","useAppShellConfig","navigate","useNavigation","i18n","useContext","HvAppShellRuntimeContext","tConfig","useMemo","getFixedT","language","CONFIG_TRANSLATIONS_NAMESPACE","l","items","menuItemsDepth","navigationMode","undefined","createMenuItems","menu","selectedMenuItemId","setSelectedMenuItemId","useState","rootMenuItemId","setRootMenuItemId","useEffect","length","selectedItemId","getRootIdFromItemId","selectedItem","findItemById","data","firstItemToSelect","findFirstLeafItem","id","toBeSelected","searchHrefInMenuItems","href","useMenuItems$1"],"mappings":";;;;;;;AAiBA,MAAMA,IAAqB,GAErBC,IAAeA,MAAwB;AACrC,QAAA;AAAA,IAAEC,UAAAA;AAAAA,IAAUC,QAAAA;AAAAA,IAAQC,OAAOC;AAAAA,MAAkBC,EAAY,GACzDC,IAAkBC,KAClB;AAAA,IAAEC,UAAAA;AAAAA,MAAaC,EAAc,GAI7B;AAAA,IAAEC,MAAAA;AAAAA,EAAAA,IAASC,EAAWC,CAAwB,KAAK,IACnDC,IAAUC,EACd,OACEJ,KAAAA,gBAAAA,EAAMK,UAAUL,EAAKM,UAAUC;AAAAA,GAE9B,CAACC,MAAcA,IAClB,CAACR,CAAI,CACP,GAEMS,IAAQL,EAAQ,MAAM;AAC1B,UAAMM,IACJd,EAAgBe,mBAAmB,aAC/BtB,IACAuB;AAEN,WAAOC,EAAgBV,GAASP,EAAgBkB,MAAMJ,CAAc;AAAA,EAAA,GACnE,CAACd,GAAiBO,CAAO,CAAC,GAEvB,CAACY,GAAoBC,CAAqB,IAAIC,EAElDL,MAAS,GAEL,CAACM,GAAgBC,CAAiB,IAAIF,EAC1CL,MACF;AAEAQ,SAAAA,EAAU,MAAM;AAEV,QAAA,CAACX,EAAMY;AACT;AAIE3B,QAAAA,KAAiBA,EAAc4B,gBAAgB;AAC/BC,MAAAA,EAAAA,EAAoB7B,EAAc4B,cAAc,CAAC;AAEnE,YAAME,IAAeC,EAAahB,GAAOf,EAAc4B,cAAc;AACrE,UAAIE,KAAAA,QAAAA,EAAcE,QAAQF,EAAaE,KAAKL,SAAS,GAAG;AAChDM,cAAAA,IAAoBC,EAAkBJ,EAAaE,IAAI;AAC7DV,QAAAA,EAAsBW,KAAAA,gBAAAA,EAAmBE,EAAE;AAAA,MAAA;AAE3Cb,QAAAA,EAAsBQ,KAAAA,gBAAAA,EAAcK,EAAE;AAExC;AAAA,IACF;AAEA,UAAMC,IAAeC,EAAsBtB,GAAOlB,GAAUC,CAAM;AAClE,QAAIsC,GAAc;AACEP,MAAAA,EAAAA,EAAoBO,CAAY,CAAC,GACnDd,EAAsBc,CAAY;AAClC;AAAA,IACF;AAGA,QAAIvC,MAAa,OAAOkB,EAAM,CAAC,EAAEuB,MAAM;AAC5BvB,MAAAA,EAAAA,EAAM,CAAC,EAAEuB,MAAM;AAAA,QACtBvC,OAAO;AAAA,UAAE6B,gBAAgBb,EAAM,CAAC,EAAEoB;AAAAA,QAAG;AAAA,MAAA,CACtC;AACD;AAAA,IACF;AAGAV,IAAAA,EAAkBP,MAAS,GAC3BI,EAAsBJ,MAAS;AAAA,EAAA,GAC9B,CAACrB,GAAUC,GAAQE,GAAee,GAAOX,CAAQ,CAAC,GAE9C;AAAA,IACLW,OAAAA;AAAAA,IACAM,oBAAAA;AAAAA,IACAG,gBAAAA;AAAAA,EAAAA;AAEJ,GAEAe,IAAe3C;"}
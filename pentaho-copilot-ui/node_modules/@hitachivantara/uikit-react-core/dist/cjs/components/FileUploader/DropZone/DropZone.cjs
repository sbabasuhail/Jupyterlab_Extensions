"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const uniqueId = require("lodash/uniqueId");
const accept = require("attr-accept");
const setId = require("../../../utils/setId.cjs");
const useUniqueId = require("../../../hooks/useUniqueId.cjs");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const utils = require("../utils.cjs");
const DropZone_styles = require("./DropZone.styles.cjs");
const Label = require("../../Forms/Label/Label.cjs");
const InfoMessage = require("../../Forms/InfoMessage/InfoMessage.cjs");
const Typography = require("../../Typography/Typography.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const uniqueId__default = /* @__PURE__ */ _interopDefault(uniqueId);
const accept__default = /* @__PURE__ */ _interopDefault(accept);
const HvDropZone = ({
  id: idProp,
  classes: classesProp,
  labels,
  acceptedFiles,
  maxFileSize,
  inputProps,
  hideLabels,
  multiple = true,
  disabled = false,
  onFilesAdded
}) => {
  const id = useUniqueId.useUniqueId(idProp, "dropzone");
  const {
    classes,
    cx
  } = DropZone_styles.useClasses(classesProp);
  const [dragState, setDrag] = React.useState(false);
  const inputRef = React.useRef(null);
  const leaveDropArea = () => {
    setDrag(false);
  };
  const enterDropArea = () => {
    setDrag(true);
  };
  const onChangeHandler = (filesList) => {
    const filesToProcess = Object.keys(filesList).map((e) => filesList[e]);
    const newFiles = [];
    filesToProcess.forEach((file) => {
      const newFile = file;
      const isSizeAllowed = file.size <= maxFileSize;
      const isFileAccepted = !acceptedFiles.length || acceptedFiles.indexOf(file.type.split("/")[1]) > -1 || acceptedFiles.some((acceptExtension) => accept__default.default({
        name: file.name,
        type: file.type
      }, acceptExtension));
      if (!isFileAccepted) {
        newFile.errorMessage = labels == null ? void 0 : labels.fileTypeError;
        newFile.status = "fail";
      } else if (!isSizeAllowed) {
        newFile.errorMessage = labels == null ? void 0 : labels.fileSizeError;
        newFile.status = "fail";
      }
      newFile.id = uniqueId__default.default("uploaded-file-data-");
      newFiles.push(newFile);
    });
    onFilesAdded == null ? void 0 : onFilesAdded(newFiles);
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    !hideLabels && /* @__PURE__ */ jsxRuntime.jsxs("div", { id, className: classes.dropZoneLabelsGroup, children: [
      /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { id: setId.setId(id, "input-file-label"), htmlFor: setId.setId(id, "input-file"), label: labels == null ? void 0 : labels.dropzone, className: classes.dropZoneLabel }),
      /* @__PURE__ */ jsxRuntime.jsxs(InfoMessage.HvInfoMessage, { id: setId.setId(id, "description"), children: [
        Number.isInteger(maxFileSize) && `${labels == null ? void 0 : labels.sizeWarning} ${utils.convertUnits(maxFileSize)}`,
        (labels == null ? void 0 : labels.acceptedFiles) && labels.acceptedFiles,
        !(labels == null ? void 0 : labels.acceptedFiles) && acceptedFiles.length > 0 && ` (${acceptedFiles.join(", ")})`
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs("div", { id: setId.setId(id, "input-file-container"), className: cx(classes.dropZoneContainer, {
      [classes.dragAction]: dragState,
      [classes.dropZoneContainerDisabled]: disabled
    }), children: [
      /* @__PURE__ */ jsxRuntime.jsx("input", { id: setId.setId(id, "input-file"), className: classes.inputArea, type: "file", multiple, disabled, title: !disabled ? `${labels == null ? void 0 : labels.drag} ${labels == null ? void 0 : labels.selectFiles}` : "", onClick: () => {
        if (inputRef.current) {
          inputRef.current.value = "";
        }
      }, onChange: () => {
        var _a;
        if (!disabled && ((_a = inputRef.current) == null ? void 0 : _a.files)) {
          onChangeHandler(inputRef.current.files);
        }
      }, onDragEnter: (event) => {
        if (!disabled) {
          enterDropArea();
          event.stopPropagation();
          event.preventDefault();
        }
      }, onDragLeave: leaveDropArea, onDropCapture: leaveDropArea, onDragOver: (event) => {
        if (!disabled) {
          enterDropArea();
          event.stopPropagation();
          event.preventDefault();
        }
      }, onDrop: (event) => {
        if (!disabled) {
          const {
            files
          } = event.dataTransfer;
          if (multiple === true || files.length === 1) {
            event.stopPropagation();
            event.preventDefault();
            onChangeHandler(files);
          }
        }
      }, ref: inputRef, accept: acceptedFiles.join(","), ...inputProps }),
      /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes == null ? void 0 : classes.dropArea, children: dragState ? /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.dropZoneAreaLabels, children: /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { className: classes.dragText, children: labels == null ? void 0 : labels.dropFiles }) }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.Doc, { iconSize: "M", className: classes.dropZoneAreaIcon, color: disabled ? "secondary_60" : "secondary" }),
        /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.dropZoneAreaLabels, children: /* @__PURE__ */ jsxRuntime.jsxs(Typography.HvTypography, { className: classes.dragText, children: [
          labels == null ? void 0 : labels.drag,
          /* @__PURE__ */ jsxRuntime.jsx("span", { className: classes.selectFilesText, children: ` ${labels == null ? void 0 : labels.selectFiles}` })
        ] }) })
      ] }) })
    ] })
  ] });
};
exports.dropZoneClasses = DropZone_styles.staticClasses;
exports.HvDropZone = HvDropZone;
//# sourceMappingURL=DropZone.cjs.map

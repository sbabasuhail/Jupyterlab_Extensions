"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const multiSelectionEventHandler = require("../../utils/multiSelectionEventHandler.cjs");
const keyboardUtils = require("../../utils/keyboardUtils.cjs");
const setId = require("../../utils/setId.cjs");
const SelectionList_styles = require("./SelectionList.styles.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const ListContainer = require("../ListContainer/ListContainer.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const React__default = /* @__PURE__ */ _interopDefault(React);
const getValueFromSelectedChildren = (children, multiple) => {
  const selectedValues = React__default.default.Children.toArray(children).map((child) => {
    var _a, _b, _c;
    const childIsControlled = ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.selected) !== void 0;
    const childIsSelected = child && childIsControlled ? (_b = child.props) == null ? void 0 : _b.selected : (_c = child.props) == null ? void 0 : _c.defaultSelected;
    return childIsSelected ? child == null ? void 0 : child.props.value : void 0;
  }).filter((v) => v !== void 0);
  return multiple ? selectedValues : selectedValues == null ? void 0 : selectedValues[0];
};
const HvSelectionList = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    children,
    name,
    value: valueProp,
    defaultValue,
    required = false,
    readOnly = false,
    disabled = false,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    orientation = "vertical",
    multiple = false,
    singleSelectionToggle = false,
    ...others
  } = useDefaultProps.useDefaultProps("HvSelectionList", props);
  const {
    classes,
    cx
  } = SelectionList_styles.useClasses(classesProp);
  const elementId = useUniqueId.useUniqueId(id, "hvselectionlist");
  const [value, setValue] = useControlled.useControlled(valueProp, defaultValue !== void 0 ? defaultValue : (
    // when uncontrolled and no default value is given,
    // extract the initial selected values from the children own state
    () => getValueFromSelectedChildren(children, multiple)
  ));
  const [validationState, setValidationState] = useControlled.useControlled(status, "standBy");
  const [validationMessage] = useControlled.useControlled(statusMessage, "Required");
  const [allValues, selectedState] = React.useMemo(() => {
    const childValues = [];
    const childSelectedState = [];
    React__default.default.Children.toArray(children).forEach((child, i) => {
      var _a;
      const childValue = (_a = child == null ? void 0 : child.props) == null ? void 0 : _a.value;
      const childIsSelected = multiple ? value.indexOf(childValue) !== -1 : value === childValue;
      childValues[i] = childValue;
      childSelectedState[i] = childIsSelected;
    });
    return [childValues, childSelectedState];
  }, [children, multiple, value]);
  const selectionAnchor = React.useRef(void 0);
  const listContainer = React.useRef(null);
  React.useEffect(() => {
    const handleMeta = (event) => {
      const tempArray = [];
      if (keyboardUtils.isKey(event, "ArrowUp") && event.shiftKey && listContainer.current.contains(event.target) || keyboardUtils.isKey(event, "ArrowDown") && event.shiftKey && listContainer.current.contains(event.target)) {
        selectedState.forEach((isSelected, i) => {
          if (i === event.target.value - 1) {
            if (!isSelected) {
              tempArray.push(allValues[i]);
            }
          } else if (isSelected) {
            tempArray.push(allValues[i]);
          }
        });
        setValue(tempArray);
      }
    };
    window.addEventListener("keyup", handleMeta);
    return () => {
      window.removeEventListener("keyup", handleMeta);
    };
  }, [allValues, selectedState, setValue]);
  const onChildChangeInterceptor = React.useCallback((index, childOnClick, evt) => {
    childOnClick == null ? void 0 : childOnClick(evt);
    if (!readOnly && !disabled) {
      let newValue;
      if (multiple) {
        newValue = multiSelectionEventHandler.multiSelectionEventHandler(evt, index, selectionAnchor, allValues, selectedState, void 0);
      } else {
        newValue = singleSelectionToggle && selectedState[index] ? null : allValues[index];
      }
      onChange == null ? void 0 : onChange(evt, newValue);
      setValue(() => {
        if (required && newValue.length === 0) {
          setValidationState("invalid");
        } else {
          setValidationState("valid");
        }
        return newValue;
      });
    }
  }, [allValues, disabled, multiple, onChange, readOnly, required, selectedState, setValidationState, setValue, singleSelectionToggle, selectionAnchor]);
  const modifiedChildren = React.useMemo(() => {
    return React__default.default.Children.map(children, (child, i) => {
      var _a;
      const childIsSelected = selectedState[i];
      return React__default.default.cloneElement(child, {
        role: "option",
        selected: childIsSelected,
        onClick: (evt) => {
          var _a2;
          return onChildChangeInterceptor(i, (_a2 = child == null ? void 0 : child.props) == null ? void 0 : _a2.onClick, evt);
        },
        disabled: disabled || ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.disabled)
      });
    });
  }, [children, disabled, onChildChangeInterceptor, selectedState]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const errorMessageId = canShowError ? setId.setId(elementId, "error") : ariaErrorMessage;
  const listId = label && setId.setId(elementId, "listbox") || "";
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { id, name, status: validationState, disabled, required, readOnly, className: cx(classes.root, className), children: [
    label && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { id: setId.setId(elementId, "label"), label, className: classes.label }),
    description && /* @__PURE__ */ jsxRuntime.jsx(InfoMessage.HvInfoMessage, { id: setId.setId(elementId, "description"), className: classes.description, children: description }),
    /* @__PURE__ */ jsxRuntime.jsx(ListContainer.HvListContainer, { id: listId, interactive: true, condensed: true, role: "listbox", "aria-multiselectable": multiple || void 0, "aria-label": ariaLabel, "aria-labelledby": [label && setId.setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0, "aria-invalid": validationState === "invalid" ? true : void 0, "aria-errormessage": validationState === "invalid" ? errorMessageId : void 0, "aria-describedby": [description && setId.setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, className: cx(classes.listbox, {
      [classes.vertical]: orientation === "vertical",
      [classes.horizontal]: orientation === "horizontal",
      [classes.invalid]: validationState === "invalid"
    }), ref: listContainer, ...others, children: modifiedChildren }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
exports.selectionListClasses = SelectionList_styles.staticClasses;
exports.HvSelectionList = HvSelectionList;
//# sourceMappingURL=SelectionList.cjs.map

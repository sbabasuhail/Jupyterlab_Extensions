"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const material = require("@mui/material");
const React = require("react");
const withTooltip = require("../../../hocs/withTooltip.cjs");
const Context = require("../Context.cjs");
const Rule_styles = require("./Rule.styles.cjs");
const Grid = require("../../Grid/Grid.cjs");
const Attribute = require("./Attribute/Attribute.cjs");
const Operator = require("./Operator/Operator.cjs");
const Value = require("./Value/Value.cjs");
const Button = require("../../Button/Button.cjs");
const Rule = ({
  id,
  combinator,
  attribute,
  operator,
  value,
  disabled,
  isInvalid
}) => {
  const {
    classes,
    cx
  } = Rule_styles.useClasses();
  const context = React.useContext(Context.QueryBuilderContext);
  const theme = material.useTheme();
  const isMdDown = material.useMediaQuery(theme.breakpoints.down("md"));
  const {
    askAction,
    attributes,
    operators,
    labels,
    readOnly
  } = context;
  const availableOperators = React.useMemo(() => {
    const attributeSpec = attribute != null && attributes ? attributes[attribute] : null;
    if (attributeSpec != null) {
      const typeOperators = operators[attributeSpec.type];
      if (typeOperators != null) {
        return typeOperators.reduce((count, item) => count + (item.combinators.includes(combinator) ? 1 : 0), 0);
      }
    }
    return -1;
  }, [attribute, attributes, combinator, operators]);
  const shouldShowValueInput = operator !== "Empty" && operator !== "IsNotEmpty";
  const DeleteIcon = withTooltip.withTooltip(() => /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.Delete, {}), labels.rule.delete.tooltip, "bottom");
  return /* @__PURE__ */ jsxRuntime.jsxs(Grid.HvGrid, { container: true, className: cx(classes.root, {
    [classes.isMdDown]: isMdDown
  }), spacing: 0, wrap: "nowrap", children: [
    /* @__PURE__ */ jsxRuntime.jsx(Grid.HvGrid, { item: true, xs: 2, lg: 3, children: /* @__PURE__ */ jsxRuntime.jsx(Attribute.Attribute, { attribute, id, disabled, isInvalid }) }),
    attribute != null && availableOperators > 0 && /* @__PURE__ */ jsxRuntime.jsx(Grid.HvGrid, { item: true, xs: 2, lg: 3, children: /* @__PURE__ */ jsxRuntime.jsx(Operator.Operator, { id, combinator, attribute, operator }) }),
    attribute != null && (operator != null || availableOperators === 0) && /* @__PURE__ */ jsxRuntime.jsx(Grid.HvGrid, { item: true, xs: true, children: shouldShowValueInput && /* @__PURE__ */ jsxRuntime.jsx(Value.Value, { attribute, id, operator, value }) }),
    /* @__PURE__ */ jsxRuntime.jsx(Grid.HvGrid, { item: true, className: classes.actionsContainer, children: /* @__PURE__ */ jsxRuntime.jsx(Button.HvButton, { icon: true, "aria-label": labels.rule.delete.ariaLabel, onClick: () => {
      askAction({
        actions: [{
          type: "remove-node",
          id
        }],
        dialog: labels.rule.delete
      });
    }, disabled: readOnly, children: /* @__PURE__ */ jsxRuntime.jsx(DeleteIcon, {}) }) })
  ] });
};
exports.Rule = Rule;
//# sourceMappingURL=Rule.cjs.map

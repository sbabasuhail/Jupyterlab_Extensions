"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const Context = require("../../Context.cjs");
const index = require("../../utils/index.cjs");
const Dropdown = require("../../../Dropdown/Dropdown.cjs");
const Operator = ({
  id,
  combinator,
  attribute,
  operator
}) => {
  const context = React.useContext(Context.QueryBuilderContext);
  const {
    dispatchAction,
    attributes,
    operators,
    labels,
    readOnly
  } = context;
  const value = operator ?? null;
  const values = React.useMemo(() => {
    const attributeSpec = attribute && attributes ? attributes[attribute] : null;
    const options = attributeSpec ? operators[attributeSpec.type].filter((o) => o.combinators.includes(combinator)) ?? [] : [];
    return options.map((key) => ({
      id: key.operator,
      label: key.label,
      selected: key.operator === value
    }));
  }, [attribute, attributes, operators, combinator, value]);
  return /* @__PURE__ */ jsxRuntime.jsx(Dropdown.HvDropdown, { required: true, status: "valid", singleSelectionToggle: false, label: labels.rule.operator.label, placeholder: labels.rule.operator.placeholder, values, disabled: values.length === 0, readOnly, onChange: (selected) => {
    if (selected && !Array.isArray(selected) && selected.id) {
      dispatchAction({
        type: "set-operator",
        id,
        operator: selected.id.toString(),
        value: value === "range" || selected.id === "range" ? null : void 0
      });
    } else {
      dispatchAction({
        type: "set-operator",
        id,
        operator: null,
        value: null
      });
    }
  }, showSearch: index.isBigList(values), ...index.isBigList(values) && {
    virtualized: true,
    height: 300
  } });
};
React.memo(Operator);
exports.Operator = Operator;
//# sourceMappingURL=Operator.cjs.map

"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
const utils = require("./utils.cjs");
const useScrollTo = (selectedIndexProp = 0, scrollElementId = void 0, href = false, offset = 0, options = [], onChange = void 0, direction = "column") => {
  const RETRY_MAX = 5;
  const [selectedIndex, setSelectedIndex] = React.useState(selectedIndexProp);
  const scrollEle = React.useRef(window);
  const requestedAnimationFrame = React.useRef(0);
  const lastContainerScrollTop = React.useRef(0);
  const selectedIndexRef = React.useRef(selectedIndex);
  React.useEffect(() => {
    selectedIndexRef.current = selectedIndex;
  }, [selectedIndex]);
  React.useEffect(() => {
    scrollEle.current = scrollElementId && document.getElementById(scrollElementId) || window;
    lastContainerScrollTop.current = utils.verticalScrollOffset(scrollEle.current);
  }, [scrollElementId]);
  const checkScroll = React.useCallback((event) => {
    if (requestedAnimationFrame.current === 0 && (window == null ? void 0 : window.requestAnimationFrame)) {
      requestedAnimationFrame.current = window.requestAnimationFrame(() => {
        requestedAnimationFrame.current = 0;
        const firstVisibleElementIndex = utils.findFirstVisibleElement(scrollEle.current, options, offset);
        let newSelectedIndex = firstVisibleElementIndex;
        if (firstVisibleElementIndex < 0) {
          newSelectedIndex = 0;
        }
        if (newSelectedIndex < options.length - 1 && utils.isScrolledToTheBottom(scrollEle.current)) {
          newSelectedIndex += 1;
        }
        const containerScrollTop = utils.getScrollTop(scrollEle.current);
        const isScrollingDown = containerScrollTop > lastContainerScrollTop.current;
        lastContainerScrollTop.current = containerScrollTop;
        if (isScrollingDown) {
          if (newSelectedIndex < selectedIndexRef.current) {
            newSelectedIndex = selectedIndexRef.current;
          }
        } else if (newSelectedIndex > selectedIndexRef.current) {
          newSelectedIndex = selectedIndexRef.current;
        }
        setSelectedIndex(newSelectedIndex);
        onChange == null ? void 0 : onChange(event, newSelectedIndex);
      });
    }
  }, [offset, options, onChange]);
  React.useEffect(() => {
    if (scrollEle.current) {
      scrollEle.current.addEventListener("scroll", checkScroll, false);
    }
    return () => {
      if (scrollEle.current) {
        scrollEle.current.removeEventListener("scroll", checkScroll);
      }
      if (requestedAnimationFrame.current !== 0) {
        window.cancelAnimationFrame(requestedAnimationFrame.current);
        requestedAnimationFrame.current = 0;
      }
    };
  }, [checkScroll]);
  React.useEffect(() => {
    let checkRenderedInterval;
    if (href) {
      const hashValue = document.location.hash.split("#")[1] || "";
      const option = options.find((o) => o.value === hashValue);
      if (option) {
        let retry = 0;
        checkRenderedInterval = setInterval(() => {
          const ele = document.getElementById(option.value);
          if (ele) {
            utils.scrollElement(ele, scrollEle.current, option.offset || offset);
            clearInterval(checkRenderedInterval);
          } else {
            retry += 1;
            if (retry === RETRY_MAX) {
              clearInterval(checkRenderedInterval);
            }
          }
        }, 1e3);
      }
    }
    return () => {
      clearInterval(checkRenderedInterval);
    };
  }, []);
  const setScrollTo = (event, id, index, wrappedOnChange) => {
    const option = options.find((o) => o.value === id);
    if (option) {
      const ele = document.getElementById(id);
      if (ele) {
        utils.scrollElement(ele, scrollEle.current, option.offset || offset, direction);
      }
      if (href) {
        window.history.pushState({}, "", `#${options[index].value}`);
      }
      setSelectedIndex(index);
      wrappedOnChange == null ? void 0 : wrappedOnChange(index);
      selectedIndexRef.current = index;
    }
  };
  return [selectedIndex, setScrollTo];
};
exports.useScrollTo = useScrollTo;
//# sourceMappingURL=useScrollTo.cjs.map

"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const isNil = require("lodash/isNil");
const uikitStyles = require("@hitachivantara/uikit-styles");
const useControlled = require("../../hooks/useControlled.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useIsMounted = require("../../hooks/useIsMounted.cjs");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const keyboardUtils = require("../../utils/keyboardUtils.cjs");
const setId = require("../../utils/setId.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const validations = require("../BaseInput/validations.cjs");
const TagsInput_styles = require("./TagsInput.styles.cjs");
const Tag = require("../Tag/Tag.cjs");
const Input = require("../Input/Input.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const CharCounter = require("../Forms/CharCounter/CharCounter.cjs");
const ListContainer = require("../ListContainer/ListContainer.cjs");
const ListItem = require("../ListContainer/ListItem/ListItem.cjs");
const BaseInput_styles = require("../BaseInput/BaseInput.styles.cjs");
const Suggestions = require("../Forms/Suggestions/Suggestions.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const isNil__default = /* @__PURE__ */ _interopDefault(isNil);
const HvTagsInput = (props) => {
  var _a;
  const {
    classes: classesProp,
    className,
    id,
    name,
    value: valueProp,
    defaultValue = [],
    readOnly = false,
    disabled = false,
    required = false,
    label: textAreaLabel,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    onAdd,
    onDelete,
    onBlur,
    onFocus,
    placeholder,
    hideCounter = false,
    middleCountLabel = "/",
    maxTagsQuantity,
    autoFocus = false,
    resizable = true,
    inputProps = {},
    countCharProps = {},
    multiline = false,
    status,
    statusMessage,
    validationMessages,
    commitTagOn = ["Enter"],
    commitOnBlur = false,
    suggestionListCallback,
    ...others
  } = useDefaultProps.useDefaultProps("HvTagsInput", props);
  const {
    classes,
    cx,
    css
  } = TagsInput_styles.useClasses(classesProp);
  const elementId = useUniqueId.useUniqueId(id, "hvTagsInput");
  const hasLabel = textAreaLabel != null;
  const hasDescription = description != null;
  const [value, setValue] = useControlled.useControlled(valueProp, defaultValue);
  const [validationState, setValidationState] = useControlled.useControlled(status, validationStates.default.standBy);
  const [validationMessage, setValidationMessage] = useControlled.useControlled(statusMessage, "");
  const [tagInput, setTagInput] = React.useState("");
  const [tagCursorPos, setTagCursorPos] = React.useState(value.length);
  const [stateValid, setStateValid] = React.useState(true);
  const inputRef = React.useRef();
  const containerRef = React.useRef();
  const skipReset = React.useRef(false);
  const blurTimeout = React.useRef();
  const materialInputRef = React.useRef(null);
  const isTagSelected = tagCursorPos >= 0 && tagCursorPos < value.length;
  const hasCounter = maxTagsQuantity != null && !hideCounter;
  const [suggestionValues, setSuggestionValues] = React.useState(null);
  const isStateInvalid = React.useMemo(() => {
    return hasCounter && value.length > maxTagsQuantity;
  }, [hasCounter, maxTagsQuantity, value.length]);
  const canShowSuggestions = suggestionListCallback != null;
  const hasSuggestions = !!suggestionValues;
  const errorMessages = React.useMemo(() => ({
    ...validations.DEFAULT_ERROR_MESSAGES,
    ...validationMessages
  }), [validationMessages]);
  const performValidation = React.useCallback((currValue) => {
    if (maxTagsQuantity !== null && maxTagsQuantity !== void 0 && currValue.length > maxTagsQuantity) {
      setValidationState(validationStates.default.invalid);
      setValidationMessage(errorMessages.maxCharError);
      setStateValid(false);
    } else {
      setValidationState(validationStates.default.valid);
      setValidationMessage("");
      setStateValid(true);
    }
  }, [errorMessages.maxCharError, maxTagsQuantity, setValidationMessage, setValidationState]);
  const deleteTag = React.useCallback((tagPos, event, end) => {
    var _a2;
    const newTagsArr = [...value.slice(0, tagPos), ...value.slice(tagPos + 1)];
    setValue(newTagsArr);
    setTagCursorPos(end ? newTagsArr.length : tagCursorPos > 0 ? tagCursorPos - 1 : 0);
    (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
    performValidation(newTagsArr);
    onDelete == null ? void 0 : onDelete(event, value[tagPos], tagPos);
    onChange == null ? void 0 : onChange(event, newTagsArr);
    skipReset.current = true;
  }, [onChange, onDelete, performValidation, setValue, tagCursorPos, value]);
  const addTag = React.useCallback((event, tag) => {
    event.preventDefault();
    if (tag !== "") {
      const newTag = {
        label: tag,
        type: "semantic"
      };
      const newTagsArr = [...value, newTag];
      setValue(newTagsArr);
      performValidation(newTagsArr);
      onAdd == null ? void 0 : onAdd(event, newTag, newTagsArr.length - 1);
      onChange == null ? void 0 : onChange(event, newTagsArr);
    }
  }, [onAdd, onChange, performValidation, setValue, value]);
  const canShowError = status !== void 0 && status === "invalid" && statusMessage !== void 0 || !stateValid;
  React.useEffect(() => {
    var _a2;
    if (!multiline) {
      const element = (_a2 = containerRef == null ? void 0 : containerRef.current) == null ? void 0 : _a2.children[tagCursorPos];
      setTimeout(() => {
        const container = containerRef.current;
        if (isNil__default.default(container))
          return;
        container.scrollLeft = element ? element.offsetLeft - container.getBoundingClientRect().width / 2 + element.getBoundingClientRect().width / 2 : 0;
      }, 50);
      element == null ? void 0 : element.focus();
    }
  }, [multiline, tagCursorPos]);
  React.useEffect(() => {
    if (!skipReset.current) {
      setTagInput("");
      setTagCursorPos(value.length);
    }
    skipReset.current = false;
  }, [value]);
  const isMounted = useIsMounted.useIsMounted();
  const focusInput = () => {
    materialInputRef.current.focus();
  };
  const getSuggestions = React.useCallback((li) => {
    var _a2;
    const listEl = document.getElementById(setId.setId(elementId, "suggestions-list") || "");
    return li != null ? (_a2 = listEl == null ? void 0 : listEl.getElementsByTagName("li")) == null ? void 0 : _a2[li] : listEl;
  }, [elementId]);
  const suggestionClearHandler = React.useCallback(() => {
    if (isMounted.current) {
      setSuggestionValues(null);
    }
  }, [isMounted]);
  const suggestionHandler = React.useCallback((val) => {
    var _a2;
    const suggestionsArray = suggestionListCallback == null ? void 0 : suggestionListCallback(val);
    if ((_a2 = suggestionsArray == null ? void 0 : suggestionsArray[0]) == null ? void 0 : _a2.label) {
      setSuggestionValues(suggestionsArray);
    } else {
      suggestionClearHandler();
    }
  }, [suggestionClearHandler, suggestionListCallback]);
  const suggestionSelectedHandler = (event, item) => {
    addTag(event, item.value || item.label);
    setTagInput(item.value || item.label);
    focusInput();
    suggestionClearHandler();
  };
  const onSuggestionKeyDown = (event) => {
    if (keyboardUtils.isKey(event, "Esc")) {
      suggestionClearHandler();
      focusInput();
    } else if (keyboardUtils.isKey(event, "Tab")) {
      suggestionClearHandler();
    }
  };
  const onChangeHandler = React.useCallback((_, input) => {
    setTagInput(input);
    if (canShowSuggestions) {
      suggestionHandler(input);
    }
  }, [canShowSuggestions, suggestionHandler]);
  const onInputKeyDownHandler = React.useCallback((event) => {
    if (!canShowSuggestions && commitTagOn.includes(event.code)) {
      addTag(event, tagInput);
    }
  }, [addTag, canShowSuggestions, commitTagOn, tagInput]);
  const onKeyDownHandler = React.useCallback((event) => {
    var _a2;
    if (tagInput === "") {
      switch (event.code) {
        case "ArrowLeft":
          setTagCursorPos(tagCursorPos > 0 ? tagCursorPos - 1 : 0);
          break;
        case "ArrowRight":
          setTagCursorPos(tagCursorPos < value.length ? tagCursorPos + 1 : value.length);
          break;
        case "Backspace":
          if (isTagSelected) {
            deleteTag(tagCursorPos, event, false);
          } else {
            setTagCursorPos(value.length - 1);
          }
          break;
        case "Delete":
          if (isTagSelected) {
            deleteTag(tagCursorPos, event, false);
          }
          break;
      }
    } else {
      switch (event.code) {
        case "ArrowDown":
          (_a2 = getSuggestions(0)) == null ? void 0 : _a2.focus();
          break;
      }
    }
  }, [deleteTag, getSuggestions, isTagSelected, tagCursorPos, tagInput, value.length]);
  const onDeleteTagHandler = React.useCallback((event, i) => {
    deleteTag(i, event, true);
    setValidationState(validationStates.default.standBy);
  }, [deleteTag, setValidationState]);
  const onContainerClickHandler = React.useCallback(() => {
    var _a2;
    (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
    clearTimeout(blurTimeout.current);
    setTagCursorPos(value.length);
  }, [value.length]);
  const onBlurHandler = (evt) => {
    blurTimeout.current = setTimeout(() => {
      if (commitOnBlur) {
        addTag(evt, tagInput);
      }
      onBlur == null ? void 0 : onBlur(evt, tagInput);
    }, 250);
  };
  const onFocusHandler = (evt) => {
    clearTimeout(blurTimeout.current);
    onFocus == null ? void 0 : onFocus(evt, tagInput);
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { id, name, disabled, readOnly, status: validationState, required, onBlur: onBlurHandler, onFocus: onFocusHandler, className: cx(classes.root, {
    [classes.disabled]: disabled,
    [classes.readOnly]: readOnly
  }, className), children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { className: classes.label, id: setId.setId(id, "label"), htmlFor: setId.setId(elementId, "input"), label: textAreaLabel }),
      hasDescription && /* @__PURE__ */ jsxRuntime.jsx(InfoMessage.HvInfoMessage, { className: classes.description, id: setId.setId(elementId, "description"), children: description })
    ] }),
    hasCounter && /* @__PURE__ */ jsxRuntime.jsx(CharCounter.HvCharCounter, { id: setId.setId(elementId, "charCounter"), className: classes.characterCounter, separator: middleCountLabel, currentCharQuantity: value.length, maxCharQuantity: maxTagsQuantity, ...countCharProps }),
    /* @__PURE__ */ jsxRuntime.jsxs(ListContainer.HvListContainer, { className: cx(classes.tagsList, {
      [classes.error]: canShowError,
      [classes.resizable]: resizable && multiline,
      [classes.invalid]: isStateInvalid,
      [classes.singleLine]: !multiline
    }), onKeyDown: onKeyDownHandler, onClick: onContainerClickHandler, ref: containerRef, children: [
      value && value.map((t, i) => {
        const tag = typeof t === "string" ? {
          label: t,
          type: "semantic"
        } : t;
        const {
          label,
          type,
          ...otherProps
        } = tag;
        return /* @__PURE__ */ jsxRuntime.jsx(ListItem.HvListItem, { tabIndex: -1, className: cx({
          [classes.singleLine]: !multiline
        }), classes: {
          gutters: classes.listItemGutters,
          root: classes.listItemRoot
        }, id: setId.setId(elementId, `tag-${i}`), children: /* @__PURE__ */ jsxRuntime.jsx(Tag.HvTag, { label, className: cx({
          [classes.tagSelected]: i === tagCursorPos
        }), classes: {
          chipRoot: classes.chipRoot
        }, type, ...!(readOnly || disabled || type === "categorical") && {
          onDelete: (event) => onDeleteTagHandler(event, i)
        }, deleteButtonProps: {
          tabIndex: -1
        }, ...otherProps }) }, `${tag.label}-${i}`);
      }),
      !(disabled || readOnly) && /* @__PURE__ */ jsxRuntime.jsx(ListItem.HvListItem, { className: cx({
        [classes.singleLine]: !multiline,
        [classes.tagInputRootEmpty]: value.length === 0
      }, !!isTagSelected && css({
        [`& .${BaseInput_styles.staticClasses.inputRoot}`]: {
          backgroundColor: uikitStyles.theme.colors.atmo1
        }
      })), classes: {
        root: classes.tagInputContainerRoot,
        gutters: classes.listItemGutters
      }, id: setId.setId(elementId, `tag-${value.length}`), children: /* @__PURE__ */ jsxRuntime.jsx(Input.HvInput, { value: tagInput, disableClear: true, onChange: onChangeHandler, onKeyDown: onInputKeyDownHandler, placeholder: value.length === 0 ? placeholder : "", autoFocus, className: cx({
        [classes.singleLine]: !multiline
      }), classes: {
        root: classes.tagInputRoot,
        input: classes.input,
        inputBorderContainer: classes.tagInputBorderContainer,
        inputRootFocused: classes.tagInputRootFocused
      }, disabled, readOnly: readOnly || isTagSelected, inputProps: {
        ref: materialInputRef,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : description && setId.setId(elementId, "description") || void 0,
        ...inputProps
      }, inputRef, ...others }) })
    ] }),
    canShowSuggestions && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      hasSuggestions && /* @__PURE__ */ jsxRuntime.jsx("div", { role: "presentation", className: classes.inputExtension }),
      /* @__PURE__ */ jsxRuntime.jsx(Suggestions.HvSuggestions, { id: setId.setId(elementId, "suggestions"), classes: {
        root: classes.suggestionsContainer,
        list: classes.suggestionList
      }, expanded: hasSuggestions, anchorEl: (_a = containerRef == null ? void 0 : containerRef.current) == null ? void 0 : _a.parentElement, onClose: suggestionClearHandler, onKeyDown: onSuggestionKeyDown, onSuggestionSelected: suggestionSelectedHandler, suggestionValues })
    ] }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
exports.tagsInputClasses = TagsInput_styles.staticClasses;
exports.HvTagsInput = HvTagsInput;
//# sourceMappingURL=TagsInput.cjs.map

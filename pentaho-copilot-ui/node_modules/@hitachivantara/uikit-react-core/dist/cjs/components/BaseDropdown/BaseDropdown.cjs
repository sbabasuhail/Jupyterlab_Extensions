"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const reactDom = require("react-dom");
const material = require("@mui/material");
const uikitStyles = require("@hitachivantara/uikit-styles");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const reactPopper = require("react-popper");
const core = require("@popperjs/core");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useTheme = require("../../hooks/useTheme.cjs");
const useForkRef = require("../../hooks/useForkRef.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const keyboardUtils = require("../../utils/keyboardUtils.cjs");
const setId = require("../../utils/setId.cjs");
const focusableElementFinder = require("../../utils/focusableElementFinder.cjs");
const BaseDropdown_styles = require("./BaseDropdown.styles.cjs");
const BaseDropdownContext = require("./BaseDropdownContext/BaseDropdownContext.cjs");
const Typography = require("../Typography/Typography.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const React__default = /* @__PURE__ */ _interopDefault(React);
const HvBaseDropdown = (props) => {
  var _a;
  const {
    id: idProp,
    className,
    classes: classesProp,
    children,
    role,
    placeholder,
    component,
    adornment,
    expanded,
    dropdownHeaderProps,
    defaultExpanded,
    disabled,
    readOnly,
    required,
    disablePortal,
    variableWidth,
    placement: placementProp = "right",
    "aria-expanded": ariaExpandedProp,
    "aria-label": ariaLabelProp,
    "aria-labelledby": ariaLabelledByProp,
    popperProps = {},
    dropdownHeaderRef: dropdownHeaderRefProp,
    onToggle,
    onClickOutside,
    onContainerCreation,
    ...others
  } = useDefaultProps.useDefaultProps("HvBaseDropdown", props);
  const {
    classes,
    cx
  } = BaseDropdown_styles.useClasses(classesProp);
  const {
    rootId
  } = useTheme.useTheme();
  const [isOpen, setIsOpen] = useControlled.useControlled(expanded, Boolean(defaultExpanded));
  const [referenceElement, setReferenceElement] = React.useState(null);
  const [popperElement, setPopperElement] = React.useState(null);
  const [popperMaxSize, setPopperMaxSize] = React.useState({});
  const handleDropdownHeaderRefProp = useForkRef.useForkRef(dropdownHeaderRefProp, dropdownHeaderProps == null ? void 0 : dropdownHeaderProps.ref);
  const handleDropdownHeaderRef = useForkRef.useForkRef(setReferenceElement, handleDropdownHeaderRefProp);
  const ariaRole = role || (component == null ? "combobox" : void 0);
  const ariaExpanded = ariaExpandedProp ?? (ariaRole ? !!isOpen : void 0);
  const id = useUniqueId.useUniqueId(idProp, "hvbasedropdown");
  const containerId = setId.setId(id, "children-container");
  const headerControlArias = {
    "aria-required": required ?? void 0,
    "aria-readonly": readOnly ?? void 0,
    "aria-expanded": ariaExpanded,
    "aria-owns": isOpen ? containerId : void 0,
    "aria-controls": isOpen ? containerId : void 0
  };
  const headerAriaLabels = {
    "aria-label": ariaLabelProp,
    "aria-labelledby": ariaLabelledByProp
  };
  const placement = `bottom-${placementProp === "right" ? "start" : "end"}`;
  const extensionWidth = referenceElement ? referenceElement == null ? void 0 : referenceElement.offsetWidth : "inherit";
  const {
    modifiers: popperPropsModifiers = [],
    ...otherPopperProps
  } = popperProps;
  const onFirstUpdate = React.useCallback(() => {
    if (onContainerCreation)
      onContainerCreation(popperElement);
  }, [onContainerCreation, popperElement]);
  const widthCalculator = React.useCallback(({
    state
  }) => {
    state.styles.popper.width = `${state.rects.reference.width}px`;
  }, []);
  const widthCalculatorEffect = React.useCallback(({
    state
  }) => {
    state.elements.popper.style.width = `${state.elements.reference.offsetWidth}px`;
  }, []);
  const applyMaxSizeCalculator = React.useCallback(({
    state
  }) => {
    const {
      width,
      height
    } = state.modifiersData.maxSize;
    if (width !== (popperMaxSize == null ? void 0 : popperMaxSize.width) || height !== (popperMaxSize == null ? void 0 : popperMaxSize.height)) {
      setPopperMaxSize({
        width,
        height
      });
    }
    state.styles.popper = {
      ...state.styles.popper,
      maxWidth: `${width}px`,
      maxHeight: `${height}px`
    };
  }, [popperMaxSize]);
  const maxSizeCalculator = React.useCallback(({
    state,
    name,
    options
  }) => {
    var _a2, _b;
    const overflow = core.detectOverflow(state, options);
    const x = ((_a2 = state.modifiersData.preventOverflow) == null ? void 0 : _a2.x) || 0;
    const y = ((_b = state.modifiersData.preventOverflow) == null ? void 0 : _b.y) || 0;
    const popperWidth = state.rects.popper.width;
    const popperHeight = state.rects.popper.height;
    const basePlacement = state.placement.split("-")[0];
    const widthProp = basePlacement === "left" ? "left" : "right";
    const heightProp = basePlacement === "top" ? "top" : "bottom";
    state.modifiersData[name] = {
      width: popperWidth - overflow[widthProp] - x,
      height: popperHeight - overflow[heightProp] - y
    };
  }, []);
  const modifiers = React.useMemo(() => [{
    name: "variableWidth",
    enabled: !variableWidth,
    phase: "beforeWrite",
    requires: ["computeStyles"],
    fn: widthCalculator,
    effect: widthCalculatorEffect
  }, {
    name: "maxSize",
    enabled: true,
    phase: "main",
    requiresIfExists: ["offset", "preventOverflow", "flip"],
    fn: maxSizeCalculator
  }, {
    name: "applyMaxSize",
    enabled: true,
    phase: "beforeWrite",
    requires: ["maxSize"],
    fn: applyMaxSizeCalculator
  }, ...popperPropsModifiers], [maxSizeCalculator, applyMaxSizeCalculator, popperPropsModifiers, variableWidth, widthCalculator, widthCalculatorEffect]);
  const {
    styles: popperStyles,
    attributes
  } = reactPopper.usePopper(referenceElement, popperElement, {
    placement,
    modifiers,
    onFirstUpdate,
    ...otherPopperProps
  });
  const popperPlacement = ((_a = attributes.popper) == null ? void 0 : _a["data-popper-placement"]) ?? "bottom";
  const handleToggle = React.useCallback((event) => {
    if (event && !keyboardUtils.isKey(event, "Tab")) {
      event.preventDefault();
    }
    const notControlKey = !!(event == null ? void 0 : event.code) && !keyboardUtils.isOneOfKeys(event, ["Tab", "Enter", "Esc", "ArrowDown", "Space"]);
    const ignoredCombinations = keyboardUtils.isKey(event, "Esc") && !isOpen || keyboardUtils.isKey(event, "ArrowDown") && isOpen || keyboardUtils.isKey(event, "Tab") && !isOpen;
    if (disabled || notControlKey || ignoredCombinations)
      return;
    const newOpen = !isOpen;
    const focusHeader = () => {
      if (!newOpen) {
        referenceElement == null ? void 0 : referenceElement.focus({
          preventScroll: true
        });
      }
      return newOpen;
    };
    setIsOpen(focusHeader());
    onToggle == null ? void 0 : onToggle(event, newOpen);
  }, [isOpen, disabled, setIsOpen, onToggle, referenceElement]);
  const headerComponent = (() => {
    if (component) {
      return React__default.default.cloneElement(component, {
        ref: handleDropdownHeaderRef,
        ...headerControlArias
      });
    }
    const ExpanderComponent = isOpen ? uikitReactIcons.DropUpXS : uikitReactIcons.DropDownXS;
    return /* @__PURE__ */ jsxRuntime.jsxs(
      "div",
      {
        id: setId.setId(id, "header"),
        className: cx(classes.header, {
          [classes.headerDisabled]: disabled,
          [classes.headerReadOnly]: readOnly,
          [classes.headerOpen]: isOpen,
          [classes.headerOpenUp]: isOpen && popperPlacement.includes("top"),
          [classes.headerOpenDown]: isOpen && popperPlacement.includes("bottom")
        }),
        role: ariaRole === "combobox" ? "textbox" : void 0,
        ...headerAriaLabels,
        style: disabled || readOnly ? {
          pointerEvents: "none"
        } : void 0,
        tabIndex: disabled ? -1 : 0,
        ref: handleDropdownHeaderRef,
        ...dropdownHeaderProps,
        children: [
          /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.selection, children: placeholder && typeof placeholder === "string" ? /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { className: cx(classes.placeholder, {
            [classes.selectionDisabled]: disabled
          }), variant: "body", children: placeholder }) : placeholder }),
          /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.arrowContainer, children: adornment || /* @__PURE__ */ jsxRuntime.jsx(ExpanderComponent, { iconSize: "XS", color: disabled ? uikitStyles.theme.colors.secondary_60 : void 0, className: classes.arrow }) })
        ]
      }
    );
  })();
  const containerComponent = (() => {
    const handleContainerKeyDown = (event) => {
      var _a2;
      if (keyboardUtils.isKey(event, "Esc")) {
        handleToggle(event);
      }
      if (keyboardUtils.isKey(event, "Tab") && !event.shiftKey) {
        const focusList = focusableElementFinder.getFirstAndLastFocus(popperElement);
        if (document.activeElement === (focusList == null ? void 0 : focusList.last)) {
          event.preventDefault();
          (_a2 = focusList == null ? void 0 : focusList.first) == null ? void 0 : _a2.focus();
        }
      }
    };
    const handleOutside = (event) => {
      const isButtonClick = referenceElement == null ? void 0 : referenceElement.contains(event.target);
      if (!isButtonClick) {
        onClickOutside == null ? void 0 : onClickOutside(event);
        setIsOpen(false);
        onToggle == null ? void 0 : onToggle(event, false);
      }
    };
    const container = /* @__PURE__ */ jsxRuntime.jsx("div", { ref: setPopperElement, className: classes.container, style: popperStyles.popper, ...attributes.popper, children: /* @__PURE__ */ jsxRuntime.jsx(material.ClickAwayListener, { onClickAway: handleOutside, children: /* @__PURE__ */ jsxRuntime.jsxs("div", { onKeyDown: handleContainerKeyDown, children: [
      popperPlacement.includes("bottom") && /* @__PURE__ */ jsxRuntime.jsx("div", { style: {
        width: extensionWidth
      }, className: cx(classes.inputExtensionOpen, {
        [classes.inputExtensionLeftPosition]: popperPlacement.includes("end")
      }) }),
      /* @__PURE__ */ jsxRuntime.jsx(BaseDropdownContext.default.Provider, { value: popperMaxSize, children: /* @__PURE__ */ jsxRuntime.jsx("div", { id: containerId, className: cx(classes.panel, {
        [classes.panelOpenedUp]: popperPlacement.includes("top"),
        [classes.panelOpenedDown]: popperPlacement.includes("bottom")
      }), children }) }),
      popperPlacement.includes("top") && /* @__PURE__ */ jsxRuntime.jsx("div", { style: {
        width: extensionWidth
      }, className: cx(classes.inputExtensionOpen, classes.inputExtensionOpenShadow, {
        [classes.inputExtensionFloatRight]: popperPlacement.includes("end"),
        [classes.inputExtensionFloatLeft]: popperPlacement.includes("start")
      }) })
    ] }) }) });
    if (disablePortal)
      return container;
    return reactDom.createPortal(container, document.getElementById(rootId || "") || document.body);
  })();
  return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.root, children: [
    /* @__PURE__ */ jsxRuntime.jsx(
      "div",
      {
        id,
        className: cx(classes.anchor, {
          [classes.rootDisabled]: disabled
        }, className),
        ...!readOnly && {
          onKeyDown: handleToggle,
          onClick: handleToggle
        },
        ...ariaRole && {
          role: ariaRole,
          ...headerAriaLabels,
          ...headerControlArias
        },
        tabIndex: -1,
        ...others,
        children: headerComponent
      }
    ),
    isOpen && containerComponent
  ] });
};
exports.baseDropdownClasses = BaseDropdown_styles.staticClasses;
exports.HvBaseDropdown = HvBaseDropdown;
//# sourceMappingURL=BaseDropdown.cjs.map

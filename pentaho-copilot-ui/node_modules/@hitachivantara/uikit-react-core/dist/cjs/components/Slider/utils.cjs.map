{"version":3,"file":"utils.cjs","sources":["../../../../src/components/Slider/utils.ts"],"sourcesContent":["import { CSSProperties } from \"react\";\n\nimport { theme } from \"@hitachivantara/uikit-styles\";\n\nimport validationStates from \"@core/components/Forms/FormElement/validationStates\";\nimport { HvFormStatus } from \"@core/components/Forms\";\n\nimport { HvKnobProperty, HvMarkProperty } from \"./types\";\nimport { SliderStyles } from \"./Slider.styles\";\n\n/**\n * Transform the scaled values into knobs positions.\n *\n * @param {*} sliderValue - he value of the slider to be scaled\n * @param {*} minPointVlue - The value of the first point in the slider from left to right.\n * @param {*} stepVlue - The calculated separation between the values of the slider.\n */\nexport const knobsPositionToScaledValue = (\n  sliderValue: number,\n  minPointValue: number,\n  stepValue: number\n): number => minPointValue + stepValue * sliderValue;\n\n/**\n * Transform the scaled values into knobs positions.\n *\n * @param {*} scaledValue - The value of the slider to be scaled\n * @param {*} minPointValue - The value of the first point in\n * the slider from left to right.\n * @param {*} inverseStepValue - The inverse of calculated separation between\n * the value of the points that compose the slider.\n */\nexport const scaledValueToKnobsPositionValue = (\n  scaledValue: number | undefined,\n  minPointValue: number,\n  inverseStepValue: number\n): number =>\n  typeof scaledValue === \"number\"\n    ? Math.floor((scaledValue - minPointValue) * inverseStepValue)\n    : NaN;\n\n/**\n * Transform the received knobs values into knob positions\n *\n * @param {Object} values - The values of the slider.\n * @param {Number} inverseStepValue - The inverse of calculated separation between\n * the value of the points that compose the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @returns {Array} - The position of the knobs.\n */\nexport const knobsValuesToKnobsPositions = (\n  values: (number | undefined)[],\n  inverseStepValue: number,\n  minPointValue: number\n): number[] => {\n  const knobsPositions: number[] = [];\n\n  values.forEach((value, index) => {\n    knobsPositions[index] = scaledValueToKnobsPositionValue(\n      value,\n      minPointValue,\n      inverseStepValue\n    );\n  });\n\n  return knobsPositions;\n};\n\n/**\n * Transform the received knobs positions into knob values\n *\n * @param {Object} knobPositions - The values of the slider.\n * @param {Number} stepValue - The calculated separation between\n * the value of the points that compose the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @returns {Array} - The position of the knobs.\n */\nexport const knobsPositionsToKnobsValues = (\n  knobPositions: number[],\n  stepValue: number,\n  minPointValue: number\n): number[] => {\n  const knobsValues: number[] = [];\n\n  knobPositions.forEach((value, index) => {\n    knobsValues[index] = knobsPositionToScaledValue(\n      value,\n      minPointValue,\n      stepValue\n    );\n  });\n\n  return knobsValues;\n};\n\n/**\n * Calculates the separation between each value in the slider.\n *\n * @param {*} maxPointValue - The value of the last point in the slider from left to right.\n * @param {*} minPointValue - The value of the first point in the slider from left to right.\n * @param {*} divisionQuantity - How many subdivisions there are in the slider.\n */\nexport const calculateStepValue = (\n  maxPointValue: number,\n  minPointValue: number,\n  divisionQuantity: number\n): number => Math.abs(maxPointValue - minPointValue) / divisionQuantity;\n\n/**\n * Generates the inline styles used for the track of each knob, applying colors if necessary.\n *\n * @param {Object} markProperties - The object provided by the user with\n * the desired configuration for the marks.\n * @param {Integer} markstep - The separation between marks.\n * @param {Integer} divisionQuantity - How many subdivisions there are in the slider.\n * @param {Integer} minPointValue - The value of the first point in the slider from\n * left to right.\n * @param {Integer} stepValue - The calculated separation between the values of the slider.\n * @param {Integer} markDigits - How many decimals the mark will show.\n * @param {Function} formatMark - A function provided by the user that is going to\n * be executed to format the mark text.\n * @param {Object} styles - the default styles for the marks.\n * @returns {Object} - An object with the for the marks.\n * @memberof HvSlider\n */\nexport const createMark = (\n  markProperties: HvMarkProperty[],\n  markstep: number,\n  divisionQuantity: number,\n  minPointValue: number,\n  stepValue: number,\n  markDigits: number,\n  disabled: boolean,\n  styles: SliderStyles,\n  formatMark: (label: React.ReactNode) => React.ReactNode = (mark) => mark\n): {\n  [key: number]: {\n    label: string;\n    style: CSSProperties;\n  };\n} => {\n  const marks: {\n    [key: number]: {\n      label: string;\n      style: CSSProperties;\n    };\n  } = {};\n\n  if (markProperties.length > 0) {\n    markProperties.forEach((markProperty) => {\n      if (typeof markProperty.position === \"number\") {\n        marks[markProperty.position] = disabled\n          ? {\n              label: `${markProperty.label}`,\n              style: {\n                ...styles.disabledMark,\n              },\n            }\n          : {\n              label: `${markProperty.label}`,\n              style: {\n                ...styles.mark,\n              },\n            };\n      }\n    });\n  } else {\n    const roundedMarkStep = Math.floor(markstep);\n\n    for (let index = 0; index <= divisionQuantity; index += roundedMarkStep) {\n      let labelValue: React.ReactNode = knobsPositionToScaledValue(\n        index,\n        minPointValue,\n        stepValue\n      ).toFixed(markDigits);\n\n      labelValue = formatMark?.(labelValue) || labelValue;\n\n      marks[index] = disabled\n        ? {\n            label: `${labelValue}`,\n            style: {\n              ...styles.disabledMark,\n            },\n          }\n        : {\n            label: `${labelValue}`,\n            style: {\n              ...styles.mark,\n            },\n          };\n    }\n  }\n\n  return marks;\n};\n\n/**\n * Generates the inline styles used for the track of each knob, applying colors if necessary.\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Object} styles - the default styles for the tracks.\n * @returns {Object} - An object with the style for each track.\n * @memberof HvSlider\n */\nexport const createTrackStyles = (\n  knobProperties: HvKnobProperty[],\n  styles: SliderStyles\n): CSSProperties[] => {\n  const trackStyles: CSSProperties[] = [];\n\n  if (knobProperties.length > 0) {\n    knobProperties.forEach((knobProperty, index) => {\n      trackStyles[index] = { ...styles.track };\n      if (knobProperty.color) {\n        trackStyles[index].backgroundColor = knobProperty.trackColor;\n      }\n    });\n  }\n\n  return trackStyles;\n};\n\n/**\n * Generates the inline styles used for each knob, applying colors if specified.\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Object} styles - the default styles for the knobs.\n * @returns {Object} - An object with both the inner and outer styles for the knob.\n * @memberof HvSlider\n */\nexport const createKnobStyles = (\n  knobProperties: HvKnobProperty[],\n  styles: SliderStyles\n): {\n  knobInner: CSSProperties[];\n  knobOuterStyle: CSSProperties[];\n} => {\n  const knobInner: CSSProperties[] = [];\n  const knobOuterStyle: CSSProperties[] = [];\n\n  const lastItem = knobProperties.length - 1;\n  if (knobProperties.length > 0) {\n    knobProperties.forEach((knobProperty, index) => {\n      knobInner[index] = { ...styles.knobInner };\n      knobOuterStyle[index] = { ...styles.knobOuter };\n\n      if (knobProperty.color) {\n        knobInner[index].backgroundColor = knobProperty.color;\n        knobOuterStyle[index].backgroundColor = \"transparent\";\n      }\n\n      if (knobProperty.hidden) {\n        knobInner[index] = styles.knobHidden;\n        if (index === lastItem) {\n          knobInner[index] = { ...styles.knobHiddenLast };\n          knobInner[index].backgroundColor = knobProperty.color;\n          knobOuterStyle[index] = { ...styles.knobHidden };\n          knobOuterStyle[index].backgroundColor = knobProperty.color;\n        }\n      }\n    });\n  }\n\n  return {\n    knobInner,\n    knobOuterStyle,\n  };\n};\n\n/**\n * Analyzes both the values and the default values to determine whether the slider is working in single mode.\n *\n * @param {Array} values - the values where the knobs are positioned when controlled.\n * @param {Array} defaultValues - the values where the knobs start when uncontrolled.\n * @returns {Boolean} - if true the slider should work as single slider\n */\nexport const isSingleSlider = (\n  values: number[],\n  defaultValues: (number | undefined)[]\n): boolean => {\n  if (!(values?.length > 1)) {\n    return defaultValues.length === 1;\n  }\n  return values.length === 1;\n};\n\n/**\n * Generates the default knob styles for each knob\n *\n * @param {Object} knobProperties - The object provided by the user with\n * the desired configuration for the knobs.\n * @param {Integer} numberOfKnobs - the default styles for the knobs.\n * @param {Object} theme - The theme to extract the colors.\n *\n * @returns {Object} - An object with both the inner and outer styles for the knob.\n * @memberof HvSlider\n */\nexport const generateDefaultKnobProperties = (\n  numberOfKnobs: number = 1,\n  disabled: boolean = false,\n  knobPropertiesProp?: HvKnobProperty[]\n): HvKnobProperty[] => {\n  let knobProperties = knobPropertiesProp || [];\n\n  const defaultKnobStyles = {\n    color: theme.colors.secondary,\n    hoverColor: theme.colors.secondary,\n    trackColor: theme.colors.secondary,\n    dragColor: theme.colors.secondary,\n    knobRingColor: theme.colors.atmo1,\n  };\n\n  const disabledKnobStyles = {\n    color: theme.colors.secondary_60,\n    hoverColor: theme.colors.secondary_60,\n    trackColor: theme.colors.secondary_60,\n    dragColor: theme.colors.secondary_60,\n    knobRingColor: theme.colors.secondary_60,\n  };\n\n  if (knobProperties.length > 0) {\n    knobProperties = knobProperties.slice(0, numberOfKnobs);\n    knobProperties = knobProperties.map((knobProperty) => {\n      if (!disabled) {\n        return {\n          ...disabledKnobStyles,\n          ...knobProperty,\n        };\n      }\n      return {\n        ...defaultKnobStyles,\n        ...knobProperty,\n      };\n    });\n  } else {\n    for (let i = 0; i < numberOfKnobs; i += 1) {\n      if (!disabled) knobProperties.push(defaultKnobStyles);\n      if (disabled) knobProperties.push(disabledKnobStyles);\n    }\n  }\n\n  return knobProperties;\n};\n\nconst pushSlider = (\n  index: number,\n  inputIndex: number,\n  inputValue: number\n): number => {\n  const difference = index - inputIndex;\n\n  return inputValue + difference;\n};\n\nexport const ensureValuesConsistency = (\n  knobPositions: number[],\n  inputIndex: number\n): number[] => {\n  const newKnobsPosition: number[] = [...knobPositions];\n\n  newKnobsPosition.forEach((value, index) => {\n    if (Number.isNaN(value) || value == null) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex]\n      );\n    } else if (index < inputIndex && value > newKnobsPosition[inputIndex]) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex]\n      );\n    } else if (index > inputIndex && value < newKnobsPosition[inputIndex]) {\n      newKnobsPosition[index] = pushSlider(\n        index,\n        inputIndex,\n        newKnobsPosition[inputIndex]\n      );\n    }\n  });\n\n  return newKnobsPosition;\n};\n\nexport const convertStatusToArray = (\n  length: number,\n  status?: HvFormStatus | HvFormStatus[]\n): {\n  arrayStatus?: HvFormStatus[];\n  arrayDefaultStatus: (keyof typeof validationStates)[];\n} => {\n  const result: {\n    arrayStatus?: HvFormStatus[];\n    arrayDefaultStatus: (keyof typeof validationStates)[];\n  } = {\n    arrayDefaultStatus: Array.from({ length }, () => validationStates.standBy),\n  };\n\n  if (status == null) {\n    return result;\n  }\n  if (!Array.isArray(status)) {\n    result.arrayStatus = Array.from({ length }, () => status);\n    return result;\n  }\n  result.arrayStatus = status;\n\n  return result;\n};\n\nexport const statusArrayToFormStatus = (\n  arrayStatus: HvFormStatus[]\n): keyof typeof validationStates => {\n  const invalid = arrayStatus.some(\n    (status) => status === validationStates.invalid\n  );\n\n  if (invalid) return validationStates.invalid;\n\n  const valid = arrayStatus.some((status) => status === validationStates.valid);\n\n  if (valid) return validationStates.valid;\n\n  return validationStates.standBy;\n};\n\nexport const knobsValuesToString = (\n  knobsValues: number[],\n  markDigits: number\n): string[] =>\n  knobsValues.map((knobValue) =>\n    Number.isNaN(knobValue) ? \"\" : knobValue.toFixed(markDigits)\n  );\n\nexport const stringValuesToKnobs = (inputsValues: string[]): number[] =>\n  inputsValues.map((inputValue) => parseFloat(inputValue));\n"],"names":["knobsPositionToScaledValue","sliderValue","minPointValue","stepValue","scaledValueToKnobsPositionValue","scaledValue","inverseStepValue","Math","floor","NaN","knobsValuesToKnobsPositions","values","knobsPositions","forEach","value","index","knobsPositionsToKnobsValues","knobPositions","knobsValues","calculateStepValue","maxPointValue","divisionQuantity","abs","createMark","markProperties","markstep","markDigits","disabled","styles","formatMark","mark","marks","length","markProperty","position","label","style","disabledMark","roundedMarkStep","labelValue","toFixed","createTrackStyles","knobProperties","trackStyles","knobProperty","track","color","backgroundColor","trackColor","createKnobStyles","knobInner","knobOuterStyle","lastItem","knobOuter","hidden","knobHidden","knobHiddenLast","isSingleSlider","defaultValues","generateDefaultKnobProperties","numberOfKnobs","knobPropertiesProp","defaultKnobStyles","theme","colors","secondary","hoverColor","dragColor","knobRingColor","atmo1","disabledKnobStyles","secondary_60","slice","map","i","push","pushSlider","inputIndex","inputValue","difference","ensureValuesConsistency","newKnobsPosition","Number","isNaN","convertStatusToArray","status","result","arrayDefaultStatus","Array","from","validationStates","standBy","isArray","arrayStatus","statusArrayToFormStatus","invalid","some","valid","knobsValuesToString","knobValue","stringValuesToKnobs","inputsValues","parseFloat"],"mappings":"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"}
"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const Slider = require("rc-slider");
const React = require("react");
const Tooltip = require("rc-tooltip");
const setId = require("../../utils/setId.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const Slider_styles = require("./Slider.styles.cjs");
const utils = require("./utils.cjs");
const SliderInput = require("./SliderInput/SliderInput.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const Slider__default = /* @__PURE__ */ _interopDefault(Slider);
const Tooltip__default = /* @__PURE__ */ _interopDefault(Tooltip);
const HvSlider = (props) => {
  const {
    id,
    className,
    name,
    label,
    status,
    statusMessage,
    disabled,
    classes: classesProp,
    sliderProps,
    knobProps,
    inputProps,
    requiredMessage = "The value is required",
    noOverlap = true,
    hideInput = false,
    required = false,
    readOnly = false,
    markProperties = [],
    defaultValues = [void 0],
    values: valuesProp = [],
    knobProperties: knobPropertiesProp,
    "aria-errormessage": ariaErrorMessage,
    maxPointValue = 100,
    minPointValue = 0,
    divisionQuantity = 100,
    markStep = 20,
    markDigits = 0,
    formatMark,
    onChange,
    onBlur,
    onBeforeChange,
    onAfterChange,
    formatTooltip,
    ...others
  } = useDefaultProps.useDefaultProps("HvSlider", props);
  const {
    classes,
    cx
  } = Slider_styles.useClasses(classesProp);
  const hasLabel = label != null;
  const isDirty = React.useRef(false);
  const elementId = useUniqueId.useUniqueId(id, "hvSlider");
  const sliderInputId = setId.setId(elementId, "input");
  const stepValue = React.useMemo(() => utils.calculateStepValue(maxPointValue, minPointValue, divisionQuantity), [divisionQuantity, maxPointValue, minPointValue]);
  const inverseStepValue = 1 / stepValue;
  const marks = React.useMemo(() => utils.createMark(markProperties, markStep, divisionQuantity, minPointValue, stepValue, markDigits, !!disabled, Slider_styles.sliderStyles, formatMark), [disabled, divisionQuantity, formatMark, markDigits, markProperties, markStep, minPointValue, stepValue]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const isSingle = React.useMemo(() => utils.isSingleSlider(valuesProp, defaultValues), [defaultValues, valuesProp]);
  const value = React.useMemo(() => (valuesProp == null ? void 0 : valuesProp.length) > 0 ? utils.knobsValuesToKnobsPositions(valuesProp, inverseStepValue, minPointValue) : void 0, [inverseStepValue, minPointValue, valuesProp]);
  const defaultKnobsPositions = React.useMemo(() => utils.knobsValuesToKnobsPositions(defaultValues, inverseStepValue, minPointValue), [defaultValues, inverseStepValue, minPointValue]);
  const [knobsPositions, setKnobsPositions] = useControlled.useControlled(value, defaultKnobsPositions);
  const {
    arrayStatus,
    arrayDefaultStatus
  } = React.useMemo(() => utils.convertStatusToArray(knobsPositions.length, status), [knobsPositions.length, status]);
  const [validationStatus, setValidationState] = useControlled.useControlled(arrayStatus, arrayDefaultStatus);
  const [validationMessage, setValidationMessage] = useControlled.useControlled(statusMessage, "");
  const [isDraggingTrack, setIsDraggingTrack] = React.useState(false);
  const knobProperties = utils.generateDefaultKnobProperties(knobsPositions.length, disabled, knobPropertiesProp);
  const rangesCount = knobProperties.length - 1;
  const trackStyles = utils.createTrackStyles(knobProperties, Slider_styles.sliderStyles);
  const knobStyles = utils.createKnobStyles(knobProperties, Slider_styles.sliderStyles);
  const performValidation = React.useCallback(() => {
    let invalid = false;
    const newValidationState = knobsPositions.map((position) => {
      if (position == null || Number.isNaN(position)) {
        invalid = true;
        return validationStates.default.invalid;
      }
      return validationStates.default.valid;
    });
    setValidationState([...newValidationState]);
    if (invalid) {
      setValidationMessage(requiredMessage);
      return;
    }
    setValidationMessage("");
  }, [knobsPositions, requiredMessage, setValidationMessage, setValidationState]);
  React.useEffect(() => {
    const stepVl = utils.calculateStepValue(maxPointValue, minPointValue, divisionQuantity);
    const inverseStepVl = 1 / stepVl;
    if ((valuesProp == null ? void 0 : valuesProp.length) > 0) {
      setKnobsPositions(utils.knobsValuesToKnobsPositions(valuesProp.length > 0 ? valuesProp : defaultValues, inverseStepVl, minPointValue));
    }
  }, [defaultValues, divisionQuantity, maxPointValue, minPointValue, setKnobsPositions, valuesProp]);
  React.useEffect(() => {
    if (!isDirty.current) {
      return;
    }
    performValidation();
  }, [knobsPositions, requiredMessage, performValidation]);
  const onMouseDownHandler = (event) => {
    if (event.target.className.includes("track")) {
      setIsDraggingTrack(true);
    }
  };
  const onMouseUpHandler = () => {
    setIsDraggingTrack(false);
  };
  const generateKnobsPositionAndValues = (knobsCurrentPosition) => {
    const newKnobsPosition = knobsCurrentPosition.slice();
    const knobsValues = [];
    let duplicatedValue = null;
    const findDuplicated = newKnobsPosition.filter((item, index) => newKnobsPosition.indexOf(item) !== index);
    if (noOverlap && findDuplicated.length > 0) {
      [duplicatedValue] = findDuplicated;
    }
    newKnobsPosition.forEach((position, index, array) => {
      const newArray = array;
      let newPosition = position;
      if (noOverlap && newPosition === duplicatedValue) {
        const previousValue = knobsPositions[index];
        if (previousValue !== newPosition) {
          newPosition += newPosition > previousValue ? -1 : 1;
          newArray[index] = newPosition;
        }
      }
      knobsValues[index] = utils.knobsPositionToScaledValue(newPosition, minPointValue, stepValue);
    }, void 0);
    return {
      knobsPosition: newKnobsPosition,
      knobsValues
    };
  };
  const onBlurHandler = (event) => {
    const knobs = generateKnobsPositionAndValues(knobsPositions);
    performValidation();
    onBlur == null ? void 0 : onBlur(event, knobs.knobsValues, status);
  };
  const onChangeHandler = (knobsPosition) => {
    isDirty.current = true;
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    knobProperties.forEach((knobProperty, index) => {
      if (knobProperty.fixed) {
        knobs.knobsPosition[index] = utils.scaledValueToKnobsPositionValue(defaultValues[index], minPointValue, inverseStepValue);
      }
    });
    if (disabled || readOnly)
      return;
    onChange == null ? void 0 : onChange(knobs.knobsValues);
    setKnobsPositions(knobs.knobsPosition);
  };
  const onInputChangeHandler = (inputValues, index) => {
    let newKnobPositions = utils.knobsValuesToKnobsPositions(inputValues, inverseStepValue, minPointValue);
    newKnobPositions = utils.ensureValuesConsistency(newKnobPositions, index);
    onChangeHandler(newKnobPositions);
  };
  const onBeforeChangeHandler = (knobsPosition) => {
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    onBeforeChange == null ? void 0 : onBeforeChange(knobs.knobsValues);
  };
  const onAfterChangeHandler = (knobsPosition) => {
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    onAfterChange == null ? void 0 : onAfterChange(knobs.knobsValues);
  };
  const createKnob = (knobNode, params) => {
    var _a, _b;
    const {
      value: knobValue,
      dragging,
      index
    } = params;
    const {
      className: knobClassName,
      style,
      ...restProps
    } = knobNode.props;
    const scaledKnobValue = utils.knobsPositionToScaledValue(knobValue, minPointValue, stepValue).toFixed(markDigits);
    if (dragging) {
      style.backgroundColor = (_a = knobProperties[index]) == null ? void 0 : _a.dragColor;
    } else {
      style.backgroundColor = (_b = knobProperties[index]) == null ? void 0 : _b.color;
    }
    const isEmpty = Number.isNaN(knobsPositions[index]) || knobsPositions[index] == null;
    const handleId = setId.setId(elementId, "knob");
    const indexedHandleId = setId.setId(handleId, index);
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className: cx({
      [classes.handleContainer]: !!(!disabled && !isEmpty),
      [classes.handleContainerDisabled]: !!(disabled && !isEmpty),
      [classes.handleHiddenContainer]: isEmpty || readOnly
    }), children: /* @__PURE__ */ jsxRuntime.jsx(Tooltip__default.default, { prefixCls: "rc-slider-tooltip", overlay: (formatTooltip == null ? void 0 : formatTooltip(scaledKnobValue)) || scaledKnobValue, visible: dragging, placement: "top", overlayClassName: classes.sliderTooltip, getTooltipContainer: () => document.getElementById(indexedHandleId || ""), children: /* @__PURE__ */ jsxRuntime.jsx("div", { id: indexedHandleId, style, className: cx(knobClassName, classes.handle), ...restProps, "aria-label": `${label}-knob-${index}`, "aria-valuenow": utils.knobsPositionToScaledValue(knobValue, minPointValue, stepValue), "aria-valuemin": minPointValue, "aria-valuemax": maxPointValue, ...knobProps == null ? void 0 : knobProps[index] }) }) }, index);
  };
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { className: cx(classes.root, {
    [classes.trackStandBy]: !readOnly && !disabled && !isSingle && !isDraggingTrack,
    [classes.trackDragging]: !readOnly && !disabled && !isSingle && isDraggingTrack,
    [classes.rootDisabled]: !!disabled
  }, className), id, name, status: utils.statusArrayToFormStatus(validationStatus), disabled, required, readOnly, onMouseDown: onMouseDownHandler, onMouseUp: onMouseUpHandler, onBlur: onBlurHandler, ...others, children: [
    (hasLabel || !hideInput) && /* @__PURE__ */ jsxRuntime.jsxs("div", { className: cx(classes.labelContainer, {
      [classes.labelIncluded]: hasLabel,
      [classes.onlyInput]: !hasLabel
    }), children: [
      hasLabel && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { id: setId.setId(elementId, "label"), className: classes.label, htmlFor: setId.setId(elementId, "slider"), label }),
      !hideInput && /* @__PURE__ */ jsxRuntime.jsx(SliderInput.HvSliderInput, { id: sliderInputId, label, values: utils.knobsPositionsToKnobsValues(knobsPositions, stepValue, minPointValue), onChange: onInputChangeHandler, status: validationStatus, disabled, readOnly, markDigits, inputProps })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsxs("div", { className: cx(classes.sliderBase, classes.sliderContainer), children: [
      isSingle && /* @__PURE__ */ jsxRuntime.jsx(Slider__default.default, { handleRender: createKnob, className: classes.sliderRoot, min: 0, max: divisionQuantity, step: 1, marks, dotStyle: disabled ? Slider_styles.sliderStyles.dotDisabled : Slider_styles.sliderStyles.dot, onChange: (singleValue) => onChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onBeforeChange: (singleValue) => onBeforeChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onAfterChange: (singleValue) => onAfterChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), value: knobsPositions.length > 0 ? knobsPositions[0] : void 0, allowCross: false, disabled, count: rangesCount, railStyle: Slider_styles.sliderStyles.rail, handleStyle: knobStyles.knobInner, trackStyle: trackStyles, ...sliderProps }),
      !isSingle && /* @__PURE__ */ jsxRuntime.jsx(Slider__default.default, { range: true, handleRender: createKnob, className: cx(classes.sliderRoot, {
        [classes.rootRange]: !isSingle
      }), min: 0, max: divisionQuantity, step: 1, marks, disabled, dotStyle: disabled ? Slider_styles.sliderStyles.dotDisabled : Slider_styles.sliderStyles.dot, onChange: (singleValue) => onChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onBeforeChange: (singleValue) => onBeforeChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onAfterChange: (singleValue) => onAfterChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), value: knobsPositions.length > 0 ? [...knobsPositions] : void 0, allowCross: false, count: rangesCount, railStyle: Slider_styles.sliderStyles.rail, handleStyle: knobStyles.knobInner, trackStyle: trackStyles, draggableTrack: !readOnly && !isSingle, ...sliderProps })
    ] }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), className: classes.error, disableBorder: true, children: validationMessage })
  ] });
};
exports.sliderClasses = Slider_styles.staticClasses;
exports.HvSlider = HvSlider;
//# sourceMappingURL=Slider.cjs.map

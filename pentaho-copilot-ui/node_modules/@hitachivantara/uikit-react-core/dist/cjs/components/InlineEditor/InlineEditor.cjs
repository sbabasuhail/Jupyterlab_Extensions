"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const useControlled = require("../../hooks/useControlled.cjs");
const useTheme = require("../../hooks/useTheme.cjs");
const keyboardUtils = require("../../utils/keyboardUtils.cjs");
const InlineEditor_styles = require("./InlineEditor.styles.cjs");
const Button = require("../Button/Button.cjs");
const Input = require("../Input/Input.cjs");
const Typography = require("../Typography/Typography.cjs");
const HvInlineEditor = (props) => {
  const {
    className,
    classes: classesProp,
    value: valueProp,
    defaultValue,
    showIcon,
    component: InputComponent = Input.HvInput,
    variant = "body",
    placeholder = "Enter text",
    onBlur,
    onChange,
    onKeyDown,
    buttonProps,
    typographyProps,
    ...others
  } = useDefaultProps.useDefaultProps("HvInlineEditor", props);
  const {
    classes,
    cx
  } = InlineEditor_styles.useClasses(classesProp);
  const [value, setValue] = useControlled.useControlled(valueProp, defaultValue);
  const [editMode, setEditMode] = React.useState(false);
  const [cachedValue, setCachedValue] = React.useState(value);
  const inputRef = React.useRef();
  const {
    activeTheme
  } = useTheme.useTheme();
  const typographyStyles = (activeTheme == null ? void 0 : activeTheme.typography[variant]) || {};
  const {
    lineHeight
  } = typographyStyles;
  React.useLayoutEffect(() => {
    const input = inputRef.current;
    if (editMode && input) {
      input.focus();
      input.select();
    }
  }, [editMode]);
  const handleClick = () => {
    setEditMode(true);
    setCachedValue(value);
  };
  const handleBlur = (event) => {
    setEditMode(false);
    const newValue = value || cachedValue;
    setValue(newValue);
    onBlur == null ? void 0 : onBlur(event, newValue);
  };
  const handleKeyDown = (event) => {
    if (keyboardUtils.isKey(event, "Esc")) {
      setEditMode(false);
      setValue(cachedValue);
    }
    onKeyDown == null ? void 0 : onKeyDown(event);
  };
  const handleChange = (event, val) => {
    setValue(val);
    onChange == null ? void 0 : onChange(event, val);
  };
  return /* @__PURE__ */ jsxRuntime.jsx("div", { className: cx(classes.root, className), children: editMode ? /* @__PURE__ */ jsxRuntime.jsx(InputComponent, { inputRef, classes: {
    root: classes.inputRoot,
    input: classes.input,
    inputBorderContainer: classes.inputBorderContainer
  }, inputProps: {
    style: {
      ...typographyStyles,
      height: InputComponent === Input.HvInput ? lineHeight : void 0
    }
  }, value, onBlur: handleBlur, onChange: handleChange, onKeyDown: handleKeyDown, ...others }) : /* @__PURE__ */ jsxRuntime.jsx(Button.HvButton, { variant: "secondaryGhost", overrideIconColors: false, endIcon: /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.Edit, { color: "secondary_60", role: "none", className: cx(classes.icon, {
    [classes.iconVisible]: showIcon
  }) }), className: cx(classes.button, {
    [classes.largeText]: parseInt(lineHeight, 10) >= 28
  }), onClick: handleClick, ...buttonProps, children: /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { variant, noWrap: true, className: cx(classes.text, {
    [classes.textEmpty]: !value
  }), ...typographyProps, children: value || placeholder }) }) });
};
exports.inlineEditorClasses = InlineEditor_styles.staticClasses;
exports.HvInlineEditor = HvInlineEditor;
//# sourceMappingURL=InlineEditor.cjs.map

"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const reactWindow = require("react-window");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const setId = require("../../utils/setId.cjs");
const wrapperTooltip = require("../../utils/wrapperTooltip.cjs");
const List_styles = require("./List.styles.cjs");
const useSelectableList = require("./useSelectableList.cjs");
const utils = require("./utils.cjs");
const Radio = require("../Radio/Radio.cjs");
const Link = require("../Link/Link.cjs");
const ListContainer = require("../ListContainer/ListContainer.cjs");
const Typography = require("../Typography/Typography.cjs");
const CheckBox = require("../CheckBox/CheckBox.cjs");
const ListItem = require("../ListContainer/ListItem/ListItem.cjs");
const DEFAULT_LABELS = {
  selectAll: "Select All",
  selectionConjunction: "/"
};
const HvList = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    multiSelect = false,
    hasTooltips = false,
    showSelectAll = false,
    labels = DEFAULT_LABELS,
    useSelector = false,
    selectable = true,
    singleSelectionToggle = true,
    condensed = false,
    onChange,
    onClick,
    values: valuesProp = [],
    height,
    virtualized = false,
    ...others
  } = useDefaultProps.useDefaultProps("HvList", props);
  const {
    classes,
    cx
  } = List_styles.useClasses(classesProp);
  const [list, setList, selection] = useSelectableList.useSelectableList(valuesProp);
  const listRef = React.useRef(null);
  React.useEffect(() => {
    const passedProps = {
      multiSelect,
      selectable,
      singleSelectionToggle
    };
    const parsedList = utils.parseList(void 0, passedProps, void 0, valuesProp);
    setList(parsedList);
  }, [valuesProp, multiSelect, selectable, singleSelectionToggle, setList]);
  const [role, itemRole] = React.useMemo(() => {
    if (selectable && useSelector)
      return ["list", "listitem"];
    if (selectable)
      return ["listbox", "option"];
    return ["menu", "menuitem"];
  }, [selectable, useSelector]);
  const handleSelect = (evt, item) => {
    if (!item.path)
      evt.preventDefault();
    if (item.disabled)
      return;
    const passedProps = {
      multiSelect,
      selectable,
      singleSelectionToggle
    };
    const parsedList = utils.parseList(item, passedProps, void 0, list);
    setList(parsedList);
    onClick == null ? void 0 : onClick(evt, item);
    onChange == null ? void 0 : onChange(parsedList);
  };
  const handleSelectAll = () => {
    const passedProps = {
      multiSelect,
      selectable,
      singleSelectionToggle
    };
    const anySelectableSelected = list.some((elem) => elem.selected || elem.disabled);
    const parsedList = utils.parseList(void 0, passedProps, !anySelectableSelected, list);
    setList(parsedList);
    onChange == null ? void 0 : onChange(parsedList);
  };
  const renderLeftIcon = (item) => {
    var _a;
    return React.isValidElement(item.icon) ? item.icon : (_a = item.icon) == null ? void 0 : _a.call(item, {
      isSelected: item.selected,
      isDisabled: item.disabled
    });
  };
  const renderSelectAll = () => {
    const {
      selectAll,
      selectionConjunction
    } = labels;
    const anySelected2 = !!(selection == null ? void 0 : selection.length);
    const allSelected = selection.length === list.length;
    const selectionLabel = /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { component: "span", children: !anySelected2 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx("b", { children: selectAll }),
      ` (${list.length})`
    ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx("b", { children: selection.length }),
      ` ${selectionConjunction} `,
      list.length
    ] }) });
    return /* @__PURE__ */ jsxRuntime.jsx(CheckBox.HvCheckBox, { id: setId.setId(id, "select-all"), label: selectionLabel, onChange: handleSelectAll, className: classes.selectAllSelector, indeterminate: anySelected2 && !allSelected, checked: allSelected });
  };
  const renderItemText = (item) => {
    const ItemText = wrapperTooltip.wrapperTooltip(hasTooltips, item.label, item.label);
    return !multiSelect && item.path ? /* @__PURE__ */ jsxRuntime.jsx(Link.HvLink, { route: item.path, classes: {
      a: classes.link
    }, children: /* @__PURE__ */ jsxRuntime.jsx(ItemText, {}) }, item.label) : /* @__PURE__ */ jsxRuntime.jsx(ItemText, {});
  };
  const renderMultiSelectItem = (item, itemId) => {
    if (useSelector) {
      const Selection = wrapperTooltip.wrapperTooltip(hasTooltips, /* @__PURE__ */ jsxRuntime.jsx(CheckBox.HvCheckBox, { id: setId.setId(itemId, "selector"), label: item.label, checked: item.selected, disabled: item.disabled, onChange: (evt) => handleSelect(evt, item), classes: {
        root: classes.selectorRoot,
        container: classes.selectorContainer,
        label: classes.truncate
      } }), item.label);
      return /* @__PURE__ */ jsxRuntime.jsx(Selection, {});
    }
    return renderItemText(item);
  };
  const renderSingleSelectItem = (item, itemId) => {
    if (useSelector) {
      const Selection = wrapperTooltip.wrapperTooltip(hasTooltips, /* @__PURE__ */ jsxRuntime.jsx(Radio.HvRadio, { id: setId.setId(itemId, "selector"), label: item.label, checked: item.selected, disabled: item.disabled, classes: {
        root: classes.selectorRoot,
        container: classes.selectorContainer,
        label: classes.truncate
      } }), item.label);
      return /* @__PURE__ */ jsxRuntime.jsx(Selection, {});
    }
    return renderItemText(item);
  };
  const renderListItem = (item, i, otherProps = {}) => {
    const itemId = setId.setId(id, "item", i);
    const selected = item.selected || false;
    let startAdornment = null;
    if (!useSelector && item.icon) {
      startAdornment = renderLeftIcon(item);
    }
    return /* @__PURE__ */ jsxRuntime.jsx(ListItem.HvListItem, { id: itemId, role: itemRole, disabled: item.disabled || void 0, className: classes.item, classes: {
      selected: cx({
        [classes.itemSelector]: useSelector || multiSelect
      })
    }, selected: multiSelect || selected ? selected : void 0, onClick: (evt) => handleSelect(evt, item), startAdornment, endAdornment: item.showNavIcon && /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.DropRightXS, { className: classes.box, iconSize: "XS" }), ...otherProps, children: multiSelect ? renderMultiSelectItem(item, itemId) : renderSingleSelectItem(item, itemId) }, i);
  };
  const filteredList = list.filter((it) => !it.isHidden);
  const anySelected = list.map((item) => item.selected && !item.disabled).reduce((result, selected) => result || selected, false);
  const selectedItemIndex = list.findIndex((item) => item.selected);
  React.useEffect(() => {
    if (selectedItemIndex >= 0 && listRef.current !== null) {
      listRef.current.scrollToItem(selectedItemIndex);
    }
  }, [listRef, selectedItemIndex]);
  const renderVirtualizedListItem = ({
    index,
    style
  }) => {
    const item = filteredList[index];
    const tabIndex = item.tabIndex || !anySelected && index === 0 || item.selected && !item.disabled ? 0 : -1;
    return renderListItem(item, index, {
      style: {
        ...style,
        top: `${parseFloat(style.top) + 5}px`,
        left: `${parseFloat(style.left) + 5}px`,
        width: `calc(${parseFloat(style.width)}% - 10px)`
      },
      tabIndex,
      interactive: true,
      condensed,
      disableGutters: useSelector
    });
  };
  const ariaMultiSelectable = role === "listbox" && multiSelect || void 0;
  const ListContainer$1 = React.useMemo(() => {
    return React.forwardRef(({
      ...rest
    }, ref) => /* @__PURE__ */ jsxRuntime.jsx(ListContainer.HvListContainer, { id, className: cx(classes.root, className), role, interactive: true, condensed, disableGutters: useSelector, "aria-multiselectable": ariaMultiSelectable, ref, ...rest }));
  }, [cx, id, useSelector, className, classes.root, role, condensed, ariaMultiSelectable]);
  if (filteredList.length === 0)
    return null;
  return /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    multiSelect && useSelector && showSelectAll && renderSelectAll(),
    !virtualized ? /* @__PURE__ */ jsxRuntime.jsx(ListContainer.HvListContainer, { id, className: cx(classes.root, className), role, interactive: true, condensed, disableGutters: useSelector, "aria-multiselectable": ariaMultiSelectable, ...others, children: filteredList.map((item, i) => renderListItem(item, i)) }) : /* @__PURE__ */ jsxRuntime.jsx(reactWindow.FixedSizeList, { ref: listRef, className: classes.virtualizedRoot, height: (height || 0) + 5, width: "100%", itemCount: filteredList.length, itemSize: condensed ? 32 : 40, innerElementType: ListContainer$1, ...others, children: renderVirtualizedListItem })
  ] });
};
exports.listClasses = List_styles.staticClasses;
exports.HvList = HvList;
//# sourceMappingURL=List.cjs.map

{"version":3,"file":"TreeView.cjs","sources":["../../../../../src/components/VerticalNavigation/TreeView/TreeView.tsx"],"sourcesContent":["import { forwardRef, useCallback, useMemo, useRef, useState } from \"react\";\n\nimport { useControlled } from \"@core/hooks/useControlled\";\nimport { useUniqueId } from \"@core/hooks/useUniqueId\";\nimport { useForkRef } from \"@core/hooks/useForkRef\";\n\nimport { ExtractNames } from \"@core/utils/classes\";\nimport {\n  NavigationMode,\n  TreeViewControlContext,\n  TreeViewStateContext,\n} from \"./TreeViewContext\";\nimport { DescendantProvider } from \"./descendants\";\nimport { staticClasses, useClasses } from \"./TreeView.styles\";\n\nexport { staticClasses as treeViewClasses };\n\nexport type HvVerticalNavigationTreeViewClasses = ExtractNames<\n  typeof useClasses\n>;\n\nexport interface HvVerticalNavigationTreeViewProps {\n  /**\n   * Id to be applied to the root node.\n   */\n  id?: string;\n  /**\n   * Class names to be applied.\n   */\n  className?: string;\n  /**\n   * A Jss Object used to override or extend the styles applied to the component.\n   */\n  classes?: HvVerticalNavigationTreeViewClasses;\n  /**\n   * Modus operandi (role) of the widget instance.\n   */\n  mode?: NavigationMode;\n  /**\n   * Enables selection.\n   * @default false\n   */\n  selectable?: boolean;\n  /**\n   * Enables the simultaneous selection of multiple items.\n   * @default false\n   */\n  multiSelect?: boolean;\n  /**\n   * The selected nodes' ids.\n   *\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected?: string[] | string;\n  /**\n   * When uncontrolled, defines the initial selected nodes' ids.\n   *\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected?: string[] | string;\n  /**\n   * Can non-leaf nodes be collapsed / expanded.\n   */\n  collapsible?: boolean;\n  /**\n   * Callback fired when a tree item is selected.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {string} nodeId The id of the selected node.\n   */\n  onChange?: any;\n  /**\n   * Expanded nodes' ids.\n   */\n  expanded?: string[];\n  /**\n   * When uncontrolled, defines the initial expanded nodes' ids.\n   * @default []\n   */\n  defaultExpanded?: string[];\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes (old and new).\n   */\n  onToggle?: (event, nodeIds) => void;\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable?: boolean;\n  /**\n   * @ignore\n   */\n  onFocus?: (event: React.FocusEvent<any>) => void;\n  /**\n   * @ignore\n   */\n  onBlur?: (event: any) => void;\n  /**\n   * @ignore\n   */\n  onKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * The content of the component.\n   */\n  children?: React.ReactNode;\n}\n\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nexport const HvVerticalNavigationTreeView = forwardRef(\n  (props: HvVerticalNavigationTreeViewProps, ref) => {\n    const {\n      id: idProp,\n      className,\n      classes: classesProp,\n\n      mode = \"treeview\",\n\n      collapsible = false,\n      expanded: expandedProp,\n      defaultExpanded = [],\n      onToggle,\n\n      selectable = false,\n      multiSelect: multiSelectProp = false,\n      selected: selectedProp,\n      defaultSelected = [],\n      onChange,\n\n      disabledItemsFocusable = false,\n\n      onFocus,\n      onBlur,\n      onKeyDown,\n\n      children,\n\n      ...others\n    } = props;\n\n    const { classes, cx } = useClasses(classesProp);\n\n    const treeviewMode = mode === \"treeview\";\n    const multiSelect = selectable && multiSelectProp;\n\n    const treeId = useUniqueId(idProp, \"hvtreeview\");\n    const treeRef = useRef<HTMLDivElement>(null);\n    const handleRef = useForkRef(treeRef, ref);\n\n    const [expanded, setExpandedState] = useControlled(\n      expandedProp,\n      defaultExpanded\n    );\n\n    const [selected, setSelectedState] = useControlled(\n      selectedProp,\n      defaultSelected\n    );\n\n    const [focusedNodeId, setFocusedNodeId] = useState<string | null>(null);\n\n    const nodeMap = useRef({});\n\n    const firstCharMap = useRef({});\n\n    /*\n     * Status Helpers\n     */\n    const isExpanded = useCallback(\n      (id) =>\n        !collapsible ||\n        (Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false),\n      [collapsible, expanded]\n    );\n\n    const isExpandable = useCallback(\n      (id) =>\n        collapsible && nodeMap.current[id] && nodeMap.current[id].expandable,\n      [collapsible]\n    );\n\n    const isSelected = useCallback(\n      (id) =>\n        selectable &&\n        (Array.isArray(selected)\n          ? selected.indexOf(id) !== -1\n          : selected === id),\n      [selectable, selected]\n    );\n\n    const isSelectable = useCallback(\n      (id) =>\n        selectable && nodeMap.current[id] && nodeMap.current[id].selectable,\n      [selectable]\n    );\n\n    const isDisabled = useCallback((id) => {\n      let node = nodeMap.current[id];\n\n      // This can be called before the node has been added to the node map.\n      if (!node) {\n        return false;\n      }\n\n      if (node.disabled) {\n        return true;\n      }\n\n      while (node.parentId != null) {\n        node = nodeMap.current[node.parentId];\n        if (node.disabled) {\n          return true;\n        }\n      }\n\n      return false;\n    }, []);\n\n    const isFocused = useCallback(\n      (id) => focusedNodeId === id,\n      [focusedNodeId]\n    );\n\n    const isChildSelected = useCallback(\n      // the second part of the condition is to ensure that the id we're\n      // looking at is actually of a child (ie, there's at least one \"-\")\n      (id) => selected.startsWith(id) && selected.includes(\"-\"),\n      [selected]\n    );\n\n    /*\n     * Child Helpers\n     */\n    const getChildrenIds = (id: string | null) =>\n      Object.keys(nodeMap.current)\n        .map((key) => {\n          return nodeMap.current[key];\n        })\n        .filter((node) => node.parentId === id)\n        .sort((a, b) => a.index - b.index)\n        .map((child) => child.id);\n\n    const getNavigableChildrenIds = useCallback(\n      (id: string | null) => {\n        let childrenIds = getChildrenIds(id);\n\n        if (!disabledItemsFocusable) {\n          childrenIds = childrenIds.filter((node) => !isDisabled(node));\n        }\n        return childrenIds;\n      },\n      [disabledItemsFocusable, isDisabled]\n    );\n\n    /*\n     * Node Helpers\n     */\n    const getNextNode = useCallback(\n      (id: string) => {\n        // If expanded get first child\n        if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n          return getNavigableChildrenIds(id)[0];\n        }\n\n        let node = nodeMap.current[id];\n        while (node != null) {\n          // Try to get next sibling\n          const siblings = getNavigableChildrenIds(node.parentId);\n          const nextSibling = siblings[siblings.indexOf(node.id) + 1];\n\n          if (nextSibling) {\n            return nextSibling;\n          }\n\n          // If the sibling does not exist, go up a level to the parent and try again.\n          node = nodeMap.current[node.parentId];\n        }\n\n        return null;\n      },\n      [getNavigableChildrenIds, isExpanded]\n    );\n\n    const getPreviousNode = (id: string) => {\n      const node = nodeMap.current[id];\n      const siblings = getNavigableChildrenIds(node.parentId);\n      const nodeIndex = siblings.indexOf(id);\n\n      if (nodeIndex === 0) {\n        return node.parentId;\n      }\n\n      let currentNode = siblings[nodeIndex - 1];\n      while (\n        isExpanded(currentNode) &&\n        getNavigableChildrenIds(currentNode).length > 0\n      ) {\n        currentNode = getNavigableChildrenIds(currentNode).pop();\n      }\n\n      return currentNode;\n    };\n\n    const getLastNode = () => {\n      let lastNode = getNavigableChildrenIds(null).pop();\n\n      while (isExpanded(lastNode)) {\n        lastNode = getNavigableChildrenIds(lastNode).pop();\n      }\n      return lastNode;\n    };\n    const getFirstNode = () => getNavigableChildrenIds(null)[0];\n    const getParent = (id) => nodeMap.current[id].parentId;\n\n    /**\n     * This is used to determine the start and end of a selection range so\n     * we can get the nodes between the two border nodes.\n     *\n     * It finds the nodes' common ancestor using\n     * a naive implementation of a lowest common ancestor algorithm\n     * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n     * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n     * so we can compare their indexes to work out which node comes first in a depth first search.\n     * (https://en.wikipedia.org/wiki/Depth-first_search)\n     *\n     * Another way to put it is which node is shallower in a trÃ©maux tree\n     * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n     */\n    const findOrderInTremauxTree = useCallback(\n      (nodeAId: string, nodeBId: string) => {\n        if (nodeAId === nodeBId) {\n          return [nodeAId, nodeBId];\n        }\n\n        const nodeA = nodeMap.current[nodeAId];\n        const nodeB = nodeMap.current[nodeBId];\n\n        if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n          return nodeB.parentId === nodeA.id\n            ? [nodeA.id, nodeB.id]\n            : [nodeB.id, nodeA.id];\n        }\n\n        const aFamily = [nodeA.id];\n        const bFamily = [nodeB.id];\n\n        let aAncestor = nodeA.parentId;\n        let bAncestor = nodeB.parentId;\n\n        let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n\n        let continueA = true;\n        let continueB = true;\n\n        while (!bAncestorIsCommon && !aAncestorIsCommon) {\n          if (continueA) {\n            aFamily.push(aAncestor);\n            aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n            continueA = aAncestor !== null;\n            if (!aAncestorIsCommon && continueA) {\n              aAncestor = nodeMap.current[aAncestor].parentId;\n            }\n          }\n\n          if (continueB && !aAncestorIsCommon) {\n            bFamily.push(bAncestor);\n            bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n            continueB = bAncestor !== null;\n            if (!bAncestorIsCommon && continueB) {\n              bAncestor = nodeMap.current[bAncestor].parentId;\n            }\n          }\n        }\n\n        const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n        const ancestorFamily = getChildrenIds(commonAncestor);\n\n        const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n        const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n\n        return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide)\n          ? [nodeAId, nodeBId]\n          : [nodeBId, nodeAId];\n      },\n      []\n    );\n\n    const getNodesInRange = useCallback(\n      (nodeA, nodeB) => {\n        if (nodeA && nodeB) {\n          const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n          const nodes = [first];\n\n          let current = first;\n\n          while (current !== last) {\n            current = getNextNode(current);\n            nodes.push(current);\n          }\n\n          return nodes;\n        }\n        return [];\n      },\n      [findOrderInTremauxTree, getNextNode]\n    );\n\n    /*\n     * Focus Helpers\n     */\n    const focus = (event, id) => {\n      if (id) {\n        setFocusedNodeId(id);\n\n        if (nodeMap.current[id]?.onFocus) {\n          nodeMap.current[id].onFocus(event);\n        }\n      }\n    };\n\n    const focusNextNode = (event, id) => focus(event, getNextNode(id));\n    const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n    const focusFirstNode = (event) => focus(event, getFirstNode());\n    const focusLastNode = (event) => focus(event, getLastNode());\n\n    const focusByFirstCharacter = (event, id, char) => {\n      let start;\n      let index;\n      const lowercaseChar = char.toLowerCase();\n\n      const firstCharIds: string[] = [];\n      const firstChars: string[] = [];\n      // This really only works since the ids are strings\n      Object.keys(firstCharMap.current).forEach((nodeId) => {\n        const firstChar = firstCharMap.current[nodeId];\n        const map = nodeMap.current[nodeId];\n        const visible = map.parentId ? isExpanded(map.parentId) : true;\n        const shouldBeSkipped = disabledItemsFocusable\n          ? false\n          : isDisabled(nodeId);\n\n        if (visible && !shouldBeSkipped) {\n          firstCharIds.push(nodeId);\n          firstChars.push(firstChar);\n        }\n      });\n\n      // Get start index for search based on position of currentItem\n      start = firstCharIds.indexOf(id) + 1;\n      if (start >= firstCharIds.length) {\n        start = 0;\n      }\n\n      // Check remaining slots in the menu\n      index = findNextFirstChar(firstChars, start, lowercaseChar);\n\n      // If not found in remaining slots, check from beginning\n      if (index === -1) {\n        index = findNextFirstChar(firstChars, 0, lowercaseChar);\n      }\n\n      // If match was found...\n      if (index > -1) {\n        focus(event, firstCharIds[index]);\n      }\n    };\n\n    /*\n     * Expansion Helpers\n     */\n    const toggleExpansion = useCallback(\n      (event, value = focusedNodeId) => {\n        let newExpanded;\n\n        if (expanded.indexOf(value) !== -1) {\n          newExpanded = expanded.filter((id) => id !== value);\n        } else {\n          newExpanded = [value].concat(expanded);\n        }\n\n        if (onToggle) {\n          onToggle(event, newExpanded);\n        }\n\n        setExpandedState(newExpanded);\n      },\n      [expanded, focusedNodeId, onToggle, setExpandedState]\n    );\n\n    const expandAllSiblings = (event, id) => {\n      const map = nodeMap.current[id];\n      const siblings = getChildrenIds(map.parentId);\n\n      const diff = siblings.filter(\n        (child) => isExpandable(child) && !isExpanded(child)\n      );\n\n      const newExpanded = expanded.concat(diff);\n\n      if (diff.length > 0) {\n        setExpandedState(newExpanded);\n\n        if (onToggle) {\n          onToggle(event, newExpanded);\n        }\n      }\n    };\n\n    /*\n     * Selection Helpers\n     */\n    const lastSelectedNode = useRef<HTMLDivElement | null>(null);\n    const lastSelectionWasRange = useRef(false);\n    const currentRangeSelection = useRef<HTMLDivElement[]>([]);\n\n    const isDivElement = (element): element is HTMLDivElement => {\n      return (element as HTMLDivElement).nodeType === 1;\n    };\n\n    const handleRangeArrowSelect = useCallback(\n      (event, nodes: { start?; next?; current? }) => {\n        let base = selected.slice();\n        const { start, next, current } = nodes;\n\n        if (!next || !current) {\n          return;\n        }\n\n        if (\n          isDivElement(current) &&\n          currentRangeSelection.current.indexOf(current) === -1\n        ) {\n          currentRangeSelection.current = [];\n        }\n\n        if (lastSelectionWasRange.current) {\n          if (\n            isDivElement(next) &&\n            currentRangeSelection.current.indexOf(next) !== -1\n          ) {\n            base = base.filter((id) => id === start || id !== current);\n            currentRangeSelection.current =\n              currentRangeSelection.current.filter(\n                (id) => id === start || id !== current\n              );\n          } else {\n            base.push(next);\n            currentRangeSelection.current.push(next);\n          }\n        } else {\n          base.push(next);\n          currentRangeSelection.current.push(current, next);\n        }\n\n        if (onChange) {\n          onChange(\n            event,\n            base,\n            base.map((id) => nodeMap.current[id]?.payload)\n          );\n        }\n\n        setSelectedState(base);\n      },\n      [onChange, selected, setSelectedState]\n    );\n\n    const handleRangeSelect = useCallback(\n      (event, nodes: { start?; end?; current? }) => {\n        let base = selected.slice();\n        const { start, end } = nodes;\n        // If last selection was a range selection ignore nodes that were selected.\n        if (lastSelectionWasRange.current) {\n          base = base.filter(\n            (id) => currentRangeSelection.current.indexOf(id) === -1\n          );\n        }\n\n        let range = getNodesInRange(start, end);\n        range = range.filter((node) => !isDisabled(node));\n        currentRangeSelection.current = range;\n        let newSelected = base.concat(range);\n        newSelected = newSelected.filter(\n          (id, i) => newSelected.indexOf(id) === i\n        );\n\n        if (onChange) {\n          onChange(\n            event,\n            newSelected,\n            newSelected.map((id) => nodeMap.current[id]?.payload)\n          );\n        }\n\n        setSelectedState(newSelected);\n      },\n      [getNodesInRange, isDisabled, onChange, selected, setSelectedState]\n    );\n\n    const handleMultipleSelect = useCallback(\n      (event, value) => {\n        let newSelected;\n        if (selected.indexOf(value) !== -1) {\n          newSelected = selected.filter((id) => id !== value);\n        } else {\n          newSelected = [value].concat(selected);\n        }\n\n        if (onChange) {\n          onChange(\n            event,\n            newSelected,\n            newSelected.map((id) => nodeMap.current[id]?.payload)\n          );\n        }\n\n        setSelectedState(newSelected);\n      },\n      [onChange, selected, setSelectedState]\n    );\n\n    const handleSingleSelect = useCallback(\n      (event, value) => {\n        const newSelected = multiSelect ? [value] : value;\n        if (onChange) {\n          const nodeValue = nodeMap.current[newSelected]?.payload;\n          onChange(event, newSelected, multiSelect ? [nodeValue] : nodeValue);\n        }\n\n        setSelectedState(newSelected);\n      },\n      [multiSelect, onChange, setSelectedState]\n    );\n\n    const selectNode = useCallback(\n      (event, id, multiple = false) => {\n        if (id && isSelectable(id)) {\n          if (multiple) {\n            handleMultipleSelect(event, id);\n          } else {\n            handleSingleSelect(event, id);\n          }\n          lastSelectedNode.current = id;\n          lastSelectionWasRange.current = false;\n          currentRangeSelection.current = [];\n\n          return true;\n        }\n        return false;\n      },\n      [handleMultipleSelect, handleSingleSelect, isSelectable]\n    );\n\n    const selectRange = useCallback(\n      (\n        event,\n        nodes: { start?; end?; current?: HTMLDivElement | null },\n        stacked = false\n      ) => {\n        const { start = lastSelectedNode.current, end, current } = nodes;\n        if (stacked) {\n          handleRangeArrowSelect(event, { start, next: end, current });\n        } else if (start != null && end != null) {\n          handleRangeSelect(event, { start, end });\n        }\n        lastSelectionWasRange.current = true;\n      },\n      [handleRangeArrowSelect, handleRangeSelect]\n    );\n\n    const rangeSelectToFirst = (event, id) => {\n      if (!lastSelectedNode.current) {\n        lastSelectedNode.current = id;\n      }\n\n      const start = lastSelectionWasRange.current\n        ? lastSelectedNode.current\n        : id;\n\n      selectRange(event, {\n        start,\n        end: getFirstNode(),\n      });\n    };\n\n    const rangeSelectToLast = (event: any, id) => {\n      if (!lastSelectedNode.current) {\n        lastSelectedNode.current = id;\n      }\n\n      const start = lastSelectionWasRange.current\n        ? lastSelectedNode.current\n        : id;\n\n      selectRange(event, {\n        start,\n        end: getLastNode(),\n      });\n    };\n\n    const selectNextNode = (event, id) => {\n      if (!isDisabled(getNextNode(id))) {\n        selectRange(\n          event,\n          {\n            end: getNextNode(id),\n            current: id,\n          },\n          true\n        );\n      }\n    };\n\n    const selectPreviousNode = (event, id) => {\n      if (!isDisabled(getPreviousNode(id))) {\n        selectRange(\n          event,\n          {\n            end: getPreviousNode(id),\n            current: id,\n          },\n          true\n        );\n      }\n    };\n\n    const selectAllNodes = (event) => {\n      selectRange(event, { start: getFirstNode(), end: getLastNode() });\n    };\n\n    /*\n     * Mapping Helpers\n     */\n    const registerNode = useCallback((node) => {\n      const {\n        id,\n        index,\n        parentId,\n        expandable,\n        idAttribute,\n        disabled,\n        selectable: nodeSelectable,\n        onFocus: nodeOnFocus,\n        payload,\n      } = node;\n\n      nodeMap.current[id] = {\n        id,\n        index,\n        parentId,\n        expandable,\n        idAttribute,\n        disabled,\n        selectable: nodeSelectable,\n        onFocus: nodeOnFocus,\n        payload,\n      };\n    }, []);\n\n    const unregisterNode = useCallback((id) => {\n      const newMap = { ...nodeMap.current };\n      delete newMap[id];\n      nodeMap.current = newMap;\n\n      setFocusedNodeId((oldFocusedNodeId) => {\n        if (\n          oldFocusedNodeId === id &&\n          treeRef.current &&\n          treeRef.current ===\n            (treeRef.current.ownerDocument || document).activeElement\n        ) {\n          return getChildrenIds(null)[0];\n        }\n        return oldFocusedNodeId;\n      });\n    }, []);\n\n    const mapFirstChar = useCallback((id, firstChar) => {\n      firstCharMap.current[id] = firstChar;\n    }, []);\n\n    const unMapFirstChar = useCallback((id) => {\n      const newMap = { ...firstCharMap.current };\n      delete newMap[id];\n      firstCharMap.current = newMap;\n    }, []);\n\n    /**\n     * Event handlers and Navigation\n     */\n    const handleNextArrow = (event) => {\n      if (isExpandable(focusedNodeId)) {\n        if (isExpanded(focusedNodeId)) {\n          focusNextNode(event, focusedNodeId);\n        } else if (!isDisabled(focusedNodeId)) {\n          toggleExpansion(event);\n        }\n      }\n      return true;\n    };\n\n    const handlePreviousArrow = (event) => {\n      if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n        toggleExpansion(event, focusedNodeId);\n        return true;\n      }\n\n      const parent = getParent(focusedNodeId);\n      if (parent) {\n        focus(event, parent);\n        return true;\n      }\n      return false;\n    };\n\n    const handleKeyDown = (event) => {\n      let flag = false;\n      const { key } = event;\n\n      // If the tree is empty there will be no focused node\n      if (\n        event.altKey ||\n        event.currentTarget !== event.target ||\n        !focusedNodeId\n      ) {\n        return;\n      }\n\n      const ctrlPressed = event.ctrlKey || event.metaKey;\n      switch (key) {\n        case \" \":\n          if (isSelectable(focusedNodeId) && !isDisabled(focusedNodeId)) {\n            if (multiSelect && event.shiftKey) {\n              selectRange(event, { end: focusedNodeId });\n              flag = true;\n            } else if (multiSelect) {\n              flag = selectNode(event, focusedNodeId, true);\n            } else {\n              flag = selectNode(event, focusedNodeId);\n            }\n          }\n          event.stopPropagation();\n          break;\n        case \"Enter\":\n          if (!isDisabled(focusedNodeId)) {\n            if (isExpandable(focusedNodeId)) {\n              toggleExpansion(event);\n              flag = true;\n            } else if (isSelectable(focusedNodeId)) {\n              if (multiSelect && event.shiftKey) {\n                selectRange(event, { end: focusedNodeId });\n                flag = true;\n              } else if (multiSelect) {\n                flag = selectNode(event, focusedNodeId, true);\n              } else {\n                flag = selectNode(event, focusedNodeId);\n              }\n            }\n          }\n          event.stopPropagation();\n          break;\n        case \"ArrowDown\":\n          if (multiSelect && event.shiftKey) {\n            selectNextNode(event, focusedNodeId);\n          }\n          focusNextNode(event, focusedNodeId);\n          flag = true;\n          break;\n        case \"ArrowUp\":\n          if (multiSelect && event.shiftKey) {\n            selectPreviousNode(event, focusedNodeId);\n          }\n          focusPreviousNode(event, focusedNodeId);\n          flag = true;\n          break;\n        case \"ArrowRight\":\n          flag = handleNextArrow(event);\n          break;\n        case \"ArrowLeft\":\n          flag = handlePreviousArrow(event);\n          break;\n        case \"Home\":\n          if (\n            multiSelect &&\n            ctrlPressed &&\n            event.shiftKey &&\n            !isDisabled(focusedNodeId)\n          ) {\n            rangeSelectToFirst(event, focusedNodeId);\n          }\n          focusFirstNode(event);\n          flag = true;\n          break;\n        case \"End\":\n          if (\n            multiSelect &&\n            ctrlPressed &&\n            event.shiftKey &&\n            !isDisabled(focusedNodeId)\n          ) {\n            rangeSelectToLast(event, focusedNodeId);\n          }\n          focusLastNode(event);\n          flag = true;\n          break;\n        default:\n          if (key === \"*\") {\n            expandAllSiblings(event, focusedNodeId);\n            flag = true;\n          } else if (multiSelect && ctrlPressed && key.toLowerCase() === \"a\") {\n            selectAllNodes(event);\n            flag = true;\n          } else if (\n            !ctrlPressed &&\n            !event.shiftKey &&\n            isPrintableCharacter(key)\n          ) {\n            focusByFirstCharacter(event, focusedNodeId, key);\n            flag = true;\n          }\n      }\n\n      if (flag) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n    };\n\n    const handleFocus = (event) => {\n      // if the event bubbled (which is React specific) we don't want to steal focus\n      if (event.target === event.currentTarget) {\n        const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n        focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n      }\n\n      if (onFocus) {\n        onFocus(event);\n      }\n    };\n\n    const handleBlur = (event) => {\n      setFocusedNodeId(null);\n\n      if (onBlur) {\n        onBlur(event);\n      }\n    };\n\n    const activeDescendant =\n      focusedNodeId && nodeMap.current[focusedNodeId]\n        ? nodeMap.current[focusedNodeId].idAttribute\n        : null;\n\n    const treeControlContext = useMemo(\n      () => ({\n        treeId,\n        mode,\n        collapsible,\n        toggleExpansion,\n        multiSelect,\n        selectNode: selectable ? selectNode : noopSelection,\n        selectRange: selectable ? selectRange : noopSelection,\n        disabledItemsFocusable,\n        registerNode,\n        unregisterNode,\n        mapFirstChar,\n        unMapFirstChar,\n        focus,\n      }),\n      [\n        registerNode,\n        unregisterNode,\n        mapFirstChar,\n        unMapFirstChar,\n        toggleExpansion,\n        selectable,\n        selectNode,\n        selectRange,\n        mode,\n        collapsible,\n        multiSelect,\n        disabledItemsFocusable,\n        treeId,\n      ]\n    );\n\n    const treeStateContext = useMemo(\n      () => ({\n        isExpanded,\n        isSelected,\n        isFocused,\n        isDisabled,\n        isChildSelected,\n      }),\n      [isDisabled, isExpanded, isFocused, isSelected, isChildSelected]\n    );\n\n    return (\n      <TreeViewControlContext.Provider value={treeControlContext}>\n        <TreeViewStateContext.Provider value={treeStateContext}>\n          <DescendantProvider>\n            <ul\n              ref={handleRef}\n              id={idProp}\n              className={cx(classes.root, className)}\n              {...(treeviewMode && {\n                id: treeId,\n                role: \"tree\",\n                \"aria-multiselectable\": multiSelect,\n                \"aria-activedescendant\": activeDescendant,\n                tabIndex: 0,\n                onFocus: handleFocus,\n                onBlur: handleBlur,\n                onKeyDown: handleKeyDown,\n              })}\n              {...others}\n            >\n              {children}\n            </ul>\n          </DescendantProvider>\n        </TreeViewStateContext.Provider>\n      </TreeViewControlContext.Provider>\n    );\n  }\n);\n"],"names":["isPrintableCharacter","string","length","match","findNextFirstChar","firstChars","startIndex","char","i","noopSelection","HvVerticalNavigationTreeView","forwardRef","props","ref","id","idProp","className","classes","classesProp","mode","collapsible","expanded","expandedProp","defaultExpanded","onToggle","selectable","multiSelect","multiSelectProp","selected","selectedProp","defaultSelected","onChange","disabledItemsFocusable","onFocus","onBlur","onKeyDown","children","others","cx","useClasses","treeviewMode","treeId","useUniqueId","treeRef","useRef","handleRef","useForkRef","setExpandedState","useControlled","setSelectedState","focusedNodeId","setFocusedNodeId","useState","nodeMap","firstCharMap","isExpanded","useCallback","Array","isArray","indexOf","isExpandable","current","expandable","isSelected","isSelectable","isDisabled","node","disabled","parentId","isFocused","isChildSelected","startsWith","includes","getChildrenIds","Object","keys","map","key","filter","sort","a","b","index","child","getNavigableChildrenIds","childrenIds","getNextNode","siblings","nextSibling","getPreviousNode","nodeIndex","currentNode","pop","getLastNode","lastNode","getFirstNode","getParent","findOrderInTremauxTree","nodeAId","nodeBId","nodeA","nodeB","aFamily","bFamily","aAncestor","bAncestor","aAncestorIsCommon","bAncestorIsCommon","continueA","continueB","push","commonAncestor","ancestorFamily","aSide","bSide","getNodesInRange","first","last","nodes","focus","event","focusNextNode","focusPreviousNode","focusFirstNode","focusLastNode","focusByFirstCharacter","start","lowercaseChar","toLowerCase","firstCharIds","forEach","nodeId","firstChar","visible","shouldBeSkipped","toggleExpansion","value","newExpanded","concat","expandAllSiblings","diff","lastSelectedNode","lastSelectionWasRange","currentRangeSelection","isDivElement","element","nodeType","handleRangeArrowSelect","base","slice","next","payload","handleRangeSelect","end","range","newSelected","handleMultipleSelect","handleSingleSelect","nodeValue","selectNode","multiple","selectRange","stacked","rangeSelectToFirst","rangeSelectToLast","selectNextNode","selectPreviousNode","selectAllNodes","registerNode","idAttribute","nodeSelectable","nodeOnFocus","unregisterNode","newMap","oldFocusedNodeId","ownerDocument","document","activeElement","mapFirstChar","unMapFirstChar","handleNextArrow","handlePreviousArrow","parent","handleKeyDown","flag","altKey","currentTarget","target","ctrlPressed","ctrlKey","metaKey","shiftKey","stopPropagation","preventDefault","handleFocus","firstSelected","handleBlur","activeDescendant","treeControlContext","useMemo","treeStateContext","jsx","TreeViewControlContext","TreeViewStateContext","DescendantProvider","root","role","tabIndex"],"mappings":"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"}
{"version":3,"file":"descendants.cjs","sources":["../../../../../src/components/VerticalNavigation/TreeView/descendants.tsx"],"sourcesContent":["/**\n * Copied from https://github.com/mui-org/material-ui/blob/8763de1633d80295e7b83d8c21040dad333e6699/packages/material-ui-lab/src/TreeView/descendants.js\n * Credit: https://github.com/reach/reach-ui/blob/86a046f54d53b6420e392b3fa56dd991d9d4e458/packages/descendants/README.md\n *\n * - Added level (depth) property.\n * - Use local copy of useEnhancedEffect.\n */\n\nimport { useEnhancedEffect } from \"@core/hooks\";\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\ntype Item = {\n  element?;\n  index?;\n  [key: string]: unknown;\n};\n\nfunction binaryFindElement(array, element) {\n  let start = 0;\n  let end = array.length - 1;\n\n  while (start <= end) {\n    const middle = Math.floor((start + end) / 2);\n\n    if (array[middle].element === element) {\n      return middle;\n    }\n\n    if (\n      array[middle].element.compareDocumentPosition(element) &&\n      Node.DOCUMENT_POSITION_PRECEDING\n    ) {\n      end = middle - 1;\n    } else {\n      start = middle + 1;\n    }\n  }\n\n  return start;\n}\n\nconst DescendantContext = createContext<DescendantContextValue>({\n  level: 0,\n  descendants: [],\n});\n\ninterface DescendantContextValue {\n  level?: number;\n  registerDescendant?;\n  unregisterDescendant?;\n  descendants: Item[];\n  parentId?;\n}\n\nif (process.env.NODE_ENV !== \"production\") {\n  DescendantContext.displayName = \"DescendantContext\";\n}\n\nfunction usePrevious(value) {\n  const ref = useRef(null);\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  return ref.current;\n}\n\nconst noop = () => {};\n\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation.\n */\nexport function useDescendant(descendant) {\n  const [, forceUpdate] = useState<{} | null>();\n  const {\n    registerDescendant = noop,\n    unregisterDescendant = noop,\n    descendants = [],\n    parentId = null,\n    level = 0,\n  } = useContext(DescendantContext);\n\n  // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n  const index = descendants.findIndex(\n    (item) => item.element === descendant.element\n  );\n\n  const previousDescendants: Item[] | null = usePrevious(descendants);\n\n  // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n  const someDescendantsHaveChanged = descendants.some(\n    (newDescendant, position) => {\n      return (\n        previousDescendants && previousDescendants[position]\n        // previousDescendants[position].element !== newDescendant.element\n        // was not able to type check this, did not any difference\n      );\n    }\n  );\n\n  // Prevent any flashing\n  useEnhancedEffect(() => {\n    if (descendant.element) {\n      registerDescendant({\n        ...descendant,\n        index,\n      });\n      return () => {\n        unregisterDescendant(descendant.element);\n      };\n    }\n    forceUpdate({});\n\n    return undefined;\n  }, [\n    registerDescendant,\n    unregisterDescendant,\n    index,\n    someDescendantsHaveChanged,\n    descendant,\n  ]);\n\n  return { parentId, index, level };\n}\n\nexport const DescendantProvider = (props: DescendantProviderProps) => {\n  const { children, id, level } = props;\n\n  const [items, set] = useState<Item[]>([]);\n\n  const registerDescendant = useCallback(({ element, ...other }) => {\n    set((oldItems) => {\n      let newItems;\n      if (oldItems.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        return [\n          {\n            ...other,\n            element,\n            index: 0,\n          },\n        ];\n      }\n\n      const index = binaryFindElement(oldItems, element);\n\n      if (oldItems[index] && oldItems[index].element === element) {\n        // If the element is already registered, just use the same array\n        newItems = oldItems;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n\n        const newItem = {\n          ...other,\n          element,\n          index,\n        };\n\n        // If an index is not found we will push the element to the end.\n        newItems = oldItems.slice();\n        newItems.splice(index, 0, newItem);\n      }\n      newItems.forEach((item, position) => {\n        item.index = position;\n      });\n      return newItems;\n    });\n  }, []);\n\n  const unregisterDescendant = useCallback((element: Item) => {\n    set((oldItems) =>\n      oldItems.filter((item: Item) => element !== item.element)\n    );\n  }, []);\n\n  const value = useMemo(\n    () => ({\n      descendants: items,\n      registerDescendant,\n      unregisterDescendant,\n      parentId: id,\n      level,\n    }),\n    [items, registerDescendant, unregisterDescendant, id, level]\n  );\n\n  return (\n    <DescendantContext.Provider value={value}>\n      {children}\n    </DescendantContext.Provider>\n  );\n};\n\nexport type DescendantProviderProps = {\n  children?: React.ReactNode;\n  id?: string;\n  level?: number;\n};\n"],"names":["binaryFindElement","array","element","start","end","length","middle","Math","floor","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","DescendantContext","createContext","level","descendants","process","env","NODE_ENV","displayName","usePrevious","value","ref","useRef","useEffect","current","noop","useDescendant","descendant","forceUpdate","useState","registerDescendant","unregisterDescendant","parentId","useContext","index","findIndex","item","previousDescendants","someDescendantsHaveChanged","some","newDescendant","position","useEnhancedEffect","undefined","DescendantProvider","props","children","id","items","set","useCallback","other","oldItems","newItems","newItem","slice","splice","forEach","filter","useMemo","jsx"],"mappings":"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"}
"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const setId = require("../../utils/setId.cjs");
const multiSelectionEventHandler = require("../../utils/multiSelectionEventHandler.cjs");
const CheckBoxGroup_styles = require("./CheckBoxGroup.styles.cjs");
const CheckBox = require("../CheckBox/CheckBox.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const computeSelectAllState = (selected, total) => {
  if (selected === 0) {
    return "none";
  }
  if (selected === total) {
    return "all";
  }
  return "some";
};
const getValueFromSelectedChildren = (children) => {
  const selectedValues = React.Children.toArray(children).map((child) => {
    var _a, _b, _c, _d;
    const childIsControlled = ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.checked) !== void 0;
    const childIsSelected = childIsControlled ? (_b = child == null ? void 0 : child.props) == null ? void 0 : _b.checked : (_c = child == null ? void 0 : child.props) == null ? void 0 : _c.defaultChecked;
    return childIsSelected ? (_d = child == null ? void 0 : child.props) == null ? void 0 : _d.value : void 0;
  }).filter((v) => v !== void 0);
  return selectedValues;
};
const HvCheckBoxGroup = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    children,
    name,
    label,
    description,
    status,
    statusMessage,
    defaultValue,
    value: valueProp,
    required = false,
    readOnly = false,
    disabled = false,
    showSelectAll = false,
    orientation = "vertical",
    selectAllLabel = "All",
    selectAllConjunctionLabel = "/",
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy,
    "aria-errormessage": ariaErrorMessage,
    onChange,
    ...others
  } = useDefaultProps.useDefaultProps("HvCheckBoxGroup", props);
  const {
    classes,
    cx
  } = CheckBoxGroup_styles.useClasses(classesProp);
  const [value, setValue] = useControlled.useControlled(valueProp, defaultValue !== void 0 ? defaultValue : (
    // When uncontrolled and no default value is given,
    // extract the initial selected values from the children own state
    () => getValueFromSelectedChildren(children)
  ));
  const [validationState, setValidationState] = useControlled.useControlled(status, "standBy");
  const [validationMessage] = useControlled.useControlled(statusMessage, "Required");
  const elementId = useUniqueId.useUniqueId(id, "hvcheckboxgroup");
  const selectionAnchor = React.useRef(void 0);
  const [allValues, selectedState, selectedCount] = React.useMemo(() => {
    const childValues = [];
    const childSelectedState = [];
    let childSelectedCounter = 0;
    React.Children.toArray(children).forEach((child, i) => {
      var _a;
      const childValue = (_a = child == null ? void 0 : child.props) == null ? void 0 : _a.value;
      const childIsSelected = value.indexOf(childValue) !== -1;
      childValues[i] = childValue;
      childSelectedState[i] = childIsSelected;
      if (childIsSelected) {
        childSelectedCounter += 1;
      }
    });
    return [childValues, childSelectedState, childSelectedCounter];
  }, [children, value]);
  const selectAllState = computeSelectAllState(value.length, selectedState.length);
  const onChildChangeInterceptor = React.useCallback((index, childOnChange, event, isChecked) => {
    const newValue = multiSelectionEventHandler.multiSelectionEventHandler(event, index, selectionAnchor, allValues, selectedState, isChecked);
    childOnChange == null ? void 0 : childOnChange(event, isChecked);
    onChange == null ? void 0 : onChange(event, newValue);
    setValue(() => {
      if (required && newValue.length === 0) {
        setValidationState("invalid");
      } else {
        setValidationState("valid");
      }
      return newValue;
    });
  }, [allValues, onChange, required, selectedState, setValidationState, setValue]);
  const modifiedChildren = React.useMemo(() => {
    return React.Children.map(children, (child, i) => {
      var _a, _b, _c;
      const childIsSelected = selectedState[i];
      return React.cloneElement(child, {
        checked: childIsSelected,
        name: ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.name) || name,
        onChange: (event, isChecked) => {
          var _a2;
          return onChildChangeInterceptor(i, (_a2 = child == null ? void 0 : child.props) == null ? void 0 : _a2.onChange, event, isChecked);
        },
        disabled: disabled || ((_b = child == null ? void 0 : child.props) == null ? void 0 : _b.disabled),
        readOnly: readOnly || ((_c = child == null ? void 0 : child.props) == null ? void 0 : _c.readOnly)
      });
    });
  }, [children, disabled, name, onChildChangeInterceptor, readOnly, selectedState]);
  const handleSelectAll = (event, selectAllChecked) => {
    let newValue;
    if (selectAllChecked) {
      newValue = [...allValues];
    } else {
      newValue = [];
    }
    onChange == null ? void 0 : onChange(event, newValue);
    setValue(() => {
      if (required && newValue.length === 0) {
        setValidationState("invalid");
      } else {
        setValidationState("valid");
      }
      return newValue;
    });
  };
  const selectAllLabelComponent = selectedCount === 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("b", { children: selectAllLabel }),
    ` (${React.Children.toArray(children).length})`
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
    /* @__PURE__ */ jsxRuntime.jsx("b", { children: selectedCount }),
    ` ${selectAllConjunctionLabel} ${React.Children.toArray(children).length}`
  ] });
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const errorMessageId = canShowError ? setId.setId(elementId, "error") : ariaErrorMessage;
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { id, name, status: validationState, disabled, required, readOnly, className: cx(classes.root, className), children: [
    label && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { id: setId.setId(elementId, "label"), label, className: classes.label }),
    description && /* @__PURE__ */ jsxRuntime.jsx(InfoMessage.HvInfoMessage, { id: setId.setId(elementId, "description"), children: description }),
    /* @__PURE__ */ jsxRuntime.jsxs("div", { role: "group", "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy || label && setId.setId(elementId, "label") || void 0, "aria-disabled": disabled ? true : void 0, "aria-invalid": validationState === "invalid" ? true : void 0, "aria-errormessage": validationState === "invalid" ? errorMessageId : void 0, "aria-describedby": [description && setId.setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, className: cx(classes.group, {
      [classes.vertical]: orientation === "vertical",
      [classes.horizontal]: orientation === "horizontal",
      [classes.invalid]: validationState === "invalid"
    }), ...others, children: [
      showSelectAll && /* @__PURE__ */ jsxRuntime.jsx(CheckBox.HvCheckBox, { checked: selectAllState === "all", indeterminate: selectAllState === "some", label: selectAllLabelComponent, disabled, readOnly, className: classes.selectAll, onChange: handleSelectAll }),
      modifiedChildren
    ] }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
exports.checkBoxGroupClasses = CheckBoxGroup_styles.staticClasses;
exports.HvCheckBoxGroup = HvCheckBoxGroup;
//# sourceMappingURL=CheckBoxGroup.cjs.map

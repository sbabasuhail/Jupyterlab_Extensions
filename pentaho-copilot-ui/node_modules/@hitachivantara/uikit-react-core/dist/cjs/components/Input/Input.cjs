"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const material = require("@mui/material");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const browser = require("../../utils/browser.cjs");
const keyboardUtils = require("../../utils/keyboardUtils.cjs");
const setId = require("../../utils/setId.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const validations = require("../BaseInput/validations.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const useIsMounted = require("../../hooks/useIsMounted.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useLabels = require("../../hooks/useLabels.cjs");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const Input_styles = require("./Input.styles.cjs");
const Adornment = require("../Forms/Adornment/Adornment.cjs");
const BaseInput = require("../BaseInput/BaseInput.cjs");
const Suggestions = require("../Forms/Suggestions/Suggestions.cjs");
const Tooltip = require("../Tooltip/Tooltip.cjs");
const Typography = require("../Typography/Typography.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const React__default = /* @__PURE__ */ _interopDefault(React);
const DEFAULT_LABELS = {
  clearButtonLabel: "Clear the text",
  revealPasswordButtonLabel: "Reveal password",
  revealPasswordButtonClickToShowTooltip: "Click to show password.",
  revealPasswordButtonClickToHideTooltip: "Click to hide password.",
  searchButtonLabel: "Search"
};
const getFocusedElement = (event) => browser.isBrowser("ie") ? document.activeElement : event.relatedTarget;
function eventTargetIsInsideContainer(container, event) {
  return container != null && container.contains(getFocusedElement(event));
}
const changeInputValue = (input, value = "") => {
  var _a;
  const event = new Event("input", {
    bubbles: true
  });
  const setInputValue = (_a = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")) == null ? void 0 : _a.set;
  setInputValue == null ? void 0 : setInputValue.call(input, value);
  input == null ? void 0 : input.dispatchEvent(event);
};
const HvInput = React.forwardRef((props, ref) => {
  var _a;
  const {
    classes: classesProp,
    className,
    id,
    name,
    value: valueProp,
    defaultValue = "",
    required = false,
    readOnly = false,
    disabled = false,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    onEnter,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    type = "text",
    placeholder,
    autoFocus = false,
    labels: labelsProp,
    validationMessages,
    disableClear = false,
    disableRevealPassword = false,
    disableSearchButton = false,
    endAdornment,
    maxCharQuantity,
    minCharQuantity,
    validation,
    showValidationIcon = false,
    suggestionListCallback,
    inputRef: inputRefProp,
    onBlur,
    onFocus,
    onKeyDown,
    inputProps = {},
    ...others
  } = useDefaultProps.useDefaultProps("HvInput", props);
  const {
    classes,
    cx
  } = Input_styles.useClasses(classesProp);
  const labels = useLabels.useLabels(DEFAULT_LABELS, labelsProp);
  const elementId = useUniqueId.useUniqueId(id, "hvinput");
  const inputRef = React.useRef(null);
  const forkedRef = material.useForkRef(ref, inputRef, inputRefProp);
  const suggestionsRef = React.useRef(null);
  const [focused, setFocused] = React.useState(false);
  const isDirty = React.useRef(false);
  const [value, setValue] = useControlled.useControlled(valueProp, defaultValue);
  const isEmptyValue = value == null || value === "";
  const [validationState, setValidationState] = useControlled.useControlled(status, validationStates.default.standBy);
  const [validationMessage, setValidationMessage] = useControlled.useControlled(statusMessage, "");
  const errorMessages = React.useMemo(
    () => ({
      ...validations.DEFAULT_ERROR_MESSAGES,
      ...validationMessages
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [validationMessages == null ? void 0 : validationMessages.error, validationMessages == null ? void 0 : validationMessages.requiredError, validationMessages == null ? void 0 : validationMessages.minCharError, validationMessages == null ? void 0 : validationMessages.maxCharError, validationMessages == null ? void 0 : validationMessages.typeMismatchError]
  );
  const validationType = React.useMemo(() => validations.computeValidationType(type), [type]);
  const performValidation = React.useCallback(() => {
    const inputValidity = validations.validateInput(inputRef.current, value, required, minCharQuantity, maxCharQuantity, validationType, validation);
    setValidationState(validations.computeValidationState(inputValidity, isEmptyValue));
    setValidationMessage(validations.computeValidationMessage(inputValidity, errorMessages));
    return inputValidity;
  }, [errorMessages, isEmptyValue, maxCharQuantity, minCharQuantity, required, setValidationMessage, setValidationState, validation, validationType, value]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && validations.hasBuiltInValidations(required, validationType, minCharQuantity, maxCharQuantity, validation, inputProps));
  const isStateInvalid = validationStates.isInvalid(validationState);
  const [revealPassword, setRevealPassword] = React.useState(false);
  const realType = React.useMemo(() => {
    if (type === "password") {
      return revealPassword ? "text" : "password";
    }
    if (type === "search") {
      return "search";
    }
    return "text";
  }, [revealPassword, type]);
  const [suggestionValues, setSuggestionValues] = React.useState(null);
  const canShowSuggestions = suggestionListCallback != null;
  const hasSuggestions = !!suggestionValues;
  const hasLabel = label != null;
  const hasDescription = description != null;
  const focusInput = () => {
    var _a2;
    (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
  };
  const isMounted = useIsMounted.useIsMounted();
  const suggestionClearHandler = () => {
    if (isMounted.current) {
      setSuggestionValues(null);
    }
  };
  const suggestionHandler = (val) => {
    var _a2;
    const suggestionsArray = suggestionListCallback == null ? void 0 : suggestionListCallback(val);
    if ((_a2 = suggestionsArray == null ? void 0 : suggestionsArray[0]) == null ? void 0 : _a2.label) {
      setSuggestionValues(suggestionsArray);
    } else {
      suggestionClearHandler();
    }
  };
  const suggestionSelectedHandler = (event, item) => {
    const newValue = item.value || item.label;
    changeInputValue(inputRef.current, newValue);
    focusInput();
    suggestionClearHandler();
    if (type === "search") {
      onEnter == null ? void 0 : onEnter(event, newValue);
    }
  };
  const onChangeHandler = (event, newValue) => {
    isDirty.current = true;
    setValue(newValue);
    onChange == null ? void 0 : onChange(event, newValue);
    if (canShowSuggestions) {
      suggestionHandler(newValue);
    }
  };
  const onInputBlurHandler = (event) => {
    if (eventTargetIsInsideContainer(suggestionsRef.current, event))
      return;
    setFocused(false);
    const inputValidity = performValidation();
    onBlur == null ? void 0 : onBlur(event, value, inputValidity);
  };
  const onFocusHandler = (event) => {
    setFocused(true);
    setValidationState(validationStates.default.standBy);
    onFocus == null ? void 0 : onFocus(event, value);
  };
  const getSuggestions = (li) => {
    var _a2;
    const listEl = document.getElementById(setId.setId(elementId, "suggestions-list") || "");
    return li != null ? (_a2 = listEl == null ? void 0 : listEl.getElementsByTagName("li")) == null ? void 0 : _a2[li] : listEl;
  };
  const onSuggestionKeyDown = (event) => {
    if (keyboardUtils.isKey(event, "Esc")) {
      suggestionClearHandler();
      focusInput();
    } else if (keyboardUtils.isKey(event, "Tab")) {
      suggestionClearHandler();
    }
  };
  const onKeyDownHandler = (event) => {
    if (keyboardUtils.isKey(event, "ArrowDown") && hasSuggestions) {
      const li = getSuggestions(0);
      li == null ? void 0 : li.focus();
    } else if (keyboardUtils.isKey(event, "Enter")) {
      onEnter == null ? void 0 : onEnter(event, value);
    }
    onKeyDown == null ? void 0 : onKeyDown(event, value);
  };
  const onContainerBlurHandler = (event) => {
    if (event.relatedTarget) {
      setTimeout(() => {
        const list = getSuggestions(null);
        if (!(list == null ? void 0 : list.contains(document.activeElement)))
          suggestionClearHandler();
      }, 10);
    }
  };
  const hasOnEnter = onEnter != null;
  const showClear = !disabled && !readOnly && !disableClear && !isEmptyValue && (!hasOnEnter || type !== "search" || disableSearchButton || validationState !== validationStates.default.standBy);
  const showSearchIcon = type === "search" && !disableSearchButton;
  const showRevealPasswordButton = type === "password" && !disableRevealPassword;
  const handleClear = React.useCallback(() => {
    setValidationState(validationStates.default.standBy);
    changeInputValue(inputRef.current, "");
    setTimeout(focusInput);
  }, [setValidationState]);
  const clearButton = React.useMemo(() => {
    if (!showClear) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(
      Adornment.HvAdornment,
      {
        className: cx(classes.adornmentButton, {
          [classes.iconClear]: !showSearchIcon
        }),
        onClick: handleClear,
        "aria-label": labels == null ? void 0 : labels.clearButtonLabel,
        "aria-controls": setId.setId(elementId, "input"),
        icon: /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.CloseXS, {})
      }
    );
  }, [showClear, classes.adornmentButton, classes.iconClear, showSearchIcon, handleClear, labels == null ? void 0 : labels.clearButtonLabel, elementId, cx]);
  const handleSearch = React.useCallback((event) => {
    onEnter == null ? void 0 : onEnter(event, value);
  }, [onEnter, value]);
  const searchButton = React.useMemo(() => {
    const reallyShowIt = showSearchIcon && (isEmptyValue || hasOnEnter && validationState === validationStates.default.standBy);
    if (!reallyShowIt) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(Adornment.HvAdornment, { className: classes.adornmentButton, onClick: hasOnEnter ? handleSearch : void 0, "aria-label": labels == null ? void 0 : labels.searchButtonLabel, icon: /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.Search, {}) });
  }, [showSearchIcon, isEmptyValue, hasOnEnter, validationState, classes.adornmentButton, handleSearch, labels == null ? void 0 : labels.searchButtonLabel]);
  const handleRevealPassword = React.useCallback(() => {
    setRevealPassword(!revealPassword);
  }, [revealPassword]);
  const revealPasswordButton = React.useMemo(() => {
    if (!showRevealPasswordButton) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(Tooltip.HvTooltip, { disableFocusListener: true, disableTouchListener: true, title: /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { children: revealPassword ? labels == null ? void 0 : labels.revealPasswordButtonClickToHideTooltip : labels == null ? void 0 : labels.revealPasswordButtonClickToShowTooltip }), children: /* @__PURE__ */ jsxRuntime.jsx(Adornment.HvAdornment, { className: classes.adornmentButton, onClick: handleRevealPassword, "aria-label": labels == null ? void 0 : labels.revealPasswordButtonLabel, "aria-controls": setId.setId(elementId, "input"), icon: revealPassword ? /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.PreviewOff, {}) : /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.Preview, {}) }) });
  }, [showRevealPasswordButton, revealPassword, labels == null ? void 0 : labels.revealPasswordButtonClickToHideTooltip, labels == null ? void 0 : labels.revealPasswordButtonClickToShowTooltip, labels == null ? void 0 : labels.revealPasswordButtonLabel, classes.adornmentButton, handleRevealPassword, elementId]);
  const validationIcon = React.useMemo(() => {
    if (!showValidationIcon) {
      return null;
    }
    if (!validationStates.isValid(validationState)) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.Success, { color: "positive", className: classes.icon });
  }, [showValidationIcon, validationState, classes.icon]);
  const customIconEl = React.useMemo(() => React.isValidElement(endAdornment) && React__default.default.cloneElement(endAdornment, {
    className: cx(endAdornment.props.className, classes.icon)
  }), [classes.icon, endAdornment, cx]);
  const adornments = React.useMemo(() => {
    if (!clearButton && !revealPasswordButton && !searchButton && !validationIcon && !customIconEl)
      return null;
    return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.adornmentsBox, "aria-hidden": "true", children: [
      clearButton,
      revealPasswordButton,
      searchButton,
      validationIcon || customIconEl
    ] });
  }, [classes.adornmentsBox, clearButton, customIconEl, revealPasswordButton, searchButton, validationIcon]);
  React.useEffect(() => {
    if (focused || !isDirty.current && isEmptyValue) {
      return;
    }
    performValidation();
  }, [focused, isEmptyValue, performValidation]);
  const errorMessageId = isStateInvalid ? canShowError ? setId.setId(elementId, "error") : ariaErrorMessage : void 0;
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { id, name, status: validationState, disabled, required, readOnly, className: cx(classes.root, {
    [classes.hasSuggestions]: hasSuggestions
  }, className), onBlur: onContainerBlurHandler, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { id: setId.setId(elementId, "label"), className: classes.label, htmlFor: setId.setId(elementId, "input"), label }),
      hasDescription && /* @__PURE__ */ jsxRuntime.jsx(InfoMessage.HvInfoMessage, { id: setId.setId(elementId, "description"), className: classes.description, children: description })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(BaseInput.HvBaseInput, { id: hasLabel || showClear || showRevealPasswordButton ? setId.setId(elementId, "input") : setId.setId(id, "input"), name, value, required, readOnly, disabled, onChange: onChangeHandler, autoFocus, onKeyDown: onKeyDownHandler, onBlur: onInputBlurHandler, onFocus: onFocusHandler, placeholder, type: realType, classes: {
      input: classes.input,
      inputRoot: classes.inputRoot,
      inputRootFocused: classes.inputRootFocused,
      inputRootDisabled: classes.inputRootDisabled,
      inputRootMultiline: classes.inputRootMultiline,
      inputBorderContainer: classes.inputBorderContainer
    }, invalid: isStateInvalid, inputProps: {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": isStateInvalid ? true : void 0,
      "aria-errormessage": errorMessageId,
      "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : description ? setId.setId(elementId, "description") : void 0,
      "aria-controls": canShowSuggestions ? setId.setId(elementId, "suggestions") : void 0,
      ref: inputRef,
      // prevent browsers auto-fill/suggestions when we have our own
      autoComplete: canShowSuggestions ? "off" : void 0,
      ...inputProps
    }, inputRef: forkedRef, endAdornment: adornments, ...others }),
    canShowSuggestions && /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      hasSuggestions && /* @__PURE__ */ jsxRuntime.jsx("div", { role: "presentation", className: classes.inputExtension }),
      /* @__PURE__ */ jsxRuntime.jsx(Suggestions.HvSuggestions, { ref: suggestionsRef, id: setId.setId(elementId, "suggestions"), classes: {
        root: classes.suggestionsContainer,
        list: classes.suggestionList
      }, expanded: hasSuggestions, anchorEl: (_a = inputRef.current) == null ? void 0 : _a.parentElement, onClose: suggestionClearHandler, onKeyDown: onSuggestionKeyDown, onSuggestionSelected: suggestionSelectedHandler, suggestionValues })
    ] }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
});
exports.inputClasses = Input_styles.staticClasses;
exports.HvInput = HvInput;
//# sourceMappingURL=Input.cjs.map

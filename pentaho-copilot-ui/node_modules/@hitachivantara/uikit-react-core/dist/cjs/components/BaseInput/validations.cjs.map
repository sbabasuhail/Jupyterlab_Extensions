{"version":3,"file":"validations.cjs","sources":["../../../../src/components/BaseInput/validations.ts"],"sourcesContent":["import { HTMLInputTypeAttribute } from \"react\";\n\nimport { InputBaseComponentProps } from \"@mui/material\";\n\nimport validationStates from \"@core/components/Forms/FormElement/validationStates\";\n\n/** Checks if the value is a number. */\nconst isNumeric = (num: string) =>\n  // to prevent Number( <spaces> ) = 0\n  num.trim().length > 0 && !Number.isNaN(Number(num));\n\n/** Checks if the value is an email */\nconst isEmail = (email: string) => {\n  const regexp =\n    /^[^\\\\s]+[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?[.])+[a-z0-9](?:[a-z0-9-]*[a-z0-9])$/i;\n  return regexp.test(email);\n};\n\nexport const validationTypes = Object.freeze({\n  none: \"none\",\n  number: \"number\",\n  email: \"email\",\n});\n\n/** Returns the input's validation type based in the type of the input. */\nexport const computeValidationType = (type: HTMLInputTypeAttribute) => {\n  switch (type) {\n    case \"number\":\n      return validationTypes.number;\n    case \"email\":\n      return validationTypes.email;\n\n    default:\n      return validationTypes.none;\n  }\n};\n\n/**\n * Checks whether any integrated validation, native or not, is active.\n */\nexport const hasBuiltInValidations = (\n  required: boolean,\n  validationType: HTMLInputTypeAttribute,\n  minCharQuantity: number | null | undefined,\n  maxCharQuantity: number | null | undefined,\n  validation?: (value: string) => boolean,\n  inputProps?: InputBaseComponentProps\n) =>\n  required ||\n  validationType !== validationTypes.none ||\n  minCharQuantity != null ||\n  maxCharQuantity != null ||\n  validation != null ||\n  inputProps?.required != null ||\n  inputProps?.minLength != null ||\n  inputProps?.maxLength != null ||\n  inputProps?.min != null ||\n  inputProps?.max != null ||\n  (inputProps?.type != null &&\n    inputProps?.type !== \"text\" &&\n    inputProps?.type !== \"password\") ||\n  inputProps?.pattern != null;\n\n/** Returns the form element's validation state based in the validity state of the input. */\nexport const computeValidationState = (\n  inputValidity: HvInputValidity,\n  isEmptyValue: boolean\n) => {\n  // to keep 2.x behaviour,\n  // consider that if the value is empty (and not required) we're returning to the standBy state.\n  // might not make sense, as it makes impossible to say if the user explicitly cleared the input.\n  if (inputValidity.valid && isEmptyValue) {\n    return validationStates.standBy;\n  }\n\n  return inputValidity.valid\n    ? validationStates.valid\n    : validationStates.invalid;\n};\n\n/**\n * Returns a error message based in the validity state of the input.\n *\n * Only one error message is returned even if multiple validations fail.\n * Also, only required, minCharQuantity, maxCharQuantity and validationType have specific error messages.\n *\n * For further customization both status and statusMessage should be controlled and\n * set using the onBlur callback that receives both the value and the input validity object.\n */\nexport const computeValidationMessage = (\n  inputValidity: HvInputValidity,\n  /** The available localized error messages. */\n  errorMessages: Record<string, string>\n) => {\n  if (inputValidity.valid) {\n    return \"\";\n  }\n\n  if (inputValidity.valueMissing) {\n    return errorMessages.requiredError;\n  }\n  if (inputValidity.tooLong) {\n    return errorMessages.maxCharError;\n  }\n  if (inputValidity.tooShort) {\n    return errorMessages.minCharError;\n  }\n  if (inputValidity.typeMismatch) {\n    return errorMessages.typeMismatchError;\n  }\n\n  return errorMessages.error;\n};\n\n/**\n * Returns a object describing the validity state of the input.\n *\n * It implements the native browser's ValidityState interface:\n * https://developer.mozilla.org/en-US/docs/Web/API/ValidityState\n */\nexport const validateInput = (\n  input: HTMLInputElement | HTMLTextAreaElement | null,\n  value: string,\n  required: boolean,\n  minCharQuantity: any,\n  maxCharQuantity: any,\n  validationType: string,\n  validation?: (value: string) => boolean\n): HvInputValidity => {\n  // bootstrap validity object using browser's built-in validation\n  const inputValidity: HvInputValidity = {\n    valid: input?.validity?.valid ?? true,\n    badInput: input?.validity?.badInput,\n    customError: input?.validity?.customError,\n    patternMismatch: input?.validity?.patternMismatch,\n    rangeOverflow: input?.validity?.rangeOverflow,\n    rangeUnderflow: input?.validity?.rangeUnderflow,\n    stepMismatch: input?.validity?.stepMismatch,\n    tooLong: input?.validity?.tooLong,\n    tooShort: input?.validity?.tooShort,\n    typeMismatch: input?.validity?.typeMismatch,\n    valueMissing: input?.validity?.valueMissing,\n  };\n\n  if (!value) {\n    if (required) {\n      // this is redundant because we're setting the required property in the native input\n      inputValidity.valueMissing = true;\n      inputValidity.valid = false;\n    }\n  } else {\n    // we're not setting minlength and maxlength in the native input\n    // to avoid different browser's behaviours and keep the user experience consistent\n    if (minCharQuantity !== null && value.length < minCharQuantity) {\n      inputValidity.tooShort = true;\n      inputValidity.valid = false;\n    }\n\n    if (maxCharQuantity !== null && value.length > maxCharQuantity) {\n      inputValidity.tooLong = true;\n      inputValidity.valid = false;\n    }\n\n    // the validationType is used instead of type\n    // for the same reason stated above\n    switch (validationType) {\n      case validationTypes.number:\n        if (!isNumeric(value)) {\n          inputValidity.typeMismatch = true;\n          inputValidity.valid = false;\n        }\n        break;\n\n      case validationTypes.email:\n        if (!isEmail(value)) {\n          inputValidity.typeMismatch = true;\n          inputValidity.valid = false;\n        }\n        break;\n\n      default:\n    }\n\n    if (validation != null && !validation(value)) {\n      inputValidity.customError = true;\n      inputValidity.valid = false;\n    }\n  }\n\n  return inputValidity;\n};\n\nexport type HvInputValidity = {\n  valid?: boolean;\n  badInput?: boolean;\n  customError?: boolean;\n  patternMismatch?: boolean;\n  rangeOverflow?: boolean;\n  rangeUnderflow?: boolean;\n  stepMismatch?: boolean;\n  tooLong?: boolean;\n  tooShort?: boolean;\n  typeMismatch?: boolean;\n  valueMissing?: boolean;\n};\n\nexport const DEFAULT_ERROR_MESSAGES = {\n  error: \"Invalid value\",\n  requiredError: \"The value is required\",\n  minCharError: \"The value is too short\",\n  maxCharError: \"The value is too long\",\n  typeMismatchError: \"Invalid value\",\n};\n"],"names":["isNumeric","num","trim","length","Number","isNaN","isEmail","email","regexp","test","validationTypes","Object","freeze","none","number","computeValidationType","type","hasBuiltInValidations","required","validationType","minCharQuantity","maxCharQuantity","validation","inputProps","minLength","maxLength","min","max","pattern","computeValidationState","inputValidity","isEmptyValue","valid","validationStates","standBy","invalid","computeValidationMessage","errorMessages","valueMissing","requiredError","tooLong","maxCharError","tooShort","minCharError","typeMismatch","typeMismatchError","error","validateInput","input","value","validity","badInput","customError","patternMismatch","rangeOverflow","rangeUnderflow","stepMismatch","DEFAULT_ERROR_MESSAGES"],"mappings":"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"}
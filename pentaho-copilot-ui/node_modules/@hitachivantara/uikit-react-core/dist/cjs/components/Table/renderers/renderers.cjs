"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const react = require("@emotion/react");
const uikitReactIcons = require("@hitachivantara/uikit-react-icons");
const setId = require("../../../utils/setId.cjs");
const fallbacks = require("../utils/fallbacks.cjs");
const DateColumnCell = require("./DateColumnCell/DateColumnCell.cjs");
const Button = require("../../Button/Button.cjs");
const SwitchColumnCell = require("./SwitchColumnCell/SwitchColumnCell.cjs");
const DropdownColumnCell = require("./DropdownColumnCell/DropdownColumnCell.cjs");
const ProgressColumnCell = require("./ProgressColumnCell/ProgressColumnCell.cjs");
const OverflowTooltip = require("../../OverflowTooltip/OverflowTooltip.cjs");
const Tag = require("../../Tag/Tag.cjs");
const Typography = require("../../Typography/Typography.cjs");
function hvTextColumn(col, overflowTooltipProps = {}) {
  return {
    Cell: ({
      value
    }) => /* @__PURE__ */ jsxRuntime.jsx(OverflowTooltip.HvOverflowTooltip, { data: fallbacks.hvStringFallback(value), ...overflowTooltipProps }),
    sortType: "alphanumeric",
    ...col
  };
}
function hvNumberColumn(col) {
  return {
    Cell: ({
      value
    }) => /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: fallbacks.hvNumberFallback(value) }),
    align: "right",
    sortType: "number",
    ...col
  };
}
function hvDateColumn(col, dateFormat) {
  return {
    Cell: ({
      value
    }) => /* @__PURE__ */ jsxRuntime.jsx(DateColumnCell.HvDateColumnCell, { date: value, dateFormat }),
    sortType: "alphanumeric",
    sortDescFirst: true,
    ...col
  };
}
function hvExpandColumn(col, expandRowButtonAriaLabel, collapseRowButtonAriaLabel, getCanRowExpand, ExpandedIcon = /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.DropUpXS, {}), CollapsedIcon = /* @__PURE__ */ jsxRuntime.jsx(uikitReactIcons.DropDownXS, {})) {
  return {
    Cell: (cellProps) => {
      var _a;
      const {
        value,
        row
      } = cellProps;
      const expandedProps = (_a = row.getToggleRowExpandedProps) == null ? void 0 : _a.call(row);
      const hasContent = (getCanRowExpand == null ? void 0 : getCanRowExpand(row)) ?? true;
      return /* @__PURE__ */ jsxRuntime.jsx(react.ClassNames, { children: ({
        css
      }) => /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
        hasContent && /* @__PURE__ */ jsxRuntime.jsx(Button.HvButton, { icon: true, "aria-label": row.isExpanded ? collapseRowButtonAriaLabel : expandRowButtonAriaLabel, "aria-expanded": row.isExpanded, onClick: expandedProps == null ? void 0 : expandedProps.onClick, classes: {
          root: css({
            position: "absolute",
            left: 0,
            top: "50%",
            transform: "translateY(-50%)"
          })
        }, children: row.isExpanded ? ExpandedIcon : CollapsedIcon }),
        /* @__PURE__ */ jsxRuntime.jsx(OverflowTooltip.HvOverflowTooltip, { data: fallbacks.hvStringFallback(value) })
      ] }) });
    },
    sortType: "alphanumeric",
    cellStyle: {
      position: "relative"
    },
    ...col
  };
}
function hvTagColumn(col, valueDataKey, colorDataKey, textColorDataKey, fromRowData = false, tagProps) {
  return {
    Cell: (cellProps) => {
      const {
        value,
        row
      } = cellProps;
      if (!value) {
        return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "—" });
      }
      const {
        [valueDataKey]: name,
        [colorDataKey]: color,
        [textColorDataKey]: textColor
      } = fromRowData ? row.original : value;
      return /* @__PURE__ */ jsxRuntime.jsx(Tag.HvTag, { label: /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { variant: "body", children: name }), type: "semantic", color, style: textColor != null ? {
        color: textColor
      } : {}, tabIndex: -1, ...tagProps });
    },
    cellStyle: {
      paddingTop: 0,
      paddingBottom: 0
    },
    ...col
  };
}
function hvSwitchColumn(col, switchLabel, falseLabel, trueLabel, switchProps) {
  return {
    Cell: (cellProps) => {
      const {
        value,
        row
      } = cellProps;
      return /* @__PURE__ */ jsxRuntime.jsx(SwitchColumnCell.HvSwitchColumnCell, { checked: value, value: row.id, switchLabel, falseLabel, trueLabel, switchProps });
    },
    cellStyle: {
      paddingTop: 0,
      paddingBottom: 0
    },
    ...col
  };
}
function hvDropdownColumn(col, id, placeholder, disabledPlaceholder, onChange) {
  return {
    Cell: (cellProps) => {
      const {
        value,
        row,
        column
      } = cellProps;
      const dsbld = value.length < 1;
      return /* @__PURE__ */ jsxRuntime.jsx(DropdownColumnCell.HvDropdownColumnCell, { values: value, placeholder: dsbld ? disabledPlaceholder : placeholder, onChange: (val) => onChange == null ? void 0 : onChange(row.id, val), disabled: dsbld, dropdownProps: {
        "aria-labelledby": setId.setId(id, column.id) || column.id || id
        // TODO - to be reviewed because it doesn't make much sense
      } });
    },
    cellStyle: {
      paddingTop: 0,
      paddingBottom: 0
    },
    ...col
  };
}
function hvProgressColumn(col, getPartial, getTotal, color) {
  return {
    Cell: (cellProps) => {
      const {
        row,
        column
      } = cellProps;
      const partial = (getPartial == null ? void 0 : getPartial(row)) || 0;
      const total = getTotal == null ? void 0 : getTotal(row);
      if (total) {
        return /* @__PURE__ */ jsxRuntime.jsx(ProgressColumnCell.HvProgressColumnCell, { partial, total, color, "aria-labelledby": column.id });
      }
      return /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, { children: "—" });
    },
    cellStyle: {
      paddingTop: 0,
      paddingBottom: 0
    },
    ...col
  };
}
exports.hvDateColumn = hvDateColumn;
exports.hvDropdownColumn = hvDropdownColumn;
exports.hvExpandColumn = hvExpandColumn;
exports.hvNumberColumn = hvNumberColumn;
exports.hvProgressColumn = hvProgressColumn;
exports.hvSwitchColumn = hvSwitchColumn;
exports.hvTagColumn = hvTagColumn;
exports.hvTextColumn = hvTextColumn;
//# sourceMappingURL=renderers.cjs.map

"use strict";
Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
const reactTable = require("react-table");
const uikitStyles = require("@hitachivantara/uikit-styles");
const isSticky = (value) => /left|right/i.test(value);
const getStickyValue = ({
  sticky,
  parent
}) => {
  var _a;
  if (isSticky(sticky)) {
    return sticky;
  }
  if (parent != null) {
    sticky = getStickyValue(parent);
    if (isSticky(sticky)) {
      return sticky;
    }
    const {
      columns
    } = parent;
    if ((columns == null ? void 0 : columns.length) > 0) {
      sticky = (_a = columns == null ? void 0 : columns.find((col) => col.sticky != null)) == null ? void 0 : _a.sticky;
      if (isSticky(sticky)) {
        return sticky;
      }
    }
  }
  return void 0;
};
const updateColumnAndParent = (column, props) => {
  Object.assign(column, props);
  if (column.parent != null) {
    updateColumnAndParent(column.parent, props);
  }
};
const visibleColumnsHook = (columns, {
  instance
}) => {
  const toTheLeft = [];
  const toTheRight = [];
  const others = [];
  columns.forEach((column) => {
    var _a;
    const sticky = (_a = getStickyValue(column)) == null ? void 0 : _a.toLowerCase();
    updateColumnAndParent(column, {
      sticky
    });
    if (sticky === "left") {
      toTheLeft.push(column);
    } else if (sticky === "right") {
      toTheRight.push(column);
    } else {
      others.push(column);
    }
  });
  if (others.length > 0) {
    const [firstNotSticky] = others;
    updateColumnAndParent(firstNotSticky, {
      isFirstNotSticky: true
    });
    const lastNotSticky = others[others.length - 1];
    updateColumnAndParent(lastNotSticky, {
      isLastNotSticky: true
    });
  }
  const hasLeftSticky = toTheLeft.length > 0;
  if (hasLeftSticky) {
    const lastLeftSticky = toTheLeft[toTheLeft.length - 1];
    updateColumnAndParent(lastLeftSticky, {
      isLastLeftSticky: true
    });
  }
  const hasRightSticky = toTheRight.length > 0;
  if (hasRightSticky) {
    const [firstRightSticky] = toTheRight;
    updateColumnAndParent(firstRightSticky, {
      isFirstRightSticky: true
    });
  }
  instance.hasStickyColumns = hasLeftSticky || hasRightSticky;
  return [...toTheLeft, ...others, ...toTheRight];
};
const calculateHeaderWidthsToTheRight = (headers, right = 0) => {
  if (!(headers == null ? void 0 : headers.length)) {
    return;
  }
  for (let i = headers.length - 1; i !== -1; i -= 1) {
    const header = headers[i];
    header.totalRight = right;
    const {
      headers: subHeaders
    } = header;
    if ((subHeaders == null ? void 0 : subHeaders.length) > 0) {
      calculateHeaderWidthsToTheRight(subHeaders, right);
    }
    if (header.isVisible) {
      right += header.totalWidth;
    }
  }
};
const useInstanceHook = (instance) => {
  calculateHeaderWidthsToTheRight(instance.headers);
  const getInstance = reactTable.useGetLatest(instance);
  instance.getTableHeadProps = reactTable.makePropGetter(instance.getHooks().getTableHeadProps, {
    instance: getInstance()
  });
};
const getRowProps = () => ({
  style: {
    display: "flex",
    flex: "1 0 auto"
  }
});
const getCellProps = (header, isHeaderCell) => {
  const props = {
    style: {
      display: "inline-flex",
      flex: `${header.totalWidth} ${header.totalMinWidth} auto`,
      alignItems: isHeaderCell ? "start" : "center",
      justifyContent: header.align,
      width: `${header.totalWidth}px`,
      minWidth: `${header.totalMinWidth}px`,
      ...isHeaderCell && {
        backgroundColor: uikitStyles.theme.colors.atmo2
      }
    }
  };
  if (header.sticky != null) {
    props.stickyColumn = true;
    const margin = header.sticky === "left" ? header.totalLeft : header.totalRight;
    props.style[header.sticky] = `${margin}px`;
    if (header.isLastLeftSticky) {
      props.stickyColumnMostLeft = true;
    }
    if (header.isFirstRightSticky) {
      props.stickyColumnLeastRight = true;
    }
  } else {
    if (header.isFirstNotSticky) {
      props.style.borderLeft = 0;
    }
    if (header.isLastNotSticky) {
      props.style.borderRight = 0;
    }
  }
  return props;
};
const getTablePropsHook = (props, {
  instance
}) => {
  const nextProps = {
    stickyHeader: instance.stickyHeader,
    stickyColumns: instance.hasStickyColumns
  };
  return [props, nextProps];
};
const getTableHeadPropsHook = (props, {
  instance
}) => {
  const nextProps = {
    stickyHeader: instance.stickyHeader
  };
  return [props, nextProps];
};
const getHeaderGroupPropsHook = (props, {
  instance
}) => {
  const nextProps = instance.hasStickyColumns ? getRowProps() : {};
  return [props, nextProps];
};
const getHeaderPropsHook = (props, {
  instance,
  column
}) => {
  const nextProps = instance.hasStickyColumns ? getCellProps(column, true) : {};
  return [props, nextProps];
};
const getRowPropsHook = (props, {
  instance
}) => {
  const nextProps = instance.hasStickyColumns ? getRowProps() : {};
  return [props, nextProps];
};
const getCellPropsHook = (props, {
  instance,
  cell
}) => {
  const nextProps = instance.hasStickyColumns ? getCellProps(cell.column, false) : {};
  return [props, nextProps];
};
const useSticky = (hooks) => {
  hooks.visibleColumns.push(visibleColumnsHook);
  hooks.useInstance.push(useInstanceHook);
  hooks.getTableProps.push(getTablePropsHook);
  hooks.getTableHeadProps = [getTableHeadPropsHook];
  hooks.getHeaderGroupProps.push(getHeaderGroupPropsHook);
  hooks.getHeaderProps.push(getHeaderPropsHook);
  hooks.getRowProps.push(getRowPropsHook);
  hooks.getCellProps.push(getCellPropsHook);
};
useSticky.pluginName = "useHvTableSticky";
const useSticky$1 = useSticky;
exports.default = useSticky$1;
exports.getHeaderGroupPropsHook = getHeaderGroupPropsHook;
exports.getTableHeadPropsHook = getTableHeadPropsHook;
//# sourceMappingURL=useSticky.cjs.map

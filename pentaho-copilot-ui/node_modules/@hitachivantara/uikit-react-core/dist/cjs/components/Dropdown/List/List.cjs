"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const uikitStyles = require("@hitachivantara/uikit-styles");
const isNil = require("lodash/isNil");
const setId = require("../../../utils/setId.cjs");
const List_styles = require("./List.styles.cjs");
const utils = require("../utils.cjs");
const BaseDropdownContext = require("../../BaseDropdown/BaseDropdownContext/BaseDropdownContext.cjs");
const ActionBar = require("../../ActionBar/ActionBar.cjs");
const Button = require("../../Button/Button.cjs");
const List = require("../../List/List.cjs");
const Input = require("../../Input/Input.cjs");
const Typography = require("../../Typography/Typography.cjs");
const CheckBox = require("../../CheckBox/CheckBox.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const isNil__default = /* @__PURE__ */ _interopDefault(isNil);
const clone = (values) => values.map((value) => ({
  ...value
}));
const cleanHidden = (lst) => lst.map((item) => ({
  ...item,
  isHidden: false
}));
const valuesExist = (values) => !isNil__default.default(values) && (values == null ? void 0 : values.length) > 0;
const HvDropdownList = ({
  id,
  classes: classesProp,
  values = [],
  multiSelect = false,
  showSearch = false,
  onChange,
  onCancel,
  labels,
  notifyChangesOnFirstRender = false,
  hasTooltips = false,
  singleSelectionToggle,
  height: dropdownHeight,
  maxHeight,
  virtualized = false,
  ...others
}) => {
  const {
    classes,
    cx,
    css
  } = List_styles.useClasses(classesProp);
  const [searchStr, setSearchStr] = React.useState("");
  const [list, setList] = React.useState(clone(values));
  const [allSelected, setAllSelected] = React.useState(false);
  const [anySelected, setAnySelected] = React.useState(false);
  const {
    width,
    height
  } = React.useContext(BaseDropdownContext.default);
  const newLabels = {
    selectAll: labels == null ? void 0 : labels.selectAll,
    selectionConjunction: labels == null ? void 0 : labels.multiSelectionConjunction
  };
  const updateSelectAll = (listValues) => {
    if (!listValues)
      return;
    const nbrSelected = utils.getSelected(listValues).length;
    const hasSelection = nbrSelected > 0;
    const allSelect = nbrSelected === listValues.length;
    setAnySelected(hasSelection);
    setAllSelected(hasSelection && allSelect);
  };
  React.useEffect(() => {
    if (!valuesExist(values))
      return;
    setList(clone(values));
    updateSelectAll(values);
    if (notifyChangesOnFirstRender) {
      onChange == null ? void 0 : onChange(values, false, false, true);
    }
  }, [values, notifyChangesOnFirstRender, onChange]);
  const handleSearch = (str) => {
    const results = list ? list.filter(({
      searchValue,
      label,
      value
    }) => {
      let stringValue = "";
      if (typeof searchValue === "string" || searchValue instanceof String) {
        stringValue = searchValue.toLowerCase();
      } else if (typeof label === "string" || label instanceof String) {
        stringValue = label.toLowerCase();
      } else if (typeof value === "string" || value instanceof String) {
        stringValue = value.toLowerCase();
      }
      return stringValue.indexOf(str.toLowerCase()) >= 0;
    }) : null;
    if (!isNil__default.default(results)) {
      const newList = list.map((elem) => {
        const isResult = results.find((result) => result.label === elem.label);
        return {
          ...elem,
          isHidden: !isResult
        };
      });
      setList(newList);
      setSearchStr(str);
    }
    return str;
  };
  const renderSearch = () => /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.searchContainer, children: /* @__PURE__ */ jsxRuntime.jsx(Input.HvInput, { id: setId.setId(id, "search"), type: "search", value: searchStr, placeholder: labels == null ? void 0 : labels.searchPlaceholder, "aria-label": labels == null ? void 0 : labels.searchPlaceholder, onChange: (event, str) => handleSearch(str) }) });
  const handleSelectAll = () => {
    const newList = list.map((elem) => ({
      ...elem,
      selected: !anySelected
    }));
    setList(newList);
    updateSelectAll(newList);
  };
  const renderSelectAll = () => {
    const selectAll = labels == null ? void 0 : labels.selectAll;
    const multiSelectionConjunction = labels == null ? void 0 : labels.multiSelectionConjunction;
    const nbrSelected = utils.getSelected(list).length;
    const defaultLabel = /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { component: "span", children: nbrSelected > 0 ? /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx("b", { children: nbrSelected }),
      ` ${multiSelectionConjunction} ${list.length}`
    ] }) : /* @__PURE__ */ jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [
      /* @__PURE__ */ jsxRuntime.jsx("b", { children: selectAll }),
      ` (${list.length})`
    ] }) });
    return /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.selectAllContainer, children: /* @__PURE__ */ jsxRuntime.jsx(CheckBox.HvCheckBox, { id: setId.setId(id, "select-all"), label: defaultLabel, onChange: () => handleSelectAll(), classes: {
      container: classes.selection
    }, className: classes.selectAll, indeterminate: anySelected && !allSelected, checked: allSelected }) });
  };
  const onSelection = (listValues) => {
    if (!multiSelect) {
      onChange(cleanHidden(listValues), true, true, true);
    } else {
      updateSelectAll(listValues);
      setList(clone(listValues));
    }
  };
  const renderActions = () => {
    const applyLabel = labels == null ? void 0 : labels.applyLabel;
    const cancelLabel = labels == null ? void 0 : labels.cancelLabel;
    return /* @__PURE__ */ jsxRuntime.jsxs(ActionBar.HvActionBar, { id: setId.setId(id, "actions"), children: [
      /* @__PURE__ */ jsxRuntime.jsx(Button.HvButton, { id: setId.setId(id, "actions-apply"), onClick: () => onChange(cleanHidden(list), true, true, true), variant: "primaryGhost", children: applyLabel }),
      /* @__PURE__ */ jsxRuntime.jsx(Button.HvButton, { id: setId.setId(id, "actions-cancel"), onClick: onCancel, variant: "primaryGhost", children: cancelLabel })
    ] });
  };
  const showList = valuesExist(values);
  return /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.rootList, children: [
    /* @__PURE__ */ jsxRuntime.jsx("div", { className: classes.listBorderDown }),
    /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.listContainer, children: [
      showSearch && renderSearch(),
      showList && multiSelect && renderSelectAll(),
      showList && /* @__PURE__ */ jsxRuntime.jsx(List.HvList, { id: setId.setId(id, "list"), classes: {
        root: cx(classes.dropdownListContainer, css({
          maxWidth: width,
          maxHeight: maxHeight ?? `calc(${height}px - 32px - ${uikitStyles.theme.space.xs} - ${uikitStyles.theme.space.sm})`,
          overflow: "auto",
          padding: 4,
          margin: -4
        }), dropdownHeight && css({
          height: dropdownHeight
        }), virtualized && css({
          maxWidth: "inherit",
          maxHeight: "inherit",
          overflow: "inherit",
          padding: 0
        }))
      }, values: list, multiSelect, useSelector: multiSelect, showSelectAll: false, onChange: onSelection, labels: newLabels, hasTooltips, selectable: true, condensed: true, singleSelectionToggle, height: dropdownHeight, virtualized, ...others })
    ] }),
    showList && multiSelect ? renderActions() : null
  ] });
};
exports.dropdownListClasses = List_styles.staticClasses;
exports.HvDropdownList = HvDropdownList;
//# sourceMappingURL=List.cjs.map

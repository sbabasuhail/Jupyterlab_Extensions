"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const uikitStyles = require("@hitachivantara/uikit-styles");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const setId = require("../../utils/setId.cjs");
const utils = require("./utils.cjs");
const Dropdown_styles = require("./Dropdown.styles.cjs");
const useLabels = require("../../hooks/useLabels.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const List = require("./List/List.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const BaseDropdown = require("../BaseDropdown/BaseDropdown.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const Typography = require("../Typography/Typography.cjs");
const DEFAULT_LABELS = {
  select: void 0,
  selectAll: "All",
  cancelLabel: "Cancel",
  applyLabel: "Apply",
  searchPlaceholder: "Search",
  multiSelectionConjunction: "/"
};
const HvDropdown = (props) => {
  const {
    classes: classesProp,
    className,
    id,
    name,
    required = false,
    disabled = false,
    readOnly = false,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    placeholder = "Select...",
    onChange,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    onCancel,
    onToggle,
    onClickOutside,
    onFocus,
    onBlur,
    values,
    multiSelect = false,
    showSearch = false,
    expanded,
    defaultExpanded = false,
    notifyChangesOnFirstRender = false,
    labels: labelsProp,
    hasTooltips = false,
    disablePortal = false,
    singleSelectionToggle = true,
    placement,
    variableWidth = false,
    popperProps = {},
    height,
    maxHeight,
    virtualized = false,
    baseDropdownProps = {},
    listProps = {},
    ...others
  } = useDefaultProps.useDefaultProps("HvDropdown", props);
  const {
    classes,
    cx,
    css
  } = Dropdown_styles.useClasses(classesProp);
  const labels = useLabels.useLabels(DEFAULT_LABELS, labelsProp);
  const elementId = useUniqueId.useUniqueId(id, "hvdropdown");
  const [validationState, setValidationState] = useControlled.useControlled(status, "standBy");
  const [validationMessage] = useControlled.useControlled(statusMessage, "Required");
  const [isOpen, setIsOpen] = useControlled.useControlled(expanded, Boolean(defaultExpanded));
  const [selectionLabel, setSelectionLabel] = React.useState(utils.getSelectionLabel(labels, placeholder, multiSelect, values));
  const [internalValues, setInternalValues] = React.useState(values);
  React.useEffect(() => {
    setInternalValues(values);
  }, [values]);
  React.useEffect(() => {
    setSelectionLabel(utils.getSelectionLabel(labels, placeholder, multiSelect, values));
  }, [labels, multiSelect, placeholder, values]);
  if (virtualized && !height && process.env.NODE_ENV !== "production") {
    console.error("Dropdown/List in virtualized mode requires a height. Please define it.");
  }
  const dropdownHeaderRef = React.useRef();
  const handleToggle = (event, open) => {
    onToggle == null ? void 0 : onToggle(event, open);
    setIsOpen(open);
    if (!open) {
      setValidationState(() => {
        if (required) {
          const hasSelection = utils.getSelected(internalValues).length > 0;
          if (!hasSelection) {
            return "invalid";
          }
        }
        return "valid";
      });
    }
  };
  const handleSelection = (listValues, commitChanges, toggle, notifyChanges = true) => {
    var _a;
    const selected = utils.getSelected(listValues);
    if (commitChanges) {
      setInternalValues(listValues);
      setSelectionLabel(utils.getSelectionLabel(labels, placeholder, multiSelect, listValues));
      setValidationState(() => {
        if (required && selected.length === 0) {
          return "invalid";
        }
        return "valid";
      });
    }
    if (notifyChanges)
      onChange == null ? void 0 : onChange(multiSelect ? selected : selected[0]);
    if (toggle) {
      handleToggle(void 0, false);
      (_a = dropdownHeaderRef.current) == null ? void 0 : _a.focus({
        preventScroll: true
      });
    }
  };
  const handleCancel = (evt) => {
    var _a;
    onCancel == null ? void 0 : onCancel(evt);
    handleToggle(evt, false);
    (_a = dropdownHeaderRef.current) == null ? void 0 : _a.focus({
      preventScroll: true
    });
  };
  const handleClickOutside = (evt) => {
    onClickOutside == null ? void 0 : onClickOutside(evt);
    onCancel == null ? void 0 : onCancel(evt);
  };
  const setFocusToContent = (containerRef) => {
    const inputs = containerRef == null ? void 0 : containerRef.getElementsByTagName("input");
    if (inputs && inputs.length > 0) {
      inputs[0].focus();
      return;
    }
    const listItems = containerRef != null ? [...containerRef.getElementsByTagName("li")] : [];
    listItems.every((listItem) => {
      if (listItem.tabIndex >= 0) {
        listItem.focus();
        return false;
      }
      return true;
    });
  };
  const buildHeaderLabel = () => {
    const hasSelection = utils.getSelected(internalValues).length > 0;
    return (labels == null ? void 0 : labels.select) || !multiSelect ? /* @__PURE__ */ jsxRuntime.jsx(Typography.HvTypography, { component: "div", variant: "body", className: cx(classes.placeholder, {
      [classes.selectionDisabled]: disabled
    }, !(isOpen || hasSelection) && css({
      color: uikitStyles.theme.dropdown.placeholderColor
    })), children: selectionLabel.selected }) : /* @__PURE__ */ jsxRuntime.jsxs(Typography.HvTypography, { component: "div", className: cx(classes.placeholder, {
      [classes.selectionDisabled]: disabled
    }), variant: "body", children: [
      /* @__PURE__ */ jsxRuntime.jsx("b", { children: selectionLabel.selected }),
      ` ${labels == null ? void 0 : labels.multiSelectionConjunction} ${selectionLabel.total}`
    ] });
  };
  const hasLabel = label != null;
  const hasDescription = description != null;
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const isStateInvalid = validationStates.isInvalid(validationState);
  let errorMessageId;
  if (isStateInvalid) {
    errorMessageId = canShowError ? setId.setId(elementId, "error") : ariaErrorMessage;
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { id, name, status: validationState, disabled, readOnly, required, className: cx(classes.root, disabled && css({
    color: uikitStyles.theme.dropdown.disabledColor
  }), className), ...others, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { id: setId.setId(elementId, "label"), label, className: classes.label }),
      hasDescription && /* @__PURE__ */ jsxRuntime.jsx(InfoMessage.HvInfoMessage, { id: setId.setId(elementId, "description"), className: classes.description, children: description })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(BaseDropdown.HvBaseDropdown, { id: setId.setId(id, "dropdown"), classes: {
      root: cx(classes.dropdown, readOnly && css({
        [`& .${Dropdown_styles.staticClasses.dropdownHeader}`]: {
          border: uikitStyles.theme.dropdown.readOnlyBorder,
          backgroundColor: uikitStyles.theme.dropdown.readOnlyBackgroundColor
        }
      })),
      arrow: classes.arrow,
      header: cx(classes.dropdownHeader, {
        [classes.dropdownHeaderInvalid]: isStateInvalid
      }),
      headerOpen: classes.dropdownHeaderOpen
    }, expanded: isOpen, disabled, readOnly, required, disablePortal, placement, popperProps, placeholder: buildHeaderLabel(), onToggle: handleToggle, onClickOutside: handleClickOutside, onContainerCreation: setFocusToContent, role: "combobox", variableWidth, "aria-label": ariaLabel, "aria-labelledby": [label && setId.setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0, "aria-invalid": isStateInvalid ? true : void 0, "aria-errormessage": errorMessageId, "aria-describedby": [description && setId.setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, onFocus, onBlur, dropdownHeaderRef, ...baseDropdownProps, children: /* @__PURE__ */ jsxRuntime.jsx(List.HvDropdownList, { id: setId.setId(elementId, "values"), classes: {
      rootList: classes.rootList,
      dropdownListContainer: classes.dropdownListContainer
    }, values: internalValues, multiSelect, showSearch, onChange: handleSelection, onCancel: handleCancel, labels, notifyChangesOnFirstRender, hasTooltips, singleSelectionToggle, "aria-label": ariaLabel, "aria-labelledby": hasLabel ? setId.setId(elementId, "label") : void 0, height, maxHeight, virtualized, ...listProps }) }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
exports.dropdownClasses = Dropdown_styles.staticClasses;
exports.HvDropdown = HvDropdown;
//# sourceMappingURL=Dropdown.cjs.map

"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const jsxRuntime = require("@emotion/react/jsx-runtime");
const React = require("react");
const material = require("@mui/material");
const isNil = require("lodash/isNil");
const setId = require("../../utils/setId.cjs");
const useUniqueId = require("../../hooks/useUniqueId.cjs");
const useControlled = require("../../hooks/useControlled.cjs");
const useDefaultProps = require("../../hooks/useDefaultProps.cjs");
const validationStates = require("../Forms/FormElement/validationStates.cjs");
const validations = require("../BaseInput/validations.cjs");
const TextArea_styles = require("./TextArea.styles.cjs");
const CharCounter = require("../Forms/CharCounter/CharCounter.cjs");
const FormElement = require("../Forms/FormElement/FormElement.cjs");
const Label = require("../Forms/Label/Label.cjs");
const InfoMessage = require("../Forms/InfoMessage/InfoMessage.cjs");
const BaseInput = require("../BaseInput/BaseInput.cjs");
const WarningText = require("../Forms/WarningText/WarningText.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const isNil__default = /* @__PURE__ */ _interopDefault(isNil);
const HvTextArea = React.forwardRef((props, ref) => {
  const {
    id,
    className,
    classes: classesProp,
    name,
    label,
    description,
    placeholder,
    status,
    statusMessage,
    validationMessages,
    maxCharQuantity,
    minCharQuantity,
    value: valueProp,
    inputRef: inputRefProp,
    rows = 1,
    defaultValue = "",
    middleCountLabel = "/",
    countCharProps = {},
    inputProps = {},
    required = false,
    readOnly = false,
    disabled = false,
    autoFocus = false,
    resizable = false,
    autoScroll = false,
    hideCounter = false,
    blockMax = false,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy,
    "aria-errormessage": ariaErrorMessage,
    validation,
    onChange,
    onBlur,
    onFocus,
    ...others
  } = useDefaultProps.useDefaultProps("HvTextArea", props);
  const {
    classes,
    cx
  } = TextArea_styles.useClasses(classesProp);
  const elementId = useUniqueId.useUniqueId(id, "hvtextarea");
  const isDirty = React.useRef(false);
  const inputRef = React.useRef(null);
  const forkedRef = material.useForkRef(ref, inputRefProp, inputRef);
  const [focused, setFocused] = React.useState(false);
  const [autoScrolling, setAutoScrolling] = React.useState(autoScroll);
  const [validationState, setValidationState] = useControlled.useControlled(status, validationStates.default.standBy);
  const [validationMessage, setValidationMessage] = useControlled.useControlled(statusMessage, "");
  const [value, setValue] = useControlled.useControlled(valueProp, defaultValue);
  const isStateInvalid = validationStates.isInvalid(validationState);
  const isEmptyValue = value == null || value === "";
  const hasLabel = label != null;
  const hasDescription = description != null;
  const hasCounter = maxCharQuantity != null && !hideCounter;
  const errorMessages = React.useMemo(() => ({
    ...validations.DEFAULT_ERROR_MESSAGES,
    ...validationMessages
  }), [validationMessages]);
  const performValidation = React.useCallback(() => {
    const inputValidity = validations.validateInput(inputRef.current, value, required, minCharQuantity, maxCharQuantity, validations.validationTypes.none, validation);
    setValidationState(validations.computeValidationState(inputValidity, isEmptyValue));
    setValidationMessage(validations.computeValidationMessage(inputValidity, errorMessages));
    return inputValidity;
  }, [errorMessages, inputRef, isEmptyValue, maxCharQuantity, minCharQuantity, required, setValidationMessage, setValidationState, validation, value]);
  const isOverflow = (currentValue) => isNil__default.default(maxCharQuantity) ? false : currentValue.length > maxCharQuantity;
  const limitValue = (currentValue) => {
    if (currentValue === void 0 || !blockMax)
      return currentValue;
    return !isOverflow(currentValue) ? currentValue : currentValue.substring(0, maxCharQuantity);
  };
  const onContainerBlurHandler = (event) => {
    setFocused(false);
    const inputValidity = performValidation();
    onBlur == null ? void 0 : onBlur(event, value, inputValidity);
  };
  const onChangeHandler = (event, currentValue) => {
    isDirty.current = true;
    const limitedValue = blockMax ? limitValue(currentValue) : currentValue;
    setValue(limitedValue);
    onChange == null ? void 0 : onChange(event, limitedValue);
  };
  const onFocusHandler = (event) => {
    setFocused(true);
    setValidationState(validationStates.default.standBy);
    onFocus == null ? void 0 : onFocus(event, value);
  };
  const isScrolledDown = React.useCallback(() => {
    const el = inputRef.current;
    return el == null || el.offsetHeight + el.scrollTop >= el.scrollHeight;
  }, [inputRef]);
  const scrollDown = React.useCallback(() => {
    const el = inputRef.current;
    if (el != null) {
      el.scrollTop = el.scrollHeight - el.clientHeight;
    }
  }, [inputRef]);
  const addScrollListener = React.useCallback(() => {
    var _a;
    const scrollHandler = {
      handleEvent: () => {
        setAutoScrolling(isScrolledDown());
      }
    };
    (_a = inputRef.current) == null ? void 0 : _a.addEventListener("scroll", scrollHandler);
  }, [inputRef, isScrolledDown]);
  React.useEffect(() => {
    if (autoScroll) {
      addScrollListener();
    }
  }, [autoScroll, addScrollListener]);
  React.useEffect(() => {
    if (autoScrolling) {
      scrollDown();
    }
  }, [valueProp, autoScrolling, scrollDown]);
  React.useEffect(() => {
    if (focused || !isDirty.current && isEmptyValue) {
      return;
    }
    performValidation();
  }, [focused, isEmptyValue, performValidation]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && validations.hasBuiltInValidations(
    required,
    validations.validationTypes.none,
    minCharQuantity,
    // If blockMax is true maxCharQuantity will never produce an error
    // unless the value is controlled, so we can't prevent it to overflow maxCharQuantity
    maxCharQuantity != null && (blockMax !== true || value != null) ? maxCharQuantity : null,
    validation,
    inputProps
  ));
  let errorMessageId;
  if (isStateInvalid) {
    errorMessageId = canShowError ? setId.setId(elementId, "error") : ariaErrorMessage;
  }
  return /* @__PURE__ */ jsxRuntime.jsxs(FormElement.HvFormElement, { id, name, status: validationState, disabled, required, readOnly, className: cx(classes.root, {
    [classes.resizable]: resizable,
    [classes.disabled]: disabled,
    [classes.invalid]: isStateInvalid
  }, className), onBlur: onContainerBlurHandler, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxRuntime.jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsxRuntime.jsx(Label.HvLabel, { className: classes.label, id: setId.setId(id, "label"), htmlFor: setId.setId(elementId, "input"), label }),
      hasDescription && /* @__PURE__ */ jsxRuntime.jsx(InfoMessage.HvInfoMessage, { className: classes.description, id: setId.setId(elementId, "description"), children: description })
    ] }),
    hasCounter && /* @__PURE__ */ jsxRuntime.jsx(CharCounter.HvCharCounter, { id: setId.setId(elementId, "charCounter"), className: classes.characterCounter, separator: middleCountLabel, currentCharQuantity: value.length, maxCharQuantity, ...countCharProps }),
    /* @__PURE__ */ jsxRuntime.jsx(BaseInput.HvBaseInput, { classes: {
      root: classes.baseInput,
      input: classes.input,
      inputResizable: classes.inputResizable
    }, id: hasLabel ? setId.setId(elementId, "input") : setId.setId(id, "input"), name, value, required, readOnly, disabled, onChange: onChangeHandler, autoFocus, onFocus: onFocusHandler, placeholder, invalid: isStateInvalid, resizable, multiline: true, rows, inputProps: {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": isStateInvalid ? true : void 0,
      "aria-errormessage": errorMessageId,
      "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : description && setId.setId(elementId, "description") || void 0,
      "aria-controls": maxCharQuantity ? setId.setId(elementId, "charCounter") : void 0,
      ...inputProps
    }, inputRef: forkedRef, ...others }),
    canShowError && /* @__PURE__ */ jsxRuntime.jsx(WarningText.HvWarningText, { id: setId.setId(elementId, "error"), className: classes.error, disableBorder: true, children: validationMessage })
  ] });
});
exports.textAreaClasses = TextArea_styles.staticClasses;
exports.HvTextArea = HvTextArea;
//# sourceMappingURL=TextArea.cjs.map

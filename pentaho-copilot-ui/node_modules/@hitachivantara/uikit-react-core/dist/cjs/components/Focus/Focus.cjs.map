{"version":3,"file":"Focus.cjs","sources":["../../../../src/components/Focus/Focus.tsx"],"sourcesContent":["import isNil from \"lodash/isNil\";\nimport React, { RefObject, useState } from \"react\";\nimport { HvBaseProps } from \"@core/types/generic\";\nimport { isKey, isOneOfKeys } from \"@core/utils/keyboardUtils\";\nimport { isBrowser } from \"@core/utils/browser\";\nimport { ConditionalWrapper } from \"@core/utils/ConditionalWrapper\";\nimport { ExtractNames } from \"@core/utils/classes\";\nimport { getFocusableChildren, setFocusTo } from \"./utils\";\nimport { staticClasses, useClasses } from \"./Focus.styles\";\n\nexport { staticClasses as focusClasses };\nexport type HvFocusClasses = ExtractNames<typeof useClasses>;\n\nexport type HvFocusStrategies = \"listbox\" | \"menu\" | \"card\" | \"grid\";\n\nexport interface HvFocusProps extends HvBaseProps<HTMLElement, \"children\"> {\n  children: React.ReactElement;\n  /** Extra configuration for the child element. */\n  configuration?: {\n    tabIndex?: number;\n  };\n  /** Indicates that the disabled class should be applied. */\n  disabledClass?: boolean;\n  /** Whether the focus is selected. */\n  selected?: boolean;\n  /** Whether the focus is disabled. */\n  disabled?: boolean;\n  /** The reference to the root element to hold all Focus' context. */\n  rootRef?: RefObject<HTMLElement>;\n  /** Show focus when click element. v */\n  focusOnClick?: boolean;\n  /** Show focus when click element. v */\n  focusDisabled?: boolean;\n  /** Focus and navigation strategy to be used. v */\n  strategy?: HvFocusStrategies;\n  /** Uses an absolute positioned div as a focus. v */\n  useFalseFocus?: boolean;\n  /** Narrows the results of the focus to only theses class v */\n  filterClass?: string;\n  /** How much the navigation will skip when using the arrows. v */\n  navigationJump?: number;\n  /** A Jss Object used to override or extend the styles applied to the component. */\n  classes?: HvFocusClasses;\n}\n\nexport const HvFocus = ({\n  classes: classesProp,\n  children,\n  configuration = {},\n  disabledClass = false,\n  selected = false,\n  disabled = false,\n  rootRef = undefined,\n  focusOnClick = false,\n  focusDisabled = true,\n  strategy = \"listbox\",\n  useFalseFocus = false,\n  filterClass,\n  navigationJump = 4,\n}: HvFocusProps) => {\n  const [showFocus, setShowFocus] = useState<boolean>(false);\n  const [childFocus, setChildFocus] = useState<any>();\n  const [hasRunConfig, setHasRunConfig] = useState(false);\n  const { classes, cx } = useClasses(classesProp);\n\n  const getFocuses = () => {\n    const focuses = rootRef?.current\n      ? Array.from(\n          rootRef.current.getElementsByClassName(\n            filterClass || staticClasses.root || \"root\"\n          )\n        )\n      : [];\n    return focuses;\n  };\n\n  const setTabIndex = (el, tabIndex = 0) => {\n    if (!el) return;\n    const elChildFocus = getFocusableChildren(el)[0];\n    if (elChildFocus) {\n      el.tabIndex = -1;\n      elChildFocus.tabIndex = tabIndex;\n    } else {\n      el.tabIndex = tabIndex;\n    }\n  };\n\n  const setSelectedTabIndex = () => {\n    const focuses = getFocuses();\n    const firstSelected = focuses.find((focus) =>\n      focus.classList.contains(classes.selected || \"selected\")\n    );\n\n    if (!firstSelected) return;\n    focuses.forEach((focus) => setTabIndex(focus, -1));\n    setTabIndex(firstSelected, 0);\n  };\n\n  const clearTabSiblings = (el) => {\n    getFocuses().forEach((focus) => setTabIndex(focus, -1));\n    setTabIndex(el, 0);\n  };\n\n  const onFocusStrategy = (evt) => {\n    if (strategy === \"listbox\") {\n      clearTabSiblings(evt.currentTarget);\n    }\n  };\n\n  const onBlurStrategy = () => {\n    if (\n      strategy === \"listbox\" &&\n      rootRef &&\n      rootRef.current &&\n      !rootRef.current.contains(document.activeElement)\n    ) {\n      setTimeout(() => {\n        setSelectedTabIndex();\n      }, 10);\n    }\n  };\n\n  const config = (el) => {\n    const { tabIndex } = configuration;\n    if (!el || hasRunConfig) return;\n    if (strategy === \"card\") {\n      setChildFocus(children);\n      return;\n    }\n\n    if (strategy === \"grid\") {\n      return;\n    }\n\n    const focusableChildren = getFocusableChildren(el);\n    if (focusableChildren.length) {\n      focusableChildren.forEach((child) => setTabIndex(child, -1));\n      setChildFocus(focusableChildren[0]);\n    }\n\n    if (!isNil(tabIndex)) setTabIndex(el, tabIndex);\n    setHasRunConfig(true);\n  };\n\n  const addFocusClass = (evt) => {\n    if (!useFalseFocus) {\n      // evt.currentTarget.classList.add(classes.focused);\n      classes.focused\n        .split(\" \")\n        .forEach((c) => evt.currentTarget.classList.add(c));\n      // add global class HvIsFocused as a marker\n      // not to be styled directly, only as helper in specific css queries\n      evt.currentTarget.classList.add(\"HvIsFocused\");\n      classes?.focus\n        ?.split(\" \")\n        .forEach((c) => evt.currentTarget.classList.add(c));\n    }\n  };\n\n  const removeFocusClass = () => {\n    if (!useFalseFocus) {\n      getFocuses().forEach((element) => {\n        // element.classList.remove(classes.focused);\n        classes.focused.split(\" \").forEach((c) => element.classList.remove(c));\n        // remove the global class HvIsFocused\n        element.classList.remove(\"HvIsFocused\");\n        classes?.focus?.split(\" \").forEach((c) => element.classList.remove(c));\n      });\n    }\n  };\n\n  const onFocus = (evt) => {\n    addFocusClass(evt);\n    setShowFocus(true);\n    // give focus to child element if any focusable\n\n    if (childFocus && childFocus.focus) childFocus.focus();\n    onFocusStrategy(evt);\n  };\n\n  const onBlur = () => {\n    setShowFocus(false);\n    removeFocusClass();\n    onBlurStrategy();\n  };\n\n  const onMouseDown = (evt) => {\n    const hasCard = !!evt.currentTarget?.querySelector(\".HvIsCardGridElement\");\n    if (strategy === \"grid\" && hasCard) return;\n\n    setFocusTo(evt.currentTarget);\n    setTabIndex(evt.currentTarget, 0);\n    // remove focus outline unless explicitly enabled\n    if (!focusOnClick) {\n      // TODO this piece of code works only because onMouseDown is happening after the focus event\n      // There is nothing in here that guarantees the order of these events, so it may present a problem in the future\n      removeFocusClass();\n      setShowFocus(false);\n    }\n  };\n\n  const focusAndUpdateIndex = (nextFocus, previousFocus, focusesList) => {\n    if (focusesList?.includes(previousFocus)) {\n      setTabIndex(previousFocus, -1);\n    }\n    setTabIndex(nextFocus, 0);\n    setFocusTo(nextFocus);\n  };\n\n  const getEnabledKeys = (currentFocusIndex, jump, listSize) => ({\n    right:\n      (currentFocusIndex + 1) % jump === 0 ||\n      currentFocusIndex + 1 > listSize - 1,\n    left: currentFocusIndex % jump === 0,\n    up: currentFocusIndex - jump < 0,\n    down:\n      currentFocusIndex + jump > listSize ||\n      currentFocusIndex + jump > listSize - 1,\n  });\n\n  const onGridKeyDownHandler = (\n    evt,\n    focuses,\n    focusesList,\n    currentFocusIndex,\n    jump\n  ) => {\n    const childFocusIsInput = childFocus && childFocus.nodeName === \"INPUT\";\n\n    if (\n      !isOneOfKeys(evt, [\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"ArrowLeft\",\n        \"ArrowRight\",\n        \"Home\",\n        \"End\",\n        \"Space\",\n        \"Enter\",\n      ]) ||\n      (childFocusIsInput && isKey(evt, \"Enter\"))\n    ) {\n      // nothing to do\n      return;\n    }\n\n    // we'll do something with the key so prevent default and stop propagation\n    // except for Enter and SpaceBar\n    if (!isOneOfKeys(evt, [\"Enter\", \"Space\"])) {\n      evt.preventDefault();\n      evt.stopPropagation();\n    }\n\n    const blockedKeys = getEnabledKeys(\n      currentFocusIndex,\n      jump,\n      focusesList.length\n    );\n\n    switch (evt.code) {\n      case \"Space\":\n      case \"Enter\":\n        if (isBrowser(\"firefox\")) {\n          evt.target.click();\n        } else {\n          evt.currentTarget.click();\n        }\n        break;\n      case \"ArrowUp\":\n        if (!blockedKeys.up) {\n          focusAndUpdateIndex(\n            focuses.jump || focuses.last,\n            evt.current,\n            focusesList\n          );\n        }\n        break;\n      case \"ArrowDown\":\n        if (!blockedKeys.down) {\n          focusAndUpdateIndex(\n            focuses.fall || focuses.first,\n            evt.current,\n            focusesList\n          );\n        }\n        break;\n      case \"ArrowLeft\":\n        if (!blockedKeys.left) {\n          focusAndUpdateIndex(\n            focuses.previous || focuses.last,\n            evt.current,\n            focusesList\n          );\n        }\n        break;\n      case \"ArrowRight\":\n        if (!blockedKeys.right) {\n          focusAndUpdateIndex(\n            focuses.next || focuses.first,\n            evt.current,\n            focusesList\n          );\n        }\n        break;\n      case \"Home\":\n        focusAndUpdateIndex(focuses.first, evt.current, focusesList);\n        break;\n      case \"End\":\n        focusAndUpdateIndex(focuses.last, evt.current, focusesList);\n        break;\n      default:\n    }\n  };\n\n  const onVerticalArrangementHandler = (evt, focuses, focusesList) => {\n    const childFocusIsInput = childFocus && childFocus.nodeName === \"INPUT\";\n\n    if (\n      !isOneOfKeys(evt, [\n        \"ArrowUp\",\n        \"ArrowDown\",\n        \"Home\",\n        \"End\",\n        \"Space\",\n        \"Enter\",\n      ]) ||\n      (childFocusIsInput && isKey(evt, \"Enter\"))\n    ) {\n      // nothing to do\n      return;\n    }\n\n    // we'll do something with the key so prevent default and stop propagation\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    switch (evt.code) {\n      case \"Space\":\n      case \"Enter\":\n        evt.target.click();\n        break;\n      case \"ArrowUp\":\n        focusAndUpdateIndex(\n          focuses.previous || focuses.last,\n          evt.current,\n          focusesList\n        );\n        break;\n      case \"ArrowDown\":\n        focusAndUpdateIndex(\n          focuses.next || focuses.first,\n          evt.current,\n          focusesList\n        );\n        break;\n      case \"Home\":\n        focusAndUpdateIndex(focuses.first, evt.current, focusesList);\n        break;\n      case \"End\":\n        focusAndUpdateIndex(focuses.last, evt.current, focusesList);\n        break;\n      default:\n    }\n  };\n\n  const onSingleHandler = (evt) => {\n    const childFocusIsInput = childFocus && childFocus.nodeName === \"INPUT\";\n\n    if (\n      !isOneOfKeys(evt, [\"Space\", \"Enter\"]) ||\n      (childFocusIsInput && isKey(evt, \"Enter\"))\n    ) {\n      // nothing to do\n      return;\n    }\n\n    // we'll do something with the key so prevent default and stop propagation\n    evt.preventDefault();\n    evt.stopPropagation();\n\n    evt.currentTarget.click();\n  };\n\n  const onKeyDown = (evt) => {\n    if (rootRef?.current == null) {\n      // operating outside of a composite widget\n      // nothing to manage, just style and trigger clicks\n      onSingleHandler(evt);\n      return;\n    }\n\n    // TODO keep the smart default, but allow to explicitly override if disabled elements should be focusable\n    const isDisabledFocusable = strategy === \"menu\";\n    const focusesList = getFocuses().filter(\n      (el) =>\n        isDisabledFocusable ||\n        !el.classList.contains(classes?.disabled as string)\n    );\n\n    const currentFocus = focusesList.indexOf(evt.currentTarget);\n\n    const focuses = {\n      first: focusesList[0],\n      last: focusesList[focusesList.length - 1],\n      previous: focusesList[currentFocus - 1],\n      next: focusesList[currentFocus + 1],\n      fall: focusesList[currentFocus + navigationJump],\n      jump: focusesList[currentFocus - navigationJump],\n    };\n\n    if (strategy === \"grid\") {\n      onGridKeyDownHandler(\n        evt,\n        focuses,\n        focusesList,\n        currentFocus,\n        navigationJump\n      );\n      return;\n    }\n\n    // TODO add property for specifying the composite widget orientation\n    // TODO implement handler for horizontal orientation\n    onVerticalArrangementHandler(evt, focuses, focusesList);\n  };\n\n  const onKeyUp = (evt) => {\n    if (isBrowser(\"firefox\")) evt.preventDefault();\n  };\n\n  if (disabled) return children;\n\n  const focusWrapper = (childrenToWrap) => (\n    <div className={classes.externalReference}>\n      {childrenToWrap}\n      {showFocus && <div className={classes.falseFocus} />}\n    </div>\n  );\n\n  return (\n    <ConditionalWrapper condition={useFalseFocus} wrapper={focusWrapper}>\n      {React.cloneElement(children, {\n        className: cx(\n          [classes.root, filterClass],\n          {\n            [classes.selected]: selected,\n            [classes.disabled]: disabledClass,\n            [classes.focusDisabled]: focusDisabled,\n          },\n          children.props.className\n        ),\n        ref: config,\n        onFocus,\n        onBlur,\n        onMouseDown,\n        onKeyDown,\n        onKeyUp,\n        selected,\n      })}\n    </ConditionalWrapper>\n  );\n};\n"],"names":["HvFocus","classes","classesProp","children","configuration","disabledClass","selected","disabled","rootRef","undefined","focusOnClick","focusDisabled","strategy","useFalseFocus","filterClass","navigationJump","showFocus","setShowFocus","useState","childFocus","setChildFocus","hasRunConfig","setHasRunConfig","cx","useClasses","getFocuses","focuses","current","Array","from","getElementsByClassName","staticClasses","root","setTabIndex","el","tabIndex","elChildFocus","getFocusableChildren","setSelectedTabIndex","firstSelected","find","focus","classList","contains","forEach","clearTabSiblings","onFocusStrategy","evt","currentTarget","onBlurStrategy","document","activeElement","setTimeout","config","focusableChildren","length","child","isNil","addFocusClass","focused","split","c","add","removeFocusClass","element","remove","onFocus","onBlur","onMouseDown","hasCard","querySelector","setFocusTo","focusAndUpdateIndex","nextFocus","previousFocus","focusesList","includes","getEnabledKeys","currentFocusIndex","jump","listSize","right","left","up","down","onGridKeyDownHandler","childFocusIsInput","nodeName","isOneOfKeys","isKey","preventDefault","stopPropagation","blockedKeys","code","isBrowser","target","click","last","fall","first","previous","next","onVerticalArrangementHandler","onSingleHandler","onKeyDown","isDisabledFocusable","filter","currentFocus","indexOf","onKeyUp","focusWrapper","childrenToWrap","jsxs","externalReference","jsx","falseFocus","ConditionalWrapper","React","cloneElement","className","props","ref"],"mappings":"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"}
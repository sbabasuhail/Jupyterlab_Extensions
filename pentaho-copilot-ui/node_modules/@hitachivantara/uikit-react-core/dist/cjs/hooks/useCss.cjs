"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const React = require("react");
const clsx = require("clsx");
const serialize = require("@emotion/serialize");
const utils = require("@emotion/utils");
const useEmotionCache = require("./useEmotionCache.cjs");
const _interopDefault = (e) => e && e.__esModule ? e : { default: e };
const clsx__default = /* @__PURE__ */ _interopDefault(clsx);
function getRef(args) {
  if (args.length !== 1) {
    return {
      args,
      ref: void 0
    };
  }
  const [arg] = args;
  if (!(arg instanceof Object)) {
    return {
      args,
      ref: void 0
    };
  }
  if (!("ref" in arg)) {
    return {
      args,
      ref: void 0
    };
  }
  const {
    ref,
    ...argCopy
  } = arg;
  return {
    args: [argCopy],
    ref
  };
}
const cssFactory = (() => {
  function merge(registered, css, className) {
    const registeredStyles = [];
    const rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) {
      return className;
    }
    return rawClassName + css(registeredStyles);
  }
  function innerCssFactory(cache) {
    const css = (...styles) => {
      const {
        ref,
        args
      } = getRef(styles);
      const serialized = serialize.serializeStyles(args, cache.registered);
      utils.insertStyles(cache, serialized, false);
      return `${cache.key}-${serialized.name}${ref === void 0 ? "" : ` ${ref}`}`;
    };
    const cx = (...args) => merge(cache.registered, css, clsx__default.default(args));
    return {
      css,
      cx
    };
  }
  return innerCssFactory;
})();
function useCss() {
  const cache = useEmotionCache.useEmotionCache();
  return React.useMemo(() => cssFactory(cache), [cache]);
}
exports.useCss = useCss;
//# sourceMappingURL=useCss.cjs.map

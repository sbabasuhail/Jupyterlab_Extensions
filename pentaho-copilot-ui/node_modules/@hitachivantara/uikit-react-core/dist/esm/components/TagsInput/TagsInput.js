import { jsxs, jsx, Fragment } from "@emotion/react/jsx-runtime";
import { useState, useRef, useMemo, useCallback, useEffect } from "react";
import isNil from "lodash/isNil";
import { theme } from "@hitachivantara/uikit-styles";
import { useControlled } from "../../hooks/useControlled.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useIsMounted } from "../../hooks/useIsMounted.js";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { isKey } from "../../utils/keyboardUtils.js";
import { setId } from "../../utils/setId.js";
import validationState from "../Forms/FormElement/validationStates.js";
import { DEFAULT_ERROR_MESSAGES } from "../BaseInput/validations.js";
import { useClasses } from "./TagsInput.styles.js";
import { staticClasses } from "./TagsInput.styles.js";
import { HvTag } from "../Tag/Tag.js";
import { HvInput } from "../Input/Input.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvCharCounter } from "../Forms/CharCounter/CharCounter.js";
import { HvListContainer } from "../ListContainer/ListContainer.js";
import { HvListItem } from "../ListContainer/ListItem/ListItem.js";
import { staticClasses as staticClasses2 } from "../BaseInput/BaseInput.styles.js";
import { HvSuggestions } from "../Forms/Suggestions/Suggestions.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
const HvTagsInput = (props) => {
  var _a;
  const {
    classes: classesProp,
    className,
    id,
    name,
    value: valueProp,
    defaultValue = [],
    readOnly = false,
    disabled = false,
    required = false,
    label: textAreaLabel,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    onAdd,
    onDelete,
    onBlur,
    onFocus,
    placeholder,
    hideCounter = false,
    middleCountLabel = "/",
    maxTagsQuantity,
    autoFocus = false,
    resizable = true,
    inputProps = {},
    countCharProps = {},
    multiline = false,
    status,
    statusMessage,
    validationMessages,
    commitTagOn = ["Enter"],
    commitOnBlur = false,
    suggestionListCallback,
    ...others
  } = useDefaultProps("HvTagsInput", props);
  const {
    classes,
    cx,
    css
  } = useClasses(classesProp);
  const elementId = useUniqueId(id, "hvTagsInput");
  const hasLabel = textAreaLabel != null;
  const hasDescription = description != null;
  const [value, setValue] = useControlled(valueProp, defaultValue);
  const [validationState$1, setValidationState] = useControlled(status, validationState.standBy);
  const [validationMessage, setValidationMessage] = useControlled(statusMessage, "");
  const [tagInput, setTagInput] = useState("");
  const [tagCursorPos, setTagCursorPos] = useState(value.length);
  const [stateValid, setStateValid] = useState(true);
  const inputRef = useRef();
  const containerRef = useRef();
  const skipReset = useRef(false);
  const blurTimeout = useRef();
  const materialInputRef = useRef(null);
  const isTagSelected = tagCursorPos >= 0 && tagCursorPos < value.length;
  const hasCounter = maxTagsQuantity != null && !hideCounter;
  const [suggestionValues, setSuggestionValues] = useState(null);
  const isStateInvalid = useMemo(() => {
    return hasCounter && value.length > maxTagsQuantity;
  }, [hasCounter, maxTagsQuantity, value.length]);
  const canShowSuggestions = suggestionListCallback != null;
  const hasSuggestions = !!suggestionValues;
  const errorMessages = useMemo(() => ({
    ...DEFAULT_ERROR_MESSAGES,
    ...validationMessages
  }), [validationMessages]);
  const performValidation = useCallback((currValue) => {
    if (maxTagsQuantity !== null && maxTagsQuantity !== void 0 && currValue.length > maxTagsQuantity) {
      setValidationState(validationState.invalid);
      setValidationMessage(errorMessages.maxCharError);
      setStateValid(false);
    } else {
      setValidationState(validationState.valid);
      setValidationMessage("");
      setStateValid(true);
    }
  }, [errorMessages.maxCharError, maxTagsQuantity, setValidationMessage, setValidationState]);
  const deleteTag = useCallback((tagPos, event, end) => {
    var _a2;
    const newTagsArr = [...value.slice(0, tagPos), ...value.slice(tagPos + 1)];
    setValue(newTagsArr);
    setTagCursorPos(end ? newTagsArr.length : tagCursorPos > 0 ? tagCursorPos - 1 : 0);
    (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
    performValidation(newTagsArr);
    onDelete == null ? void 0 : onDelete(event, value[tagPos], tagPos);
    onChange == null ? void 0 : onChange(event, newTagsArr);
    skipReset.current = true;
  }, [onChange, onDelete, performValidation, setValue, tagCursorPos, value]);
  const addTag = useCallback((event, tag) => {
    event.preventDefault();
    if (tag !== "") {
      const newTag = {
        label: tag,
        type: "semantic"
      };
      const newTagsArr = [...value, newTag];
      setValue(newTagsArr);
      performValidation(newTagsArr);
      onAdd == null ? void 0 : onAdd(event, newTag, newTagsArr.length - 1);
      onChange == null ? void 0 : onChange(event, newTagsArr);
    }
  }, [onAdd, onChange, performValidation, setValue, value]);
  const canShowError = status !== void 0 && status === "invalid" && statusMessage !== void 0 || !stateValid;
  useEffect(() => {
    var _a2;
    if (!multiline) {
      const element = (_a2 = containerRef == null ? void 0 : containerRef.current) == null ? void 0 : _a2.children[tagCursorPos];
      setTimeout(() => {
        const container = containerRef.current;
        if (isNil(container))
          return;
        container.scrollLeft = element ? element.offsetLeft - container.getBoundingClientRect().width / 2 + element.getBoundingClientRect().width / 2 : 0;
      }, 50);
      element == null ? void 0 : element.focus();
    }
  }, [multiline, tagCursorPos]);
  useEffect(() => {
    if (!skipReset.current) {
      setTagInput("");
      setTagCursorPos(value.length);
    }
    skipReset.current = false;
  }, [value]);
  const isMounted = useIsMounted();
  const focusInput = () => {
    materialInputRef.current.focus();
  };
  const getSuggestions = useCallback((li) => {
    var _a2;
    const listEl = document.getElementById(setId(elementId, "suggestions-list") || "");
    return li != null ? (_a2 = listEl == null ? void 0 : listEl.getElementsByTagName("li")) == null ? void 0 : _a2[li] : listEl;
  }, [elementId]);
  const suggestionClearHandler = useCallback(() => {
    if (isMounted.current) {
      setSuggestionValues(null);
    }
  }, [isMounted]);
  const suggestionHandler = useCallback((val) => {
    var _a2;
    const suggestionsArray = suggestionListCallback == null ? void 0 : suggestionListCallback(val);
    if ((_a2 = suggestionsArray == null ? void 0 : suggestionsArray[0]) == null ? void 0 : _a2.label) {
      setSuggestionValues(suggestionsArray);
    } else {
      suggestionClearHandler();
    }
  }, [suggestionClearHandler, suggestionListCallback]);
  const suggestionSelectedHandler = (event, item) => {
    addTag(event, item.value || item.label);
    setTagInput(item.value || item.label);
    focusInput();
    suggestionClearHandler();
  };
  const onSuggestionKeyDown = (event) => {
    if (isKey(event, "Esc")) {
      suggestionClearHandler();
      focusInput();
    } else if (isKey(event, "Tab")) {
      suggestionClearHandler();
    }
  };
  const onChangeHandler = useCallback((_, input) => {
    setTagInput(input);
    if (canShowSuggestions) {
      suggestionHandler(input);
    }
  }, [canShowSuggestions, suggestionHandler]);
  const onInputKeyDownHandler = useCallback((event) => {
    if (!canShowSuggestions && commitTagOn.includes(event.code)) {
      addTag(event, tagInput);
    }
  }, [addTag, canShowSuggestions, commitTagOn, tagInput]);
  const onKeyDownHandler = useCallback((event) => {
    var _a2;
    if (tagInput === "") {
      switch (event.code) {
        case "ArrowLeft":
          setTagCursorPos(tagCursorPos > 0 ? tagCursorPos - 1 : 0);
          break;
        case "ArrowRight":
          setTagCursorPos(tagCursorPos < value.length ? tagCursorPos + 1 : value.length);
          break;
        case "Backspace":
          if (isTagSelected) {
            deleteTag(tagCursorPos, event, false);
          } else {
            setTagCursorPos(value.length - 1);
          }
          break;
        case "Delete":
          if (isTagSelected) {
            deleteTag(tagCursorPos, event, false);
          }
          break;
      }
    } else {
      switch (event.code) {
        case "ArrowDown":
          (_a2 = getSuggestions(0)) == null ? void 0 : _a2.focus();
          break;
      }
    }
  }, [deleteTag, getSuggestions, isTagSelected, tagCursorPos, tagInput, value.length]);
  const onDeleteTagHandler = useCallback((event, i) => {
    deleteTag(i, event, true);
    setValidationState(validationState.standBy);
  }, [deleteTag, setValidationState]);
  const onContainerClickHandler = useCallback(() => {
    var _a2;
    (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
    clearTimeout(blurTimeout.current);
    setTagCursorPos(value.length);
  }, [value.length]);
  const onBlurHandler = (evt) => {
    blurTimeout.current = setTimeout(() => {
      if (commitOnBlur) {
        addTag(evt, tagInput);
      }
      onBlur == null ? void 0 : onBlur(evt, tagInput);
    }, 250);
  };
  const onFocusHandler = (evt) => {
    clearTimeout(blurTimeout.current);
    onFocus == null ? void 0 : onFocus(evt, tagInput);
  };
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, disabled, readOnly, status: validationState$1, required, onBlur: onBlurHandler, onFocus: onFocusHandler, className: cx(classes.root, {
    [classes.disabled]: disabled,
    [classes.readOnly]: readOnly
  }, className), children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsx(HvLabel, { className: classes.label, id: setId(id, "label"), htmlFor: setId(elementId, "input"), label: textAreaLabel }),
      hasDescription && /* @__PURE__ */ jsx(HvInfoMessage, { className: classes.description, id: setId(elementId, "description"), children: description })
    ] }),
    hasCounter && /* @__PURE__ */ jsx(HvCharCounter, { id: setId(elementId, "charCounter"), className: classes.characterCounter, separator: middleCountLabel, currentCharQuantity: value.length, maxCharQuantity: maxTagsQuantity, ...countCharProps }),
    /* @__PURE__ */ jsxs(HvListContainer, { className: cx(classes.tagsList, {
      [classes.error]: canShowError,
      [classes.resizable]: resizable && multiline,
      [classes.invalid]: isStateInvalid,
      [classes.singleLine]: !multiline
    }), onKeyDown: onKeyDownHandler, onClick: onContainerClickHandler, ref: containerRef, children: [
      value && value.map((t, i) => {
        const tag = typeof t === "string" ? {
          label: t,
          type: "semantic"
        } : t;
        const {
          label,
          type,
          ...otherProps
        } = tag;
        return /* @__PURE__ */ jsx(HvListItem, { tabIndex: -1, className: cx({
          [classes.singleLine]: !multiline
        }), classes: {
          gutters: classes.listItemGutters,
          root: classes.listItemRoot
        }, id: setId(elementId, `tag-${i}`), children: /* @__PURE__ */ jsx(HvTag, { label, className: cx({
          [classes.tagSelected]: i === tagCursorPos
        }), classes: {
          chipRoot: classes.chipRoot
        }, type, ...!(readOnly || disabled || type === "categorical") && {
          onDelete: (event) => onDeleteTagHandler(event, i)
        }, deleteButtonProps: {
          tabIndex: -1
        }, ...otherProps }) }, `${tag.label}-${i}`);
      }),
      !(disabled || readOnly) && /* @__PURE__ */ jsx(HvListItem, { className: cx({
        [classes.singleLine]: !multiline,
        [classes.tagInputRootEmpty]: value.length === 0
      }, !!isTagSelected && css({
        [`& .${staticClasses2.inputRoot}`]: {
          backgroundColor: theme.colors.atmo1
        }
      })), classes: {
        root: classes.tagInputContainerRoot,
        gutters: classes.listItemGutters
      }, id: setId(elementId, `tag-${value.length}`), children: /* @__PURE__ */ jsx(HvInput, { value: tagInput, disableClear: true, onChange: onChangeHandler, onKeyDown: onInputKeyDownHandler, placeholder: value.length === 0 ? placeholder : "", autoFocus, className: cx({
        [classes.singleLine]: !multiline
      }), classes: {
        root: classes.tagInputRoot,
        input: classes.input,
        inputBorderContainer: classes.tagInputBorderContainer,
        inputRootFocused: classes.tagInputRootFocused
      }, disabled, readOnly: readOnly || isTagSelected, inputProps: {
        ref: materialInputRef,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : description && setId(elementId, "description") || void 0,
        ...inputProps
      }, inputRef, ...others }) })
    ] }),
    canShowSuggestions && /* @__PURE__ */ jsxs(Fragment, { children: [
      hasSuggestions && /* @__PURE__ */ jsx("div", { role: "presentation", className: classes.inputExtension }),
      /* @__PURE__ */ jsx(HvSuggestions, { id: setId(elementId, "suggestions"), classes: {
        root: classes.suggestionsContainer,
        list: classes.suggestionList
      }, expanded: hasSuggestions, anchorEl: (_a = containerRef == null ? void 0 : containerRef.current) == null ? void 0 : _a.parentElement, onClose: suggestionClearHandler, onKeyDown: onSuggestionKeyDown, onSuggestionSelected: suggestionSelectedHandler, suggestionValues })
    ] }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
export {
  HvTagsInput,
  staticClasses as tagsInputClasses
};
//# sourceMappingURL=TagsInput.js.map

import { jsx, jsxs } from "@emotion/react/jsx-runtime";
import isNil from "lodash/isNil";
import React__default, { useState } from "react";
import { isOneOfKeys, isKey } from "../../utils/keyboardUtils.js";
import { isBrowser } from "../../utils/browser.js";
import { ConditionalWrapper } from "../../utils/ConditionalWrapper.js";
import { getFocusableChildren, setFocusTo } from "./utils.js";
import { useClasses, staticClasses } from "./Focus.styles.js";
const HvFocus = ({
  classes: classesProp,
  children,
  configuration = {},
  disabledClass = false,
  selected = false,
  disabled = false,
  rootRef = void 0,
  focusOnClick = false,
  focusDisabled = true,
  strategy = "listbox",
  useFalseFocus = false,
  filterClass,
  navigationJump = 4
}) => {
  const [showFocus, setShowFocus] = useState(false);
  const [childFocus, setChildFocus] = useState();
  const [hasRunConfig, setHasRunConfig] = useState(false);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const getFocuses = () => {
    const focuses = (rootRef == null ? void 0 : rootRef.current) ? Array.from(rootRef.current.getElementsByClassName(filterClass || staticClasses.root || "root")) : [];
    return focuses;
  };
  const setTabIndex = (el, tabIndex = 0) => {
    if (!el)
      return;
    const elChildFocus = getFocusableChildren(el)[0];
    if (elChildFocus) {
      el.tabIndex = -1;
      elChildFocus.tabIndex = tabIndex;
    } else {
      el.tabIndex = tabIndex;
    }
  };
  const setSelectedTabIndex = () => {
    const focuses = getFocuses();
    const firstSelected = focuses.find((focus) => focus.classList.contains(classes.selected || "selected"));
    if (!firstSelected)
      return;
    focuses.forEach((focus) => setTabIndex(focus, -1));
    setTabIndex(firstSelected, 0);
  };
  const clearTabSiblings = (el) => {
    getFocuses().forEach((focus) => setTabIndex(focus, -1));
    setTabIndex(el, 0);
  };
  const onFocusStrategy = (evt) => {
    if (strategy === "listbox") {
      clearTabSiblings(evt.currentTarget);
    }
  };
  const onBlurStrategy = () => {
    if (strategy === "listbox" && rootRef && rootRef.current && !rootRef.current.contains(document.activeElement)) {
      setTimeout(() => {
        setSelectedTabIndex();
      }, 10);
    }
  };
  const config = (el) => {
    const {
      tabIndex
    } = configuration;
    if (!el || hasRunConfig)
      return;
    if (strategy === "card") {
      setChildFocus(children);
      return;
    }
    if (strategy === "grid") {
      return;
    }
    const focusableChildren = getFocusableChildren(el);
    if (focusableChildren.length) {
      focusableChildren.forEach((child) => setTabIndex(child, -1));
      setChildFocus(focusableChildren[0]);
    }
    if (!isNil(tabIndex))
      setTabIndex(el, tabIndex);
    setHasRunConfig(true);
  };
  const addFocusClass = (evt) => {
    var _a;
    if (!useFalseFocus) {
      classes.focused.split(" ").forEach((c) => evt.currentTarget.classList.add(c));
      evt.currentTarget.classList.add("HvIsFocused");
      (_a = classes == null ? void 0 : classes.focus) == null ? void 0 : _a.split(" ").forEach((c) => evt.currentTarget.classList.add(c));
    }
  };
  const removeFocusClass = () => {
    if (!useFalseFocus) {
      getFocuses().forEach((element) => {
        var _a;
        classes.focused.split(" ").forEach((c) => element.classList.remove(c));
        element.classList.remove("HvIsFocused");
        (_a = classes == null ? void 0 : classes.focus) == null ? void 0 : _a.split(" ").forEach((c) => element.classList.remove(c));
      });
    }
  };
  const onFocus = (evt) => {
    addFocusClass(evt);
    setShowFocus(true);
    if (childFocus && childFocus.focus)
      childFocus.focus();
    onFocusStrategy(evt);
  };
  const onBlur = () => {
    setShowFocus(false);
    removeFocusClass();
    onBlurStrategy();
  };
  const onMouseDown = (evt) => {
    var _a;
    const hasCard = !!((_a = evt.currentTarget) == null ? void 0 : _a.querySelector(".HvIsCardGridElement"));
    if (strategy === "grid" && hasCard)
      return;
    setFocusTo(evt.currentTarget);
    setTabIndex(evt.currentTarget, 0);
    if (!focusOnClick) {
      removeFocusClass();
      setShowFocus(false);
    }
  };
  const focusAndUpdateIndex = (nextFocus, previousFocus, focusesList) => {
    if (focusesList == null ? void 0 : focusesList.includes(previousFocus)) {
      setTabIndex(previousFocus, -1);
    }
    setTabIndex(nextFocus, 0);
    setFocusTo(nextFocus);
  };
  const getEnabledKeys = (currentFocusIndex, jump, listSize) => ({
    right: (currentFocusIndex + 1) % jump === 0 || currentFocusIndex + 1 > listSize - 1,
    left: currentFocusIndex % jump === 0,
    up: currentFocusIndex - jump < 0,
    down: currentFocusIndex + jump > listSize || currentFocusIndex + jump > listSize - 1
  });
  const onGridKeyDownHandler = (evt, focuses, focusesList, currentFocusIndex, jump) => {
    const childFocusIsInput = childFocus && childFocus.nodeName === "INPUT";
    if (!isOneOfKeys(evt, ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", "Home", "End", "Space", "Enter"]) || childFocusIsInput && isKey(evt, "Enter")) {
      return;
    }
    if (!isOneOfKeys(evt, ["Enter", "Space"])) {
      evt.preventDefault();
      evt.stopPropagation();
    }
    const blockedKeys = getEnabledKeys(currentFocusIndex, jump, focusesList.length);
    switch (evt.code) {
      case "Space":
      case "Enter":
        if (isBrowser("firefox")) {
          evt.target.click();
        } else {
          evt.currentTarget.click();
        }
        break;
      case "ArrowUp":
        if (!blockedKeys.up) {
          focusAndUpdateIndex(focuses.jump || focuses.last, evt.current, focusesList);
        }
        break;
      case "ArrowDown":
        if (!blockedKeys.down) {
          focusAndUpdateIndex(focuses.fall || focuses.first, evt.current, focusesList);
        }
        break;
      case "ArrowLeft":
        if (!blockedKeys.left) {
          focusAndUpdateIndex(focuses.previous || focuses.last, evt.current, focusesList);
        }
        break;
      case "ArrowRight":
        if (!blockedKeys.right) {
          focusAndUpdateIndex(focuses.next || focuses.first, evt.current, focusesList);
        }
        break;
      case "Home":
        focusAndUpdateIndex(focuses.first, evt.current, focusesList);
        break;
      case "End":
        focusAndUpdateIndex(focuses.last, evt.current, focusesList);
        break;
    }
  };
  const onVerticalArrangementHandler = (evt, focuses, focusesList) => {
    const childFocusIsInput = childFocus && childFocus.nodeName === "INPUT";
    if (!isOneOfKeys(evt, ["ArrowUp", "ArrowDown", "Home", "End", "Space", "Enter"]) || childFocusIsInput && isKey(evt, "Enter")) {
      return;
    }
    evt.preventDefault();
    evt.stopPropagation();
    switch (evt.code) {
      case "Space":
      case "Enter":
        evt.target.click();
        break;
      case "ArrowUp":
        focusAndUpdateIndex(focuses.previous || focuses.last, evt.current, focusesList);
        break;
      case "ArrowDown":
        focusAndUpdateIndex(focuses.next || focuses.first, evt.current, focusesList);
        break;
      case "Home":
        focusAndUpdateIndex(focuses.first, evt.current, focusesList);
        break;
      case "End":
        focusAndUpdateIndex(focuses.last, evt.current, focusesList);
        break;
    }
  };
  const onSingleHandler = (evt) => {
    const childFocusIsInput = childFocus && childFocus.nodeName === "INPUT";
    if (!isOneOfKeys(evt, ["Space", "Enter"]) || childFocusIsInput && isKey(evt, "Enter")) {
      return;
    }
    evt.preventDefault();
    evt.stopPropagation();
    evt.currentTarget.click();
  };
  const onKeyDown = (evt) => {
    if ((rootRef == null ? void 0 : rootRef.current) == null) {
      onSingleHandler(evt);
      return;
    }
    const isDisabledFocusable = strategy === "menu";
    const focusesList = getFocuses().filter((el) => isDisabledFocusable || !el.classList.contains(classes == null ? void 0 : classes.disabled));
    const currentFocus = focusesList.indexOf(evt.currentTarget);
    const focuses = {
      first: focusesList[0],
      last: focusesList[focusesList.length - 1],
      previous: focusesList[currentFocus - 1],
      next: focusesList[currentFocus + 1],
      fall: focusesList[currentFocus + navigationJump],
      jump: focusesList[currentFocus - navigationJump]
    };
    if (strategy === "grid") {
      onGridKeyDownHandler(evt, focuses, focusesList, currentFocus, navigationJump);
      return;
    }
    onVerticalArrangementHandler(evt, focuses, focusesList);
  };
  const onKeyUp = (evt) => {
    if (isBrowser("firefox"))
      evt.preventDefault();
  };
  if (disabled)
    return children;
  const focusWrapper = (childrenToWrap) => /* @__PURE__ */ jsxs("div", { className: classes.externalReference, children: [
    childrenToWrap,
    showFocus && /* @__PURE__ */ jsx("div", { className: classes.falseFocus })
  ] });
  return /* @__PURE__ */ jsx(ConditionalWrapper, { condition: useFalseFocus, wrapper: focusWrapper, children: React__default.cloneElement(children, {
    className: cx([classes.root, filterClass], {
      [classes.selected]: selected,
      [classes.disabled]: disabledClass,
      [classes.focusDisabled]: focusDisabled
    }, children.props.className),
    ref: config,
    onFocus,
    onBlur,
    onMouseDown,
    onKeyDown,
    onKeyUp,
    selected
  }) });
};
export {
  HvFocus,
  staticClasses as focusClasses
};
//# sourceMappingURL=Focus.js.map

import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import React__default, { useMemo, useRef, useEffect, useCallback } from "react";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useControlled } from "../../hooks/useControlled.js";
import { multiSelectionEventHandler } from "../../utils/multiSelectionEventHandler.js";
import { isKey } from "../../utils/keyboardUtils.js";
import { setId } from "../../utils/setId.js";
import { useClasses } from "./SelectionList.styles.js";
import { staticClasses } from "./SelectionList.styles.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvListContainer } from "../ListContainer/ListContainer.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
const getValueFromSelectedChildren = (children, multiple) => {
  const selectedValues = React__default.Children.toArray(children).map((child) => {
    var _a, _b, _c;
    const childIsControlled = ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.selected) !== void 0;
    const childIsSelected = child && childIsControlled ? (_b = child.props) == null ? void 0 : _b.selected : (_c = child.props) == null ? void 0 : _c.defaultSelected;
    return childIsSelected ? child == null ? void 0 : child.props.value : void 0;
  }).filter((v) => v !== void 0);
  return multiple ? selectedValues : selectedValues == null ? void 0 : selectedValues[0];
};
const HvSelectionList = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    children,
    name,
    value: valueProp,
    defaultValue,
    required = false,
    readOnly = false,
    disabled = false,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    orientation = "vertical",
    multiple = false,
    singleSelectionToggle = false,
    ...others
  } = useDefaultProps("HvSelectionList", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const elementId = useUniqueId(id, "hvselectionlist");
  const [value, setValue] = useControlled(valueProp, defaultValue !== void 0 ? defaultValue : (
    // when uncontrolled and no default value is given,
    // extract the initial selected values from the children own state
    () => getValueFromSelectedChildren(children, multiple)
  ));
  const [validationState, setValidationState] = useControlled(status, "standBy");
  const [validationMessage] = useControlled(statusMessage, "Required");
  const [allValues, selectedState] = useMemo(() => {
    const childValues = [];
    const childSelectedState = [];
    React__default.Children.toArray(children).forEach((child, i) => {
      var _a;
      const childValue = (_a = child == null ? void 0 : child.props) == null ? void 0 : _a.value;
      const childIsSelected = multiple ? value.indexOf(childValue) !== -1 : value === childValue;
      childValues[i] = childValue;
      childSelectedState[i] = childIsSelected;
    });
    return [childValues, childSelectedState];
  }, [children, multiple, value]);
  const selectionAnchor = useRef(void 0);
  const listContainer = useRef(null);
  useEffect(() => {
    const handleMeta = (event) => {
      const tempArray = [];
      if (isKey(event, "ArrowUp") && event.shiftKey && listContainer.current.contains(event.target) || isKey(event, "ArrowDown") && event.shiftKey && listContainer.current.contains(event.target)) {
        selectedState.forEach((isSelected, i) => {
          if (i === event.target.value - 1) {
            if (!isSelected) {
              tempArray.push(allValues[i]);
            }
          } else if (isSelected) {
            tempArray.push(allValues[i]);
          }
        });
        setValue(tempArray);
      }
    };
    window.addEventListener("keyup", handleMeta);
    return () => {
      window.removeEventListener("keyup", handleMeta);
    };
  }, [allValues, selectedState, setValue]);
  const onChildChangeInterceptor = useCallback((index, childOnClick, evt) => {
    childOnClick == null ? void 0 : childOnClick(evt);
    if (!readOnly && !disabled) {
      let newValue;
      if (multiple) {
        newValue = multiSelectionEventHandler(evt, index, selectionAnchor, allValues, selectedState, void 0);
      } else {
        newValue = singleSelectionToggle && selectedState[index] ? null : allValues[index];
      }
      onChange == null ? void 0 : onChange(evt, newValue);
      setValue(() => {
        if (required && newValue.length === 0) {
          setValidationState("invalid");
        } else {
          setValidationState("valid");
        }
        return newValue;
      });
    }
  }, [allValues, disabled, multiple, onChange, readOnly, required, selectedState, setValidationState, setValue, singleSelectionToggle, selectionAnchor]);
  const modifiedChildren = useMemo(() => {
    return React__default.Children.map(children, (child, i) => {
      var _a;
      const childIsSelected = selectedState[i];
      return React__default.cloneElement(child, {
        role: "option",
        selected: childIsSelected,
        onClick: (evt) => {
          var _a2;
          return onChildChangeInterceptor(i, (_a2 = child == null ? void 0 : child.props) == null ? void 0 : _a2.onClick, evt);
        },
        disabled: disabled || ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.disabled)
      });
    });
  }, [children, disabled, onChildChangeInterceptor, selectedState]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const errorMessageId = canShowError ? setId(elementId, "error") : ariaErrorMessage;
  const listId = label && setId(elementId, "listbox") || "";
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, status: validationState, disabled, required, readOnly, className: cx(classes.root, className), children: [
    label && /* @__PURE__ */ jsx(HvLabel, { id: setId(elementId, "label"), label, className: classes.label }),
    description && /* @__PURE__ */ jsx(HvInfoMessage, { id: setId(elementId, "description"), className: classes.description, children: description }),
    /* @__PURE__ */ jsx(HvListContainer, { id: listId, interactive: true, condensed: true, role: "listbox", "aria-multiselectable": multiple || void 0, "aria-label": ariaLabel, "aria-labelledby": [label && setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0, "aria-invalid": validationState === "invalid" ? true : void 0, "aria-errormessage": validationState === "invalid" ? errorMessageId : void 0, "aria-describedby": [description && setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, className: cx(classes.listbox, {
      [classes.vertical]: orientation === "vertical",
      [classes.horizontal]: orientation === "horizontal",
      [classes.invalid]: validationState === "invalid"
    }), ref: listContainer, ...others, children: modifiedChildren }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
export {
  HvSelectionList,
  staticClasses as selectionListClasses
};
//# sourceMappingURL=SelectionList.js.map

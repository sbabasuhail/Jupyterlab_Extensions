import { jsx } from "@emotion/react/jsx-runtime";
import { createContext, useState, useContext, useCallback, useMemo, useRef, useEffect } from "react";
import { useEnhancedEffect } from "../../../hooks/useEnhancedEffect.js";
function binaryFindElement(array, element) {
  let start = 0;
  let end = array.length - 1;
  while (start <= end) {
    const middle = Math.floor((start + end) / 2);
    if (array[middle].element === element) {
      return middle;
    }
    if (array[middle].element.compareDocumentPosition(element) && Node.DOCUMENT_POSITION_PRECEDING) {
      end = middle - 1;
    } else {
      start = middle + 1;
    }
  }
  return start;
}
const DescendantContext = createContext({
  level: 0,
  descendants: []
});
if (process.env.NODE_ENV !== "production") {
  DescendantContext.displayName = "DescendantContext";
}
function usePrevious(value) {
  const ref = useRef(null);
  useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
const noop = () => {
};
function useDescendant(descendant) {
  const [, forceUpdate] = useState();
  const {
    registerDescendant = noop,
    unregisterDescendant = noop,
    descendants = [],
    parentId = null,
    level = 0
  } = useContext(DescendantContext);
  const index = descendants.findIndex((item) => item.element === descendant.element);
  const previousDescendants = usePrevious(descendants);
  const someDescendantsHaveChanged = descendants.some((newDescendant, position) => {
    return previousDescendants && previousDescendants[position];
  });
  useEnhancedEffect(() => {
    if (descendant.element) {
      registerDescendant({
        ...descendant,
        index
      });
      return () => {
        unregisterDescendant(descendant.element);
      };
    }
    forceUpdate({});
    return void 0;
  }, [registerDescendant, unregisterDescendant, index, someDescendantsHaveChanged, descendant]);
  return {
    parentId,
    index,
    level
  };
}
const DescendantProvider = (props) => {
  const {
    children,
    id,
    level
  } = props;
  const [items, set] = useState([]);
  const registerDescendant = useCallback(({
    element,
    ...other
  }) => {
    set((oldItems) => {
      let newItems;
      if (oldItems.length === 0) {
        return [{
          ...other,
          element,
          index: 0
        }];
      }
      const index = binaryFindElement(oldItems, element);
      if (oldItems[index] && oldItems[index].element === element) {
        newItems = oldItems;
      } else {
        const newItem = {
          ...other,
          element,
          index
        };
        newItems = oldItems.slice();
        newItems.splice(index, 0, newItem);
      }
      newItems.forEach((item, position) => {
        item.index = position;
      });
      return newItems;
    });
  }, []);
  const unregisterDescendant = useCallback((element) => {
    set((oldItems) => oldItems.filter((item) => element !== item.element));
  }, []);
  const value = useMemo(() => ({
    descendants: items,
    registerDescendant,
    unregisterDescendant,
    parentId: id,
    level
  }), [items, registerDescendant, unregisterDescendant, id, level]);
  return /* @__PURE__ */ jsx(DescendantContext.Provider, { value, children });
};
export {
  DescendantProvider,
  useDescendant
};
//# sourceMappingURL=descendants.js.map

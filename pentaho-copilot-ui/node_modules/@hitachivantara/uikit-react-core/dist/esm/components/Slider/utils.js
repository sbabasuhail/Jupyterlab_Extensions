import { theme } from "@hitachivantara/uikit-styles";
import validationState from "../Forms/FormElement/validationStates.js";
const knobsPositionToScaledValue = (sliderValue, minPointValue, stepValue) => minPointValue + stepValue * sliderValue;
const scaledValueToKnobsPositionValue = (scaledValue, minPointValue, inverseStepValue) => typeof scaledValue === "number" ? Math.floor((scaledValue - minPointValue) * inverseStepValue) : NaN;
const knobsValuesToKnobsPositions = (values, inverseStepValue, minPointValue) => {
  const knobsPositions = [];
  values.forEach((value, index) => {
    knobsPositions[index] = scaledValueToKnobsPositionValue(value, minPointValue, inverseStepValue);
  });
  return knobsPositions;
};
const knobsPositionsToKnobsValues = (knobPositions, stepValue, minPointValue) => {
  const knobsValues = [];
  knobPositions.forEach((value, index) => {
    knobsValues[index] = knobsPositionToScaledValue(value, minPointValue, stepValue);
  });
  return knobsValues;
};
const calculateStepValue = (maxPointValue, minPointValue, divisionQuantity) => Math.abs(maxPointValue - minPointValue) / divisionQuantity;
const createMark = (markProperties, markstep, divisionQuantity, minPointValue, stepValue, markDigits, disabled, styles, formatMark = (mark) => mark) => {
  const marks = {};
  if (markProperties.length > 0) {
    markProperties.forEach((markProperty) => {
      if (typeof markProperty.position === "number") {
        marks[markProperty.position] = disabled ? {
          label: `${markProperty.label}`,
          style: {
            ...styles.disabledMark
          }
        } : {
          label: `${markProperty.label}`,
          style: {
            ...styles.mark
          }
        };
      }
    });
  } else {
    const roundedMarkStep = Math.floor(markstep);
    for (let index = 0; index <= divisionQuantity; index += roundedMarkStep) {
      let labelValue = knobsPositionToScaledValue(index, minPointValue, stepValue).toFixed(markDigits);
      labelValue = (formatMark == null ? void 0 : formatMark(labelValue)) || labelValue;
      marks[index] = disabled ? {
        label: `${labelValue}`,
        style: {
          ...styles.disabledMark
        }
      } : {
        label: `${labelValue}`,
        style: {
          ...styles.mark
        }
      };
    }
  }
  return marks;
};
const createTrackStyles = (knobProperties, styles) => {
  const trackStyles = [];
  if (knobProperties.length > 0) {
    knobProperties.forEach((knobProperty, index) => {
      trackStyles[index] = {
        ...styles.track
      };
      if (knobProperty.color) {
        trackStyles[index].backgroundColor = knobProperty.trackColor;
      }
    });
  }
  return trackStyles;
};
const createKnobStyles = (knobProperties, styles) => {
  const knobInner = [];
  const knobOuterStyle = [];
  const lastItem = knobProperties.length - 1;
  if (knobProperties.length > 0) {
    knobProperties.forEach((knobProperty, index) => {
      knobInner[index] = {
        ...styles.knobInner
      };
      knobOuterStyle[index] = {
        ...styles.knobOuter
      };
      if (knobProperty.color) {
        knobInner[index].backgroundColor = knobProperty.color;
        knobOuterStyle[index].backgroundColor = "transparent";
      }
      if (knobProperty.hidden) {
        knobInner[index] = styles.knobHidden;
        if (index === lastItem) {
          knobInner[index] = {
            ...styles.knobHiddenLast
          };
          knobInner[index].backgroundColor = knobProperty.color;
          knobOuterStyle[index] = {
            ...styles.knobHidden
          };
          knobOuterStyle[index].backgroundColor = knobProperty.color;
        }
      }
    });
  }
  return {
    knobInner,
    knobOuterStyle
  };
};
const isSingleSlider = (values, defaultValues) => {
  if (!((values == null ? void 0 : values.length) > 1)) {
    return defaultValues.length === 1;
  }
  return values.length === 1;
};
const generateDefaultKnobProperties = (numberOfKnobs = 1, disabled = false, knobPropertiesProp) => {
  let knobProperties = knobPropertiesProp || [];
  const defaultKnobStyles = {
    color: theme.colors.secondary,
    hoverColor: theme.colors.secondary,
    trackColor: theme.colors.secondary,
    dragColor: theme.colors.secondary,
    knobRingColor: theme.colors.atmo1
  };
  const disabledKnobStyles = {
    color: theme.colors.secondary_60,
    hoverColor: theme.colors.secondary_60,
    trackColor: theme.colors.secondary_60,
    dragColor: theme.colors.secondary_60,
    knobRingColor: theme.colors.secondary_60
  };
  if (knobProperties.length > 0) {
    knobProperties = knobProperties.slice(0, numberOfKnobs);
    knobProperties = knobProperties.map((knobProperty) => {
      if (!disabled) {
        return {
          ...disabledKnobStyles,
          ...knobProperty
        };
      }
      return {
        ...defaultKnobStyles,
        ...knobProperty
      };
    });
  } else {
    for (let i = 0; i < numberOfKnobs; i += 1) {
      if (!disabled)
        knobProperties.push(defaultKnobStyles);
      if (disabled)
        knobProperties.push(disabledKnobStyles);
    }
  }
  return knobProperties;
};
const pushSlider = (index, inputIndex, inputValue) => {
  const difference = index - inputIndex;
  return inputValue + difference;
};
const ensureValuesConsistency = (knobPositions, inputIndex) => {
  const newKnobsPosition = [...knobPositions];
  newKnobsPosition.forEach((value, index) => {
    if (Number.isNaN(value) || value == null) {
      newKnobsPosition[index] = pushSlider(index, inputIndex, newKnobsPosition[inputIndex]);
    } else if (index < inputIndex && value > newKnobsPosition[inputIndex]) {
      newKnobsPosition[index] = pushSlider(index, inputIndex, newKnobsPosition[inputIndex]);
    } else if (index > inputIndex && value < newKnobsPosition[inputIndex]) {
      newKnobsPosition[index] = pushSlider(index, inputIndex, newKnobsPosition[inputIndex]);
    }
  });
  return newKnobsPosition;
};
const convertStatusToArray = (length, status) => {
  const result = {
    arrayDefaultStatus: Array.from({
      length
    }, () => validationState.standBy)
  };
  if (status == null) {
    return result;
  }
  if (!Array.isArray(status)) {
    result.arrayStatus = Array.from({
      length
    }, () => status);
    return result;
  }
  result.arrayStatus = status;
  return result;
};
const statusArrayToFormStatus = (arrayStatus) => {
  const invalid = arrayStatus.some((status) => status === validationState.invalid);
  if (invalid)
    return validationState.invalid;
  const valid = arrayStatus.some((status) => status === validationState.valid);
  if (valid)
    return validationState.valid;
  return validationState.standBy;
};
const knobsValuesToString = (knobsValues, markDigits) => knobsValues.map((knobValue) => Number.isNaN(knobValue) ? "" : knobValue.toFixed(markDigits));
const stringValuesToKnobs = (inputsValues) => inputsValues.map((inputValue) => parseFloat(inputValue));
export {
  calculateStepValue,
  convertStatusToArray,
  createKnobStyles,
  createMark,
  createTrackStyles,
  ensureValuesConsistency,
  generateDefaultKnobProperties,
  isSingleSlider,
  knobsPositionToScaledValue,
  knobsPositionsToKnobsValues,
  knobsValuesToKnobsPositions,
  knobsValuesToString,
  scaledValueToKnobsPositionValue,
  statusArrayToFormStatus,
  stringValuesToKnobs
};
//# sourceMappingURL=utils.js.map

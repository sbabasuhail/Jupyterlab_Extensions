import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import Slider from "rc-slider";
import { useRef, useMemo, useState, useCallback, useEffect } from "react";
import Tooltip from "rc-tooltip";
import { setId } from "../../utils/setId.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useControlled } from "../../hooks/useControlled.js";
import validationState from "../Forms/FormElement/validationStates.js";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { useClasses, sliderStyles } from "./Slider.styles.js";
import { staticClasses } from "./Slider.styles.js";
import { calculateStepValue, createMark, isSingleSlider, knobsValuesToKnobsPositions, convertStatusToArray, generateDefaultKnobProperties, createTrackStyles, createKnobStyles, statusArrayToFormStatus, knobsPositionsToKnobsValues, scaledValueToKnobsPositionValue, ensureValuesConsistency, knobsPositionToScaledValue } from "./utils.js";
import { HvSliderInput } from "./SliderInput/SliderInput.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
const HvSlider = (props) => {
  const {
    id,
    className,
    name,
    label,
    status,
    statusMessage,
    disabled,
    classes: classesProp,
    sliderProps,
    knobProps,
    inputProps,
    requiredMessage = "The value is required",
    noOverlap = true,
    hideInput = false,
    required = false,
    readOnly = false,
    markProperties = [],
    defaultValues = [void 0],
    values: valuesProp = [],
    knobProperties: knobPropertiesProp,
    "aria-errormessage": ariaErrorMessage,
    maxPointValue = 100,
    minPointValue = 0,
    divisionQuantity = 100,
    markStep = 20,
    markDigits = 0,
    formatMark,
    onChange,
    onBlur,
    onBeforeChange,
    onAfterChange,
    formatTooltip,
    ...others
  } = useDefaultProps("HvSlider", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const hasLabel = label != null;
  const isDirty = useRef(false);
  const elementId = useUniqueId(id, "hvSlider");
  const sliderInputId = setId(elementId, "input");
  const stepValue = useMemo(() => calculateStepValue(maxPointValue, minPointValue, divisionQuantity), [divisionQuantity, maxPointValue, minPointValue]);
  const inverseStepValue = 1 / stepValue;
  const marks = useMemo(() => createMark(markProperties, markStep, divisionQuantity, minPointValue, stepValue, markDigits, !!disabled, sliderStyles, formatMark), [disabled, divisionQuantity, formatMark, markDigits, markProperties, markStep, minPointValue, stepValue]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const isSingle = useMemo(() => isSingleSlider(valuesProp, defaultValues), [defaultValues, valuesProp]);
  const value = useMemo(() => (valuesProp == null ? void 0 : valuesProp.length) > 0 ? knobsValuesToKnobsPositions(valuesProp, inverseStepValue, minPointValue) : void 0, [inverseStepValue, minPointValue, valuesProp]);
  const defaultKnobsPositions = useMemo(() => knobsValuesToKnobsPositions(defaultValues, inverseStepValue, minPointValue), [defaultValues, inverseStepValue, minPointValue]);
  const [knobsPositions, setKnobsPositions] = useControlled(value, defaultKnobsPositions);
  const {
    arrayStatus,
    arrayDefaultStatus
  } = useMemo(() => convertStatusToArray(knobsPositions.length, status), [knobsPositions.length, status]);
  const [validationStatus, setValidationState] = useControlled(arrayStatus, arrayDefaultStatus);
  const [validationMessage, setValidationMessage] = useControlled(statusMessage, "");
  const [isDraggingTrack, setIsDraggingTrack] = useState(false);
  const knobProperties = generateDefaultKnobProperties(knobsPositions.length, disabled, knobPropertiesProp);
  const rangesCount = knobProperties.length - 1;
  const trackStyles = createTrackStyles(knobProperties, sliderStyles);
  const knobStyles = createKnobStyles(knobProperties, sliderStyles);
  const performValidation = useCallback(() => {
    let invalid = false;
    const newValidationState = knobsPositions.map((position) => {
      if (position == null || Number.isNaN(position)) {
        invalid = true;
        return validationState.invalid;
      }
      return validationState.valid;
    });
    setValidationState([...newValidationState]);
    if (invalid) {
      setValidationMessage(requiredMessage);
      return;
    }
    setValidationMessage("");
  }, [knobsPositions, requiredMessage, setValidationMessage, setValidationState]);
  useEffect(() => {
    const stepVl = calculateStepValue(maxPointValue, minPointValue, divisionQuantity);
    const inverseStepVl = 1 / stepVl;
    if ((valuesProp == null ? void 0 : valuesProp.length) > 0) {
      setKnobsPositions(knobsValuesToKnobsPositions(valuesProp.length > 0 ? valuesProp : defaultValues, inverseStepVl, minPointValue));
    }
  }, [defaultValues, divisionQuantity, maxPointValue, minPointValue, setKnobsPositions, valuesProp]);
  useEffect(() => {
    if (!isDirty.current) {
      return;
    }
    performValidation();
  }, [knobsPositions, requiredMessage, performValidation]);
  const onMouseDownHandler = (event) => {
    if (event.target.className.includes("track")) {
      setIsDraggingTrack(true);
    }
  };
  const onMouseUpHandler = () => {
    setIsDraggingTrack(false);
  };
  const generateKnobsPositionAndValues = (knobsCurrentPosition) => {
    const newKnobsPosition = knobsCurrentPosition.slice();
    const knobsValues = [];
    let duplicatedValue = null;
    const findDuplicated = newKnobsPosition.filter((item, index) => newKnobsPosition.indexOf(item) !== index);
    if (noOverlap && findDuplicated.length > 0) {
      [duplicatedValue] = findDuplicated;
    }
    newKnobsPosition.forEach((position, index, array) => {
      const newArray = array;
      let newPosition = position;
      if (noOverlap && newPosition === duplicatedValue) {
        const previousValue = knobsPositions[index];
        if (previousValue !== newPosition) {
          newPosition += newPosition > previousValue ? -1 : 1;
          newArray[index] = newPosition;
        }
      }
      knobsValues[index] = knobsPositionToScaledValue(newPosition, minPointValue, stepValue);
    }, void 0);
    return {
      knobsPosition: newKnobsPosition,
      knobsValues
    };
  };
  const onBlurHandler = (event) => {
    const knobs = generateKnobsPositionAndValues(knobsPositions);
    performValidation();
    onBlur == null ? void 0 : onBlur(event, knobs.knobsValues, status);
  };
  const onChangeHandler = (knobsPosition) => {
    isDirty.current = true;
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    knobProperties.forEach((knobProperty, index) => {
      if (knobProperty.fixed) {
        knobs.knobsPosition[index] = scaledValueToKnobsPositionValue(defaultValues[index], minPointValue, inverseStepValue);
      }
    });
    if (disabled || readOnly)
      return;
    onChange == null ? void 0 : onChange(knobs.knobsValues);
    setKnobsPositions(knobs.knobsPosition);
  };
  const onInputChangeHandler = (inputValues, index) => {
    let newKnobPositions = knobsValuesToKnobsPositions(inputValues, inverseStepValue, minPointValue);
    newKnobPositions = ensureValuesConsistency(newKnobPositions, index);
    onChangeHandler(newKnobPositions);
  };
  const onBeforeChangeHandler = (knobsPosition) => {
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    onBeforeChange == null ? void 0 : onBeforeChange(knobs.knobsValues);
  };
  const onAfterChangeHandler = (knobsPosition) => {
    const knobs = generateKnobsPositionAndValues(knobsPosition);
    onAfterChange == null ? void 0 : onAfterChange(knobs.knobsValues);
  };
  const createKnob = (knobNode, params) => {
    var _a, _b;
    const {
      value: knobValue,
      dragging,
      index
    } = params;
    const {
      className: knobClassName,
      style,
      ...restProps
    } = knobNode.props;
    const scaledKnobValue = knobsPositionToScaledValue(knobValue, minPointValue, stepValue).toFixed(markDigits);
    if (dragging) {
      style.backgroundColor = (_a = knobProperties[index]) == null ? void 0 : _a.dragColor;
    } else {
      style.backgroundColor = (_b = knobProperties[index]) == null ? void 0 : _b.color;
    }
    const isEmpty = Number.isNaN(knobsPositions[index]) || knobsPositions[index] == null;
    const handleId = setId(elementId, "knob");
    const indexedHandleId = setId(handleId, index);
    return /* @__PURE__ */ jsx("div", { className: cx({
      [classes.handleContainer]: !!(!disabled && !isEmpty),
      [classes.handleContainerDisabled]: !!(disabled && !isEmpty),
      [classes.handleHiddenContainer]: isEmpty || readOnly
    }), children: /* @__PURE__ */ jsx(Tooltip, { prefixCls: "rc-slider-tooltip", overlay: (formatTooltip == null ? void 0 : formatTooltip(scaledKnobValue)) || scaledKnobValue, visible: dragging, placement: "top", overlayClassName: classes.sliderTooltip, getTooltipContainer: () => document.getElementById(indexedHandleId || ""), children: /* @__PURE__ */ jsx("div", { id: indexedHandleId, style, className: cx(knobClassName, classes.handle), ...restProps, "aria-label": `${label}-knob-${index}`, "aria-valuenow": knobsPositionToScaledValue(knobValue, minPointValue, stepValue), "aria-valuemin": minPointValue, "aria-valuemax": maxPointValue, ...knobProps == null ? void 0 : knobProps[index] }) }) }, index);
  };
  return /* @__PURE__ */ jsxs(HvFormElement, { className: cx(classes.root, {
    [classes.trackStandBy]: !readOnly && !disabled && !isSingle && !isDraggingTrack,
    [classes.trackDragging]: !readOnly && !disabled && !isSingle && isDraggingTrack,
    [classes.rootDisabled]: !!disabled
  }, className), id, name, status: statusArrayToFormStatus(validationStatus), disabled, required, readOnly, onMouseDown: onMouseDownHandler, onMouseUp: onMouseUpHandler, onBlur: onBlurHandler, ...others, children: [
    (hasLabel || !hideInput) && /* @__PURE__ */ jsxs("div", { className: cx(classes.labelContainer, {
      [classes.labelIncluded]: hasLabel,
      [classes.onlyInput]: !hasLabel
    }), children: [
      hasLabel && /* @__PURE__ */ jsx(HvLabel, { id: setId(elementId, "label"), className: classes.label, htmlFor: setId(elementId, "slider"), label }),
      !hideInput && /* @__PURE__ */ jsx(HvSliderInput, { id: sliderInputId, label, values: knobsPositionsToKnobsValues(knobsPositions, stepValue, minPointValue), onChange: onInputChangeHandler, status: validationStatus, disabled, readOnly, markDigits, inputProps })
    ] }),
    /* @__PURE__ */ jsxs("div", { className: cx(classes.sliderBase, classes.sliderContainer), children: [
      isSingle && /* @__PURE__ */ jsx(Slider, { handleRender: createKnob, className: classes.sliderRoot, min: 0, max: divisionQuantity, step: 1, marks, dotStyle: disabled ? sliderStyles.dotDisabled : sliderStyles.dot, onChange: (singleValue) => onChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onBeforeChange: (singleValue) => onBeforeChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onAfterChange: (singleValue) => onAfterChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), value: knobsPositions.length > 0 ? knobsPositions[0] : void 0, allowCross: false, disabled, count: rangesCount, railStyle: sliderStyles.rail, handleStyle: knobStyles.knobInner, trackStyle: trackStyles, ...sliderProps }),
      !isSingle && /* @__PURE__ */ jsx(Slider, { range: true, handleRender: createKnob, className: cx(classes.sliderRoot, {
        [classes.rootRange]: !isSingle
      }), min: 0, max: divisionQuantity, step: 1, marks, disabled, dotStyle: disabled ? sliderStyles.dotDisabled : sliderStyles.dot, onChange: (singleValue) => onChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onBeforeChange: (singleValue) => onBeforeChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), onAfterChange: (singleValue) => onAfterChangeHandler(Array.isArray(singleValue) ? singleValue : [singleValue]), value: knobsPositions.length > 0 ? [...knobsPositions] : void 0, allowCross: false, count: rangesCount, railStyle: sliderStyles.rail, handleStyle: knobStyles.knobInner, trackStyle: trackStyles, draggableTrack: !readOnly && !isSingle, ...sliderProps })
    ] }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), className: classes.error, disableBorder: true, children: validationMessage })
  ] });
};
export {
  HvSlider,
  staticClasses as sliderClasses
};
//# sourceMappingURL=Slider.js.map

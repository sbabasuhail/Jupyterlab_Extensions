{"version":3,"file":"Slider.js","sources":["../../../../src/components/Slider/Slider.tsx"],"sourcesContent":["import Slider, { SliderProps } from \"rc-slider\";\n\nimport React, {\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n} from \"react\";\n\nimport Tooltip from \"rc-tooltip\";\n\nimport { HvBaseProps } from \"@core/types/generic\";\nimport { setId } from \"@core/utils/setId\";\nimport { useUniqueId } from \"@core/hooks/useUniqueId\";\nimport { useControlled } from \"@core/hooks/useControlled\";\nimport validationStates from \"@core/components/Forms/FormElement/validationStates\";\nimport { HvInputProps } from \"@core/components/Input\";\nimport {\n  HvFormElement,\n  HvFormStatus,\n  HvLabel,\n  HvWarningText,\n} from \"@core/components/Forms\";\nimport { ExtractNames } from \"@core/utils/classes\";\nimport { useDefaultProps } from \"@core/hooks/useDefaultProps\";\n\nimport { sliderStyles, staticClasses, useClasses } from \"./Slider.styles\";\nimport {\n  calculateStepValue,\n  convertStatusToArray,\n  createKnobStyles,\n  createMark,\n  createTrackStyles,\n  ensureValuesConsistency,\n  generateDefaultKnobProperties,\n  isSingleSlider,\n  knobsPositionsToKnobsValues,\n  knobsPositionToScaledValue,\n  knobsValuesToKnobsPositions,\n  scaledValueToKnobsPositionValue,\n  statusArrayToFormStatus,\n} from \"./utils\";\nimport { HvSliderInput } from \"./SliderInput/SliderInput\";\nimport { HvKnobProperty, HvMarkProperty } from \"./types\";\n\nexport { staticClasses as sliderClasses };\n\nexport type HvSliderClasses = ExtractNames<typeof useClasses>;\n\nexport interface HvSliderProps\n  extends HvBaseProps<HTMLDivElement, \"onChange\" | \"onBlur\"> {\n  /**\n   * The slider name.\n   */\n  name?: string;\n  /**\n   * The label of the slider.\n   *\n   * If not provided, an aria-label or aria-labelledby must be inputted via sliderProps.\n   */\n  label?: React.ReactNode;\n  /**\n   * Indicates that the slider is disabled.\n   */\n  disabled?: boolean;\n  /**\n   * Indicates that the slider is not editable.\n   */\n  readOnly?: boolean;\n  /**\n   * Indicates that user slider is required on the form element.\n   */\n  required?: boolean;\n  /**\n   * What message to render when the value is required.\n   */\n  requiredMessage?: string;\n  /**\n   * If `true` the input that controls the slider is hidden.\n   */\n  hideInput?: boolean;\n  /**\n   * Attributes applied to the slider element.\n   */\n  sliderProps?: SliderProps;\n  /**\n   * The status of the slider element.\n   *\n   * Valid is correct, invalid is incorrect and standBy means no validations have run.\n   *\n   * When uncontrolled and unspecified it will default to \"standBy\" and change to either \"valid\"\n   * or \"invalid\" after any change to the state.\n   */\n  status?: HvFormStatus | HvFormStatus[];\n  /**\n   * The error message to show when `status` is \"invalid\".\n   */\n  statusMessage?: React.ReactNode;\n  /**\n   * The values array to apply to the component\n   */\n  values?: number[];\n  /**\n   * The default values array to apply to the component\n   */\n  defaultValues?: (number | undefined)[];\n  /**\n   * The object used to set the knob properties,\n   * for every item in the array a new knob will be created.\n   */\n  knobProperties?: HvKnobProperty[];\n  /**\n   * The object used to set the mark properties individually.\n   */\n  markProperties?: HvMarkProperty[];\n  /**\n   * The function executed before a change will occur in the slider.\n   */\n  onBeforeChange?: (value: number[]) => void;\n  /**\n   * The function executed while a change is occurring in the slider.\n   */\n  onChange?: (value: number[]) => void;\n  /**\n   * The function executed after a change ocurred in the slider.\n   */\n  onAfterChange?: (value: number[]) => void;\n  /**\n   * The function executed after a blur ocurred in the slider.\n   */\n  onBlur?: (\n    event: React.FocusEvent,\n    knobsValues: number[],\n    status?: HvFormStatus | HvFormStatus[]\n  ) => void;\n  /**\n   * The separation in points between marks.\n   * example: if 10 divisions and a markstep of 2 there will be 5 marks.\n   */\n  markStep?: number;\n  /**\n   * How many subdivisions there are in the slider.\n   */\n  divisionQuantity?: number;\n  /**\n   * The value of the first point in the slider from left to right.\n   */\n  minPointValue?: number;\n  /**\n   * The value of the last point in the slider from left to right.\n   */\n  maxPointValue?: number;\n  /**\n   * The nax number of decimals if no format function is applied\n   */\n  markDigits?: number;\n  /**\n   * A formatting function used to add format to the marks in the track,\n   * the function receives the mark text\n   */\n  formatMark?: (label: React.ReactNode) => React.ReactNode;\n  /**\n   * A formatting function used to add format to the tooltip in the track,\n   * the function receives the mark text\n   */\n  formatTooltip?: (label: React.ReactNode) => React.ReactNode;\n  /**\n   * If `true` the knobs can't have the same value, if `false` knobs can have the same value.\n   */\n  noOverlap?: boolean;\n  /**\n   * Attributes applied to the input element.\n   */\n  inputProps?: HvInputProps[];\n  /**\n   * Attributes applied to the knob element.\n   */\n  knobProps?: React.HTMLAttributes<HTMLDivElement>[];\n  /**\n   * The classes object to be applied into the root object.\n   */\n  classes?: HvSliderClasses;\n}\n\n/**\n * Sliders reflect a range of values along a bar, from which users may select a single value. They are ideal for adjusting settings such as volume, brightness, or applying image filters.\n */\nexport const HvSlider = (props: HvSliderProps) => {\n  const {\n    id,\n    className,\n    name,\n    label,\n    status,\n    statusMessage,\n    disabled,\n    classes: classesProp,\n    sliderProps,\n    knobProps,\n    inputProps,\n    requiredMessage = \"The value is required\",\n    noOverlap = true,\n    hideInput = false,\n    required = false,\n    readOnly = false,\n    markProperties = [],\n    defaultValues = [undefined],\n    values: valuesProp = [],\n    knobProperties: knobPropertiesProp,\n    \"aria-errormessage\": ariaErrorMessage,\n    maxPointValue = 100,\n    minPointValue = 0,\n    divisionQuantity = 100,\n    markStep = 20,\n    markDigits = 0,\n    formatMark,\n    onChange,\n    onBlur,\n    onBeforeChange,\n    onAfterChange,\n    formatTooltip,\n    ...others\n  } = useDefaultProps(\"HvSlider\", props);\n\n  const { classes, cx } = useClasses(classesProp);\n\n  // Miscellaneous state\n  const hasLabel = label != null;\n\n  // Signals that the user has manually edited the input value\n  const isDirty = useRef(false);\n\n  const elementId = useUniqueId(id, \"hvSlider\");\n\n  const sliderInputId = setId(elementId, \"input\");\n\n  const stepValue: number = useMemo(\n    () => calculateStepValue(maxPointValue, minPointValue, divisionQuantity),\n    [divisionQuantity, maxPointValue, minPointValue]\n  );\n\n  const inverseStepValue: number = 1 / stepValue;\n\n  const marks = useMemo(\n    () =>\n      createMark(\n        markProperties,\n        markStep,\n        divisionQuantity,\n        minPointValue,\n        stepValue,\n        markDigits,\n        !!disabled,\n        sliderStyles,\n        formatMark\n      ),\n    [\n      disabled,\n      divisionQuantity,\n      formatMark,\n      markDigits,\n      markProperties,\n      markStep,\n      minPointValue,\n      stepValue,\n    ]\n  );\n\n  const canShowError =\n    ariaErrorMessage == null &&\n    ((status !== undefined && statusMessage !== undefined) ||\n      (status === undefined && required));\n\n  const isSingle: boolean = useMemo(\n    () => isSingleSlider(valuesProp, defaultValues),\n    [defaultValues, valuesProp]\n  );\n\n  const value: number[] | undefined = useMemo(\n    () =>\n      valuesProp?.length > 0\n        ? knobsValuesToKnobsPositions(\n            valuesProp,\n            inverseStepValue,\n            minPointValue\n          )\n        : undefined,\n    [inverseStepValue, minPointValue, valuesProp]\n  );\n\n  const defaultKnobsPositions: number[] = useMemo(\n    () =>\n      knobsValuesToKnobsPositions(\n        defaultValues,\n        inverseStepValue,\n        minPointValue\n      ),\n    [defaultValues, inverseStepValue, minPointValue]\n  );\n\n  const [knobsPositions, setKnobsPositions] = useControlled(\n    value,\n    defaultKnobsPositions\n  );\n\n  // Validation related state\n  const { arrayStatus, arrayDefaultStatus } = useMemo(\n    () => convertStatusToArray(knobsPositions.length, status),\n    [knobsPositions.length, status]\n  );\n\n  const [validationStatus, setValidationState] = useControlled(\n    arrayStatus,\n    arrayDefaultStatus\n  );\n\n  const [validationMessage, setValidationMessage] = useControlled(\n    statusMessage,\n    \"\"\n  );\n\n  const [isDraggingTrack, setIsDraggingTrack] = useState<boolean>(false);\n\n  const knobProperties: HvKnobProperty[] = generateDefaultKnobProperties(\n    knobsPositions.length,\n    disabled,\n    knobPropertiesProp\n  );\n\n  const rangesCount = knobProperties.length - 1;\n\n  const trackStyles = createTrackStyles(knobProperties, sliderStyles);\n\n  const knobStyles = createKnobStyles(knobProperties, sliderStyles);\n\n  const performValidation = useCallback(() => {\n    let invalid: boolean = false;\n\n    const newValidationState = knobsPositions.map((position) => {\n      if (position == null || Number.isNaN(position)) {\n        invalid = true;\n        return validationStates.invalid;\n      }\n      return validationStates.valid;\n    });\n\n    setValidationState([...newValidationState]);\n\n    if (invalid) {\n      setValidationMessage(requiredMessage);\n      return;\n    }\n\n    setValidationMessage(\"\");\n  }, [\n    knobsPositions,\n    requiredMessage,\n    setValidationMessage,\n    setValidationState,\n  ]);\n\n  useEffect(() => {\n    const stepVl = calculateStepValue(\n      maxPointValue,\n      minPointValue,\n      divisionQuantity\n    );\n\n    const inverseStepVl = 1 / stepVl;\n\n    if (valuesProp?.length > 0) {\n      setKnobsPositions(\n        knobsValuesToKnobsPositions(\n          valuesProp.length > 0 ? valuesProp : defaultValues,\n          inverseStepVl,\n          minPointValue\n        )\n      );\n    }\n  }, [\n    defaultValues,\n    divisionQuantity,\n    maxPointValue,\n    minPointValue,\n    setKnobsPositions,\n    valuesProp,\n  ]);\n\n  useEffect(() => {\n    if (!isDirty.current) {\n      // Skip validation if currently focused or if empty and\n      // the user never manually edited the input value\n      return;\n    }\n\n    performValidation();\n  }, [knobsPositions, requiredMessage, performValidation]);\n\n  const onMouseDownHandler = (event: React.MouseEvent<HTMLDivElement>) => {\n    if ((event.target as HTMLDivElement).className.includes(\"track\")) {\n      setIsDraggingTrack(true);\n    }\n  };\n\n  const onMouseUpHandler = () => {\n    setIsDraggingTrack(false);\n  };\n\n  /**\n   * Generates an object which posses the current value and position of the knobs.\n   *\n   * @param {Array} knobsCurrentPosition - An array containing the current positions of the knobs.\n   * @returns {Object} - An object with the positions and values of the knobs.\n   * @memberof HvSlider\n   */\n  const generateKnobsPositionAndValues = (\n    knobsCurrentPosition: number[]\n  ): { knobsPosition: number[]; knobsValues: number[] } => {\n    const newKnobsPosition: number[] = knobsCurrentPosition.slice();\n    const knobsValues: number[] = [];\n\n    let duplicatedValue: number | null = null;\n\n    const findDuplicated: number[] = newKnobsPosition.filter(\n      (item, index) => newKnobsPosition.indexOf(item) !== index\n    );\n\n    if (noOverlap && findDuplicated.length > 0) {\n      [duplicatedValue] = findDuplicated;\n    }\n\n    newKnobsPosition.forEach((position, index, array) => {\n      const newArray: number[] = array;\n      let newPosition: number = position;\n\n      if (noOverlap && newPosition === duplicatedValue) {\n        const previousValue = knobsPositions[index];\n        if (previousValue !== newPosition) {\n          newPosition += newPosition > previousValue ? -1 : 1;\n          newArray[index] = newPosition;\n        }\n      }\n\n      knobsValues[index] = knobsPositionToScaledValue(\n        newPosition,\n        minPointValue,\n        stepValue\n      );\n    }, this);\n\n    return {\n      knobsPosition: newKnobsPosition,\n      knobsValues,\n    };\n  };\n\n  const onBlurHandler = (event: React.FocusEvent) => {\n    const knobs = generateKnobsPositionAndValues(knobsPositions);\n\n    performValidation();\n\n    onBlur?.(event, knobs.knobsValues, status);\n  };\n\n  /**\n   * Function executed while the knobs changes.\n   *\n   * executes the callback provided by the user with the values and position of the knobs,\n   * also lock the value of the knob in case one is fixed.\n   *\n   * @param {Array} knobsPosition - An array containing the current positions of the knobs.\n   * @memberof HvSlider\n   */\n  const onChangeHandler = (knobsPosition: number[]) => {\n    isDirty.current = true;\n\n    const knobs = generateKnobsPositionAndValues(knobsPosition);\n\n    knobProperties.forEach((knobProperty, index) => {\n      if (knobProperty.fixed) {\n        knobs.knobsPosition[index] = scaledValueToKnobsPositionValue(\n          defaultValues[index],\n          minPointValue,\n          inverseStepValue\n        );\n      }\n    });\n\n    if (disabled || readOnly) return;\n\n    onChange?.(knobs.knobsValues);\n\n    setKnobsPositions(knobs.knobsPosition);\n  };\n\n  const onInputChangeHandler = (inputValues: number[], index: number) => {\n    let newKnobPositions = knobsValuesToKnobsPositions(\n      inputValues,\n      inverseStepValue,\n      minPointValue\n    );\n\n    newKnobPositions = ensureValuesConsistency(newKnobPositions, index);\n\n    onChangeHandler(newKnobPositions);\n  };\n\n  /**\n   * Function executed before a change.\n   *\n   * executes the callback provided by the user with the values and position of the knobs\n   *\n   * @param {Array} knobsPosition - An array containing the current positions of the knobs.\n   * @memberof HvSlider\n   */\n  const onBeforeChangeHandler = (knobsPosition: number[]) => {\n    const knobs = generateKnobsPositionAndValues(knobsPosition);\n\n    onBeforeChange?.(knobs.knobsValues);\n  };\n\n  /**\n   * Function executed after a change.\n   *\n   * executes the callback provided by the user with the values and position of the knobs\n   *\n   * @param {Array} knobsPosition - An array containing the current positions of the knobs.\n   * @memberof HvSlider\n   */\n  const onAfterChangeHandler = (knobsPosition: number[]) => {\n    const knobs = generateKnobsPositionAndValues(knobsPosition);\n\n    onAfterChange?.(knobs.knobsValues);\n  };\n\n  /**\n   * Function used to create a custom knob for the slider.\n   *\n   * TODO: This should be isolated because is creating a sub component,\n   * but there were some problems regarding the underlying component losing\n   * references of the handlers disabling the focus.\n   *\n   * @param {Object} props - An object containing the properties of the knobs.\n   * @memberof HvSlider\n   */\n  const createKnob = (knobNode, params) => {\n    const { value: knobValue, dragging, index } = params;\n    const { className: knobClassName, style, ...restProps } = knobNode.props;\n    const scaledKnobValue = knobsPositionToScaledValue(\n      knobValue,\n      minPointValue,\n      stepValue\n    ).toFixed(markDigits);\n    if (dragging) {\n      style.backgroundColor = knobProperties[index]?.dragColor;\n    } else {\n      style.backgroundColor = knobProperties[index]?.color;\n    }\n\n    const isEmpty =\n      Number.isNaN(knobsPositions[index]) || knobsPositions[index] == null;\n    const handleId = setId(elementId, \"knob\");\n    const indexedHandleId = setId(handleId, index);\n\n    return (\n      <div\n        key={index}\n        className={cx({\n          [classes.handleContainer]: !!(!disabled && !isEmpty),\n          [classes.handleContainerDisabled]: !!(disabled && !isEmpty),\n          [classes.handleHiddenContainer]: isEmpty || readOnly,\n        })}\n      >\n        <Tooltip\n          prefixCls=\"rc-slider-tooltip\"\n          overlay={formatTooltip?.(scaledKnobValue) || scaledKnobValue}\n          visible={dragging}\n          placement=\"top\"\n          overlayClassName={classes.sliderTooltip}\n          getTooltipContainer={() =>\n            document.getElementById(indexedHandleId || \"\") as HTMLElement\n          }\n        >\n          <div\n            id={indexedHandleId}\n            style={style}\n            className={cx(knobClassName, classes.handle)}\n            {...restProps}\n            aria-label={`${label}-knob-${index}`}\n            aria-valuenow={knobsPositionToScaledValue(\n              knobValue,\n              minPointValue,\n              stepValue\n            )}\n            aria-valuemin={minPointValue}\n            aria-valuemax={maxPointValue}\n            {...knobProps?.[index]}\n          />\n        </Tooltip>\n      </div>\n    );\n  };\n\n  return (\n    <HvFormElement\n      className={cx(\n        classes.root,\n        {\n          [classes.trackStandBy]:\n            !readOnly && !disabled && !isSingle && !isDraggingTrack,\n          [classes.trackDragging]:\n            !readOnly && !disabled && !isSingle && isDraggingTrack,\n          [classes.rootDisabled]: !!disabled,\n        },\n        className\n      )}\n      id={id}\n      name={name}\n      status={statusArrayToFormStatus(validationStatus)}\n      disabled={disabled}\n      required={required}\n      readOnly={readOnly}\n      onMouseDown={onMouseDownHandler}\n      onMouseUp={onMouseUpHandler}\n      onBlur={onBlurHandler}\n      {...others}\n    >\n      {(hasLabel || !hideInput) && (\n        <div\n          className={cx(classes.labelContainer, {\n            [classes.labelIncluded]: hasLabel,\n            [classes.onlyInput]: !hasLabel,\n          })}\n        >\n          {hasLabel && (\n            <HvLabel\n              id={setId(elementId, \"label\")}\n              className={classes.label}\n              htmlFor={setId(elementId, \"slider\")}\n              label={label}\n            />\n          )}\n\n          {!hideInput && (\n            <HvSliderInput\n              id={sliderInputId}\n              label={label}\n              values={knobsPositionsToKnobsValues(\n                knobsPositions,\n                stepValue,\n                minPointValue\n              )}\n              onChange={onInputChangeHandler}\n              status={validationStatus}\n              disabled={disabled}\n              readOnly={readOnly}\n              markDigits={markDigits}\n              inputProps={inputProps}\n            />\n          )}\n        </div>\n      )}\n\n      <div className={cx(classes.sliderBase, classes.sliderContainer)}>\n        {isSingle && (\n          <Slider\n            handleRender={createKnob}\n            className={classes.sliderRoot}\n            min={0}\n            max={divisionQuantity}\n            step={1}\n            marks={marks}\n            dotStyle={disabled ? sliderStyles.dotDisabled : sliderStyles.dot}\n            onChange={(singleValue) =>\n              onChangeHandler(\n                Array.isArray(singleValue) ? singleValue : [singleValue]\n              )\n            }\n            onBeforeChange={(singleValue) =>\n              onBeforeChangeHandler(\n                Array.isArray(singleValue) ? singleValue : [singleValue]\n              )\n            }\n            onAfterChange={(singleValue) =>\n              onAfterChangeHandler(\n                Array.isArray(singleValue) ? singleValue : [singleValue]\n              )\n            }\n            value={knobsPositions.length > 0 ? knobsPositions[0] : undefined}\n            allowCross={false}\n            disabled={disabled}\n            count={rangesCount}\n            railStyle={sliderStyles.rail}\n            handleStyle={knobStyles.knobInner}\n            trackStyle={trackStyles}\n            {...sliderProps}\n          />\n        )}\n        {!isSingle && (\n          <Slider\n            range\n            handleRender={createKnob}\n            className={cx(classes.sliderRoot, {\n              [classes.rootRange]: !isSingle,\n            })}\n            min={0}\n            max={divisionQuantity}\n            step={1}\n            marks={marks}\n            disabled={disabled}\n            dotStyle={disabled ? sliderStyles.dotDisabled : sliderStyles.dot}\n            onChange={(singleValue) =>\n              onChangeHandler(\n                Array.isArray(singleValue) ? singleValue : [singleValue]\n              )\n            }\n            onBeforeChange={(singleValue) =>\n              onBeforeChangeHandler(\n                Array.isArray(singleValue) ? singleValue : [singleValue]\n              )\n            }\n            onAfterChange={(singleValue) =>\n              onAfterChangeHandler(\n                Array.isArray(singleValue) ? singleValue : [singleValue]\n              )\n            }\n            value={knobsPositions.length > 0 ? [...knobsPositions] : undefined}\n            allowCross={false}\n            count={rangesCount}\n            railStyle={sliderStyles.rail}\n            handleStyle={knobStyles.knobInner}\n            trackStyle={trackStyles}\n            draggableTrack={!readOnly && !isSingle}\n            {...sliderProps}\n          />\n        )}\n      </div>\n\n      {canShowError && (\n        <HvWarningText\n          id={setId(elementId, \"error\")}\n          className={classes.error}\n          disableBorder\n        >\n          {validationMessage}\n        </HvWarningText>\n      )}\n    </HvFormElement>\n  );\n};\n"],"names":["HvSlider","props","id","className","name","label","status","statusMessage","disabled","classes","classesProp","sliderProps","knobProps","inputProps","requiredMessage","noOverlap","hideInput","required","readOnly","markProperties","defaultValues","undefined","values","valuesProp","knobProperties","knobPropertiesProp","ariaErrorMessage","maxPointValue","minPointValue","divisionQuantity","markStep","markDigits","formatMark","onChange","onBlur","onBeforeChange","onAfterChange","formatTooltip","others","useDefaultProps","cx","useClasses","hasLabel","isDirty","useRef","elementId","useUniqueId","sliderInputId","setId","stepValue","useMemo","calculateStepValue","inverseStepValue","marks","createMark","sliderStyles","canShowError","isSingle","isSingleSlider","value","length","knobsValuesToKnobsPositions","defaultKnobsPositions","knobsPositions","setKnobsPositions","useControlled","arrayStatus","arrayDefaultStatus","convertStatusToArray","validationStatus","setValidationState","validationMessage","setValidationMessage","isDraggingTrack","setIsDraggingTrack","useState","generateDefaultKnobProperties","rangesCount","trackStyles","createTrackStyles","knobStyles","createKnobStyles","performValidation","useCallback","invalid","newValidationState","map","position","Number","isNaN","validationStates","valid","useEffect","stepVl","inverseStepVl","current","onMouseDownHandler","event","target","includes","onMouseUpHandler","generateKnobsPositionAndValues","knobsCurrentPosition","newKnobsPosition","slice","knobsValues","duplicatedValue","findDuplicated","filter","item","index","indexOf","forEach","array","newArray","newPosition","previousValue","knobsPositionToScaledValue","knobsPosition","onBlurHandler","knobs","onChangeHandler","knobProperty","fixed","scaledValueToKnobsPositionValue","onInputChangeHandler","inputValues","newKnobPositions","ensureValuesConsistency","onBeforeChangeHandler","onAfterChangeHandler","createKnob","knobNode","params","knobValue","dragging","knobClassName","style","restProps","scaledKnobValue","toFixed","backgroundColor","dragColor","color","isEmpty","handleId","indexedHandleId","handleContainer","handleContainerDisabled","handleHiddenContainer","sliderTooltip","document","getElementById","handle","root","trackStandBy","trackDragging","rootDisabled","statusArrayToFormStatus","labelContainer","labelIncluded","onlyInput","knobsPositionsToKnobsValues","sliderBase","sliderContainer","sliderRoot","dotDisabled","dot","singleValue","Array","isArray","rail","knobInner","rootRange","error"],"mappings":"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"}
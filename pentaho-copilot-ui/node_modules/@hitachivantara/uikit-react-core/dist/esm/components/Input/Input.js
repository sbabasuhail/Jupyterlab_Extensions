import { jsx, jsxs, Fragment } from "@emotion/react/jsx-runtime";
import React__default, { forwardRef, useRef, useState, useMemo, useCallback, isValidElement, useEffect } from "react";
import { useForkRef } from "@mui/material";
import { CloseXS, Search, PreviewOff, Preview, Success } from "@hitachivantara/uikit-react-icons";
import { isBrowser } from "../../utils/browser.js";
import { isKey } from "../../utils/keyboardUtils.js";
import { setId } from "../../utils/setId.js";
import validationState, { isInvalid, isValid } from "../Forms/FormElement/validationStates.js";
import { DEFAULT_ERROR_MESSAGES, computeValidationType, validateInput, computeValidationState, computeValidationMessage, hasBuiltInValidations } from "../BaseInput/validations.js";
import { useControlled } from "../../hooks/useControlled.js";
import { useIsMounted } from "../../hooks/useIsMounted.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useLabels } from "../../hooks/useLabels.js";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { useClasses } from "./Input.styles.js";
import { staticClasses } from "./Input.styles.js";
import { HvAdornment } from "../Forms/Adornment/Adornment.js";
import { HvBaseInput } from "../BaseInput/BaseInput.js";
import { HvSuggestions } from "../Forms/Suggestions/Suggestions.js";
import { HvTooltip } from "../Tooltip/Tooltip.js";
import { HvTypography } from "../Typography/Typography.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
const DEFAULT_LABELS = {
  clearButtonLabel: "Clear the text",
  revealPasswordButtonLabel: "Reveal password",
  revealPasswordButtonClickToShowTooltip: "Click to show password.",
  revealPasswordButtonClickToHideTooltip: "Click to hide password.",
  searchButtonLabel: "Search"
};
const getFocusedElement = (event) => isBrowser("ie") ? document.activeElement : event.relatedTarget;
function eventTargetIsInsideContainer(container, event) {
  return container != null && container.contains(getFocusedElement(event));
}
const changeInputValue = (input, value = "") => {
  var _a;
  const event = new Event("input", {
    bubbles: true
  });
  const setInputValue = (_a = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, "value")) == null ? void 0 : _a.set;
  setInputValue == null ? void 0 : setInputValue.call(input, value);
  input == null ? void 0 : input.dispatchEvent(event);
};
const HvInput = forwardRef((props, ref) => {
  var _a;
  const {
    classes: classesProp,
    className,
    id,
    name,
    value: valueProp,
    defaultValue = "",
    required = false,
    readOnly = false,
    disabled = false,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    onEnter,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    type = "text",
    placeholder,
    autoFocus = false,
    labels: labelsProp,
    validationMessages,
    disableClear = false,
    disableRevealPassword = false,
    disableSearchButton = false,
    endAdornment,
    maxCharQuantity,
    minCharQuantity,
    validation,
    showValidationIcon = false,
    suggestionListCallback,
    inputRef: inputRefProp,
    onBlur,
    onFocus,
    onKeyDown,
    inputProps = {},
    ...others
  } = useDefaultProps("HvInput", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const labels = useLabels(DEFAULT_LABELS, labelsProp);
  const elementId = useUniqueId(id, "hvinput");
  const inputRef = useRef(null);
  const forkedRef = useForkRef(ref, inputRef, inputRefProp);
  const suggestionsRef = useRef(null);
  const [focused, setFocused] = useState(false);
  const isDirty = useRef(false);
  const [value, setValue] = useControlled(valueProp, defaultValue);
  const isEmptyValue = value == null || value === "";
  const [validationState$1, setValidationState] = useControlled(status, validationState.standBy);
  const [validationMessage, setValidationMessage] = useControlled(statusMessage, "");
  const errorMessages = useMemo(
    () => ({
      ...DEFAULT_ERROR_MESSAGES,
      ...validationMessages
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [validationMessages == null ? void 0 : validationMessages.error, validationMessages == null ? void 0 : validationMessages.requiredError, validationMessages == null ? void 0 : validationMessages.minCharError, validationMessages == null ? void 0 : validationMessages.maxCharError, validationMessages == null ? void 0 : validationMessages.typeMismatchError]
  );
  const validationType = useMemo(() => computeValidationType(type), [type]);
  const performValidation = useCallback(() => {
    const inputValidity = validateInput(inputRef.current, value, required, minCharQuantity, maxCharQuantity, validationType, validation);
    setValidationState(computeValidationState(inputValidity, isEmptyValue));
    setValidationMessage(computeValidationMessage(inputValidity, errorMessages));
    return inputValidity;
  }, [errorMessages, isEmptyValue, maxCharQuantity, minCharQuantity, required, setValidationMessage, setValidationState, validation, validationType, value]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && hasBuiltInValidations(required, validationType, minCharQuantity, maxCharQuantity, validation, inputProps));
  const isStateInvalid = isInvalid(validationState$1);
  const [revealPassword, setRevealPassword] = useState(false);
  const realType = useMemo(() => {
    if (type === "password") {
      return revealPassword ? "text" : "password";
    }
    if (type === "search") {
      return "search";
    }
    return "text";
  }, [revealPassword, type]);
  const [suggestionValues, setSuggestionValues] = useState(null);
  const canShowSuggestions = suggestionListCallback != null;
  const hasSuggestions = !!suggestionValues;
  const hasLabel = label != null;
  const hasDescription = description != null;
  const focusInput = () => {
    var _a2;
    (_a2 = inputRef.current) == null ? void 0 : _a2.focus();
  };
  const isMounted = useIsMounted();
  const suggestionClearHandler = () => {
    if (isMounted.current) {
      setSuggestionValues(null);
    }
  };
  const suggestionHandler = (val) => {
    var _a2;
    const suggestionsArray = suggestionListCallback == null ? void 0 : suggestionListCallback(val);
    if ((_a2 = suggestionsArray == null ? void 0 : suggestionsArray[0]) == null ? void 0 : _a2.label) {
      setSuggestionValues(suggestionsArray);
    } else {
      suggestionClearHandler();
    }
  };
  const suggestionSelectedHandler = (event, item) => {
    const newValue = item.value || item.label;
    changeInputValue(inputRef.current, newValue);
    focusInput();
    suggestionClearHandler();
    if (type === "search") {
      onEnter == null ? void 0 : onEnter(event, newValue);
    }
  };
  const onChangeHandler = (event, newValue) => {
    isDirty.current = true;
    setValue(newValue);
    onChange == null ? void 0 : onChange(event, newValue);
    if (canShowSuggestions) {
      suggestionHandler(newValue);
    }
  };
  const onInputBlurHandler = (event) => {
    if (eventTargetIsInsideContainer(suggestionsRef.current, event))
      return;
    setFocused(false);
    const inputValidity = performValidation();
    onBlur == null ? void 0 : onBlur(event, value, inputValidity);
  };
  const onFocusHandler = (event) => {
    setFocused(true);
    setValidationState(validationState.standBy);
    onFocus == null ? void 0 : onFocus(event, value);
  };
  const getSuggestions = (li) => {
    var _a2;
    const listEl = document.getElementById(setId(elementId, "suggestions-list") || "");
    return li != null ? (_a2 = listEl == null ? void 0 : listEl.getElementsByTagName("li")) == null ? void 0 : _a2[li] : listEl;
  };
  const onSuggestionKeyDown = (event) => {
    if (isKey(event, "Esc")) {
      suggestionClearHandler();
      focusInput();
    } else if (isKey(event, "Tab")) {
      suggestionClearHandler();
    }
  };
  const onKeyDownHandler = (event) => {
    if (isKey(event, "ArrowDown") && hasSuggestions) {
      const li = getSuggestions(0);
      li == null ? void 0 : li.focus();
    } else if (isKey(event, "Enter")) {
      onEnter == null ? void 0 : onEnter(event, value);
    }
    onKeyDown == null ? void 0 : onKeyDown(event, value);
  };
  const onContainerBlurHandler = (event) => {
    if (event.relatedTarget) {
      setTimeout(() => {
        const list = getSuggestions(null);
        if (!(list == null ? void 0 : list.contains(document.activeElement)))
          suggestionClearHandler();
      }, 10);
    }
  };
  const hasOnEnter = onEnter != null;
  const showClear = !disabled && !readOnly && !disableClear && !isEmptyValue && (!hasOnEnter || type !== "search" || disableSearchButton || validationState$1 !== validationState.standBy);
  const showSearchIcon = type === "search" && !disableSearchButton;
  const showRevealPasswordButton = type === "password" && !disableRevealPassword;
  const handleClear = useCallback(() => {
    setValidationState(validationState.standBy);
    changeInputValue(inputRef.current, "");
    setTimeout(focusInput);
  }, [setValidationState]);
  const clearButton = useMemo(() => {
    if (!showClear) {
      return null;
    }
    return /* @__PURE__ */ jsx(
      HvAdornment,
      {
        className: cx(classes.adornmentButton, {
          [classes.iconClear]: !showSearchIcon
        }),
        onClick: handleClear,
        "aria-label": labels == null ? void 0 : labels.clearButtonLabel,
        "aria-controls": setId(elementId, "input"),
        icon: /* @__PURE__ */ jsx(CloseXS, {})
      }
    );
  }, [showClear, classes.adornmentButton, classes.iconClear, showSearchIcon, handleClear, labels == null ? void 0 : labels.clearButtonLabel, elementId, cx]);
  const handleSearch = useCallback((event) => {
    onEnter == null ? void 0 : onEnter(event, value);
  }, [onEnter, value]);
  const searchButton = useMemo(() => {
    const reallyShowIt = showSearchIcon && (isEmptyValue || hasOnEnter && validationState$1 === validationState.standBy);
    if (!reallyShowIt) {
      return null;
    }
    return /* @__PURE__ */ jsx(HvAdornment, { className: classes.adornmentButton, onClick: hasOnEnter ? handleSearch : void 0, "aria-label": labels == null ? void 0 : labels.searchButtonLabel, icon: /* @__PURE__ */ jsx(Search, {}) });
  }, [showSearchIcon, isEmptyValue, hasOnEnter, validationState$1, classes.adornmentButton, handleSearch, labels == null ? void 0 : labels.searchButtonLabel]);
  const handleRevealPassword = useCallback(() => {
    setRevealPassword(!revealPassword);
  }, [revealPassword]);
  const revealPasswordButton = useMemo(() => {
    if (!showRevealPasswordButton) {
      return null;
    }
    return /* @__PURE__ */ jsx(HvTooltip, { disableFocusListener: true, disableTouchListener: true, title: /* @__PURE__ */ jsx(HvTypography, { children: revealPassword ? labels == null ? void 0 : labels.revealPasswordButtonClickToHideTooltip : labels == null ? void 0 : labels.revealPasswordButtonClickToShowTooltip }), children: /* @__PURE__ */ jsx(HvAdornment, { className: classes.adornmentButton, onClick: handleRevealPassword, "aria-label": labels == null ? void 0 : labels.revealPasswordButtonLabel, "aria-controls": setId(elementId, "input"), icon: revealPassword ? /* @__PURE__ */ jsx(PreviewOff, {}) : /* @__PURE__ */ jsx(Preview, {}) }) });
  }, [showRevealPasswordButton, revealPassword, labels == null ? void 0 : labels.revealPasswordButtonClickToHideTooltip, labels == null ? void 0 : labels.revealPasswordButtonClickToShowTooltip, labels == null ? void 0 : labels.revealPasswordButtonLabel, classes.adornmentButton, handleRevealPassword, elementId]);
  const validationIcon = useMemo(() => {
    if (!showValidationIcon) {
      return null;
    }
    if (!isValid(validationState$1)) {
      return null;
    }
    return /* @__PURE__ */ jsx(Success, { color: "positive", className: classes.icon });
  }, [showValidationIcon, validationState$1, classes.icon]);
  const customIconEl = useMemo(() => isValidElement(endAdornment) && React__default.cloneElement(endAdornment, {
    className: cx(endAdornment.props.className, classes.icon)
  }), [classes.icon, endAdornment, cx]);
  const adornments = useMemo(() => {
    if (!clearButton && !revealPasswordButton && !searchButton && !validationIcon && !customIconEl)
      return null;
    return /* @__PURE__ */ jsxs("div", { className: classes.adornmentsBox, "aria-hidden": "true", children: [
      clearButton,
      revealPasswordButton,
      searchButton,
      validationIcon || customIconEl
    ] });
  }, [classes.adornmentsBox, clearButton, customIconEl, revealPasswordButton, searchButton, validationIcon]);
  useEffect(() => {
    if (focused || !isDirty.current && isEmptyValue) {
      return;
    }
    performValidation();
  }, [focused, isEmptyValue, performValidation]);
  const errorMessageId = isStateInvalid ? canShowError ? setId(elementId, "error") : ariaErrorMessage : void 0;
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, status: validationState$1, disabled, required, readOnly, className: cx(classes.root, {
    [classes.hasSuggestions]: hasSuggestions
  }, className), onBlur: onContainerBlurHandler, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsx(HvLabel, { id: setId(elementId, "label"), className: classes.label, htmlFor: setId(elementId, "input"), label }),
      hasDescription && /* @__PURE__ */ jsx(HvInfoMessage, { id: setId(elementId, "description"), className: classes.description, children: description })
    ] }),
    /* @__PURE__ */ jsx(HvBaseInput, { id: hasLabel || showClear || showRevealPasswordButton ? setId(elementId, "input") : setId(id, "input"), name, value, required, readOnly, disabled, onChange: onChangeHandler, autoFocus, onKeyDown: onKeyDownHandler, onBlur: onInputBlurHandler, onFocus: onFocusHandler, placeholder, type: realType, classes: {
      input: classes.input,
      inputRoot: classes.inputRoot,
      inputRootFocused: classes.inputRootFocused,
      inputRootDisabled: classes.inputRootDisabled,
      inputRootMultiline: classes.inputRootMultiline,
      inputBorderContainer: classes.inputBorderContainer
    }, invalid: isStateInvalid, inputProps: {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": isStateInvalid ? true : void 0,
      "aria-errormessage": errorMessageId,
      "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : description ? setId(elementId, "description") : void 0,
      "aria-controls": canShowSuggestions ? setId(elementId, "suggestions") : void 0,
      ref: inputRef,
      // prevent browsers auto-fill/suggestions when we have our own
      autoComplete: canShowSuggestions ? "off" : void 0,
      ...inputProps
    }, inputRef: forkedRef, endAdornment: adornments, ...others }),
    canShowSuggestions && /* @__PURE__ */ jsxs(Fragment, { children: [
      hasSuggestions && /* @__PURE__ */ jsx("div", { role: "presentation", className: classes.inputExtension }),
      /* @__PURE__ */ jsx(HvSuggestions, { ref: suggestionsRef, id: setId(elementId, "suggestions"), classes: {
        root: classes.suggestionsContainer,
        list: classes.suggestionList
      }, expanded: hasSuggestions, anchorEl: (_a = inputRef.current) == null ? void 0 : _a.parentElement, onClose: suggestionClearHandler, onKeyDown: onSuggestionKeyDown, onSuggestionSelected: suggestionSelectedHandler, suggestionValues })
    ] }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
});
export {
  HvInput,
  staticClasses as inputClasses
};
//# sourceMappingURL=Input.js.map

import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import { useState, useEffect, useRef } from "react";
import { theme } from "@hitachivantara/uikit-styles";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { setId } from "../../utils/setId.js";
import { getSelectionLabel, getSelected } from "./utils.js";
import { useClasses, staticClasses } from "./Dropdown.styles.js";
import { useLabels } from "../../hooks/useLabels.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useControlled } from "../../hooks/useControlled.js";
import { HvDropdownList } from "./List/List.js";
import { isInvalid } from "../Forms/FormElement/validationStates.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvBaseDropdown } from "../BaseDropdown/BaseDropdown.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
import { HvTypography } from "../Typography/Typography.js";
const DEFAULT_LABELS = {
  select: void 0,
  selectAll: "All",
  cancelLabel: "Cancel",
  applyLabel: "Apply",
  searchPlaceholder: "Search",
  multiSelectionConjunction: "/"
};
const HvDropdown = (props) => {
  const {
    classes: classesProp,
    className,
    id,
    name,
    required = false,
    disabled = false,
    readOnly = false,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    placeholder = "Select...",
    onChange,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    onCancel,
    onToggle,
    onClickOutside,
    onFocus,
    onBlur,
    values,
    multiSelect = false,
    showSearch = false,
    expanded,
    defaultExpanded = false,
    notifyChangesOnFirstRender = false,
    labels: labelsProp,
    hasTooltips = false,
    disablePortal = false,
    singleSelectionToggle = true,
    placement,
    variableWidth = false,
    popperProps = {},
    height,
    maxHeight,
    virtualized = false,
    baseDropdownProps = {},
    listProps = {},
    ...others
  } = useDefaultProps("HvDropdown", props);
  const {
    classes,
    cx,
    css
  } = useClasses(classesProp);
  const labels = useLabels(DEFAULT_LABELS, labelsProp);
  const elementId = useUniqueId(id, "hvdropdown");
  const [validationState, setValidationState] = useControlled(status, "standBy");
  const [validationMessage] = useControlled(statusMessage, "Required");
  const [isOpen, setIsOpen] = useControlled(expanded, Boolean(defaultExpanded));
  const [selectionLabel, setSelectionLabel] = useState(getSelectionLabel(labels, placeholder, multiSelect, values));
  const [internalValues, setInternalValues] = useState(values);
  useEffect(() => {
    setInternalValues(values);
  }, [values]);
  useEffect(() => {
    setSelectionLabel(getSelectionLabel(labels, placeholder, multiSelect, values));
  }, [labels, multiSelect, placeholder, values]);
  if (virtualized && !height && process.env.NODE_ENV !== "production") {
    console.error("Dropdown/List in virtualized mode requires a height. Please define it.");
  }
  const dropdownHeaderRef = useRef();
  const handleToggle = (event, open) => {
    onToggle == null ? void 0 : onToggle(event, open);
    setIsOpen(open);
    if (!open) {
      setValidationState(() => {
        if (required) {
          const hasSelection = getSelected(internalValues).length > 0;
          if (!hasSelection) {
            return "invalid";
          }
        }
        return "valid";
      });
    }
  };
  const handleSelection = (listValues, commitChanges, toggle, notifyChanges = true) => {
    var _a;
    const selected = getSelected(listValues);
    if (commitChanges) {
      setInternalValues(listValues);
      setSelectionLabel(getSelectionLabel(labels, placeholder, multiSelect, listValues));
      setValidationState(() => {
        if (required && selected.length === 0) {
          return "invalid";
        }
        return "valid";
      });
    }
    if (notifyChanges)
      onChange == null ? void 0 : onChange(multiSelect ? selected : selected[0]);
    if (toggle) {
      handleToggle(void 0, false);
      (_a = dropdownHeaderRef.current) == null ? void 0 : _a.focus({
        preventScroll: true
      });
    }
  };
  const handleCancel = (evt) => {
    var _a;
    onCancel == null ? void 0 : onCancel(evt);
    handleToggle(evt, false);
    (_a = dropdownHeaderRef.current) == null ? void 0 : _a.focus({
      preventScroll: true
    });
  };
  const handleClickOutside = (evt) => {
    onClickOutside == null ? void 0 : onClickOutside(evt);
    onCancel == null ? void 0 : onCancel(evt);
  };
  const setFocusToContent = (containerRef) => {
    const inputs = containerRef == null ? void 0 : containerRef.getElementsByTagName("input");
    if (inputs && inputs.length > 0) {
      inputs[0].focus();
      return;
    }
    const listItems = containerRef != null ? [...containerRef.getElementsByTagName("li")] : [];
    listItems.every((listItem) => {
      if (listItem.tabIndex >= 0) {
        listItem.focus();
        return false;
      }
      return true;
    });
  };
  const buildHeaderLabel = () => {
    const hasSelection = getSelected(internalValues).length > 0;
    return (labels == null ? void 0 : labels.select) || !multiSelect ? /* @__PURE__ */ jsx(HvTypography, { component: "div", variant: "body", className: cx(classes.placeholder, {
      [classes.selectionDisabled]: disabled
    }, !(isOpen || hasSelection) && css({
      color: theme.dropdown.placeholderColor
    })), children: selectionLabel.selected }) : /* @__PURE__ */ jsxs(HvTypography, { component: "div", className: cx(classes.placeholder, {
      [classes.selectionDisabled]: disabled
    }), variant: "body", children: [
      /* @__PURE__ */ jsx("b", { children: selectionLabel.selected }),
      ` ${labels == null ? void 0 : labels.multiSelectionConjunction} ${selectionLabel.total}`
    ] });
  };
  const hasLabel = label != null;
  const hasDescription = description != null;
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const isStateInvalid = isInvalid(validationState);
  let errorMessageId;
  if (isStateInvalid) {
    errorMessageId = canShowError ? setId(elementId, "error") : ariaErrorMessage;
  }
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, status: validationState, disabled, readOnly, required, className: cx(classes.root, disabled && css({
    color: theme.dropdown.disabledColor
  }), className), ...others, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsx(HvLabel, { id: setId(elementId, "label"), label, className: classes.label }),
      hasDescription && /* @__PURE__ */ jsx(HvInfoMessage, { id: setId(elementId, "description"), className: classes.description, children: description })
    ] }),
    /* @__PURE__ */ jsx(HvBaseDropdown, { id: setId(id, "dropdown"), classes: {
      root: cx(classes.dropdown, readOnly && css({
        [`& .${staticClasses.dropdownHeader}`]: {
          border: theme.dropdown.readOnlyBorder,
          backgroundColor: theme.dropdown.readOnlyBackgroundColor
        }
      })),
      arrow: classes.arrow,
      header: cx(classes.dropdownHeader, {
        [classes.dropdownHeaderInvalid]: isStateInvalid
      }),
      headerOpen: classes.dropdownHeaderOpen
    }, expanded: isOpen, disabled, readOnly, required, disablePortal, placement, popperProps, placeholder: buildHeaderLabel(), onToggle: handleToggle, onClickOutside: handleClickOutside, onContainerCreation: setFocusToContent, role: "combobox", variableWidth, "aria-label": ariaLabel, "aria-labelledby": [label && setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0, "aria-invalid": isStateInvalid ? true : void 0, "aria-errormessage": errorMessageId, "aria-describedby": [description && setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, onFocus, onBlur, dropdownHeaderRef, ...baseDropdownProps, children: /* @__PURE__ */ jsx(HvDropdownList, { id: setId(elementId, "values"), classes: {
      rootList: classes.rootList,
      dropdownListContainer: classes.dropdownListContainer
    }, values: internalValues, multiSelect, showSearch, onChange: handleSelection, onCancel: handleCancel, labels, notifyChangesOnFirstRender, hasTooltips, singleSelectionToggle, "aria-label": ariaLabel, "aria-labelledby": hasLabel ? setId(elementId, "label") : void 0, height, maxHeight, virtualized, ...listProps }) }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), disableBorder: true, className: classes.error, children: validationMessage })
  ] });
};
export {
  HvDropdown,
  staticClasses as dropdownClasses
};
//# sourceMappingURL=Dropdown.js.map

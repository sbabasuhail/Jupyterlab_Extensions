import { jsx, jsxs, Fragment } from "@emotion/react/jsx-runtime";
import { useRef, useEffect, useMemo, forwardRef, isValidElement } from "react";
import { FixedSizeList } from "react-window";
import { DropRightXS } from "@hitachivantara/uikit-react-icons";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { setId } from "../../utils/setId.js";
import { wrapperTooltip } from "../../utils/wrapperTooltip.js";
import { useClasses } from "./List.styles.js";
import { staticClasses } from "./List.styles.js";
import { useSelectableList } from "./useSelectableList.js";
import { parseList } from "./utils.js";
import { HvRadio } from "../Radio/Radio.js";
import { HvLink } from "../Link/Link.js";
import { HvListContainer } from "../ListContainer/ListContainer.js";
import { HvTypography } from "../Typography/Typography.js";
import { HvCheckBox } from "../CheckBox/CheckBox.js";
import { HvListItem } from "../ListContainer/ListItem/ListItem.js";
const DEFAULT_LABELS = {
  selectAll: "Select All",
  selectionConjunction: "/"
};
const HvList = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    multiSelect = false,
    hasTooltips = false,
    showSelectAll = false,
    labels = DEFAULT_LABELS,
    useSelector = false,
    selectable = true,
    singleSelectionToggle = true,
    condensed = false,
    onChange,
    onClick,
    values: valuesProp = [],
    height,
    virtualized = false,
    ...others
  } = useDefaultProps("HvList", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const [list, setList, selection] = useSelectableList(valuesProp);
  const listRef = useRef(null);
  useEffect(() => {
    const passedProps = {
      multiSelect,
      selectable,
      singleSelectionToggle
    };
    const parsedList = parseList(void 0, passedProps, void 0, valuesProp);
    setList(parsedList);
  }, [valuesProp, multiSelect, selectable, singleSelectionToggle, setList]);
  const [role, itemRole] = useMemo(() => {
    if (selectable && useSelector)
      return ["list", "listitem"];
    if (selectable)
      return ["listbox", "option"];
    return ["menu", "menuitem"];
  }, [selectable, useSelector]);
  const handleSelect = (evt, item) => {
    if (!item.path)
      evt.preventDefault();
    if (item.disabled)
      return;
    const passedProps = {
      multiSelect,
      selectable,
      singleSelectionToggle
    };
    const parsedList = parseList(item, passedProps, void 0, list);
    setList(parsedList);
    onClick == null ? void 0 : onClick(evt, item);
    onChange == null ? void 0 : onChange(parsedList);
  };
  const handleSelectAll = () => {
    const passedProps = {
      multiSelect,
      selectable,
      singleSelectionToggle
    };
    const anySelectableSelected = list.some((elem) => elem.selected || elem.disabled);
    const parsedList = parseList(void 0, passedProps, !anySelectableSelected, list);
    setList(parsedList);
    onChange == null ? void 0 : onChange(parsedList);
  };
  const renderLeftIcon = (item) => {
    var _a;
    return isValidElement(item.icon) ? item.icon : (_a = item.icon) == null ? void 0 : _a.call(item, {
      isSelected: item.selected,
      isDisabled: item.disabled
    });
  };
  const renderSelectAll = () => {
    const {
      selectAll,
      selectionConjunction
    } = labels;
    const anySelected2 = !!(selection == null ? void 0 : selection.length);
    const allSelected = selection.length === list.length;
    const selectionLabel = /* @__PURE__ */ jsx(HvTypography, { component: "span", children: !anySelected2 ? /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("b", { children: selectAll }),
      ` (${list.length})`
    ] }) : /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx("b", { children: selection.length }),
      ` ${selectionConjunction} `,
      list.length
    ] }) });
    return /* @__PURE__ */ jsx(HvCheckBox, { id: setId(id, "select-all"), label: selectionLabel, onChange: handleSelectAll, className: classes.selectAllSelector, indeterminate: anySelected2 && !allSelected, checked: allSelected });
  };
  const renderItemText = (item) => {
    const ItemText = wrapperTooltip(hasTooltips, item.label, item.label);
    return !multiSelect && item.path ? /* @__PURE__ */ jsx(HvLink, { route: item.path, classes: {
      a: classes.link
    }, children: /* @__PURE__ */ jsx(ItemText, {}) }, item.label) : /* @__PURE__ */ jsx(ItemText, {});
  };
  const renderMultiSelectItem = (item, itemId) => {
    if (useSelector) {
      const Selection = wrapperTooltip(hasTooltips, /* @__PURE__ */ jsx(HvCheckBox, { id: setId(itemId, "selector"), label: item.label, checked: item.selected, disabled: item.disabled, onChange: (evt) => handleSelect(evt, item), classes: {
        root: classes.selectorRoot,
        container: classes.selectorContainer,
        label: classes.truncate
      } }), item.label);
      return /* @__PURE__ */ jsx(Selection, {});
    }
    return renderItemText(item);
  };
  const renderSingleSelectItem = (item, itemId) => {
    if (useSelector) {
      const Selection = wrapperTooltip(hasTooltips, /* @__PURE__ */ jsx(HvRadio, { id: setId(itemId, "selector"), label: item.label, checked: item.selected, disabled: item.disabled, classes: {
        root: classes.selectorRoot,
        container: classes.selectorContainer,
        label: classes.truncate
      } }), item.label);
      return /* @__PURE__ */ jsx(Selection, {});
    }
    return renderItemText(item);
  };
  const renderListItem = (item, i, otherProps = {}) => {
    const itemId = setId(id, "item", i);
    const selected = item.selected || false;
    let startAdornment = null;
    if (!useSelector && item.icon) {
      startAdornment = renderLeftIcon(item);
    }
    return /* @__PURE__ */ jsx(HvListItem, { id: itemId, role: itemRole, disabled: item.disabled || void 0, className: classes.item, classes: {
      selected: cx({
        [classes.itemSelector]: useSelector || multiSelect
      })
    }, selected: multiSelect || selected ? selected : void 0, onClick: (evt) => handleSelect(evt, item), startAdornment, endAdornment: item.showNavIcon && /* @__PURE__ */ jsx(DropRightXS, { className: classes.box, iconSize: "XS" }), ...otherProps, children: multiSelect ? renderMultiSelectItem(item, itemId) : renderSingleSelectItem(item, itemId) }, i);
  };
  const filteredList = list.filter((it) => !it.isHidden);
  const anySelected = list.map((item) => item.selected && !item.disabled).reduce((result, selected) => result || selected, false);
  const selectedItemIndex = list.findIndex((item) => item.selected);
  useEffect(() => {
    if (selectedItemIndex >= 0 && listRef.current !== null) {
      listRef.current.scrollToItem(selectedItemIndex);
    }
  }, [listRef, selectedItemIndex]);
  const renderVirtualizedListItem = ({
    index,
    style
  }) => {
    const item = filteredList[index];
    const tabIndex = item.tabIndex || !anySelected && index === 0 || item.selected && !item.disabled ? 0 : -1;
    return renderListItem(item, index, {
      style: {
        ...style,
        top: `${parseFloat(style.top) + 5}px`,
        left: `${parseFloat(style.left) + 5}px`,
        width: `calc(${parseFloat(style.width)}% - 10px)`
      },
      tabIndex,
      interactive: true,
      condensed,
      disableGutters: useSelector
    });
  };
  const ariaMultiSelectable = role === "listbox" && multiSelect || void 0;
  const ListContainer = useMemo(() => {
    return forwardRef(({
      ...rest
    }, ref) => /* @__PURE__ */ jsx(HvListContainer, { id, className: cx(classes.root, className), role, interactive: true, condensed, disableGutters: useSelector, "aria-multiselectable": ariaMultiSelectable, ref, ...rest }));
  }, [cx, id, useSelector, className, classes.root, role, condensed, ariaMultiSelectable]);
  if (filteredList.length === 0)
    return null;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    multiSelect && useSelector && showSelectAll && renderSelectAll(),
    !virtualized ? /* @__PURE__ */ jsx(HvListContainer, { id, className: cx(classes.root, className), role, interactive: true, condensed, disableGutters: useSelector, "aria-multiselectable": ariaMultiSelectable, ...others, children: filteredList.map((item, i) => renderListItem(item, i)) }) : /* @__PURE__ */ jsx(FixedSizeList, { ref: listRef, className: classes.virtualizedRoot, height: (height || 0) + 5, width: "100%", itemCount: filteredList.length, itemSize: condensed ? 32 : 40, innerElementType: ListContainer, ...others, children: renderVirtualizedListItem })
  ] });
};
export {
  HvList,
  staticClasses as listClasses
};
//# sourceMappingURL=List.js.map

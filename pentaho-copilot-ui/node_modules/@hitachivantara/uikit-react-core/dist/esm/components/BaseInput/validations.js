import validationState from "../Forms/FormElement/validationStates.js";
const isNumeric = (num) => (
  // to prevent Number( <spaces> ) = 0
  num.trim().length > 0 && !Number.isNaN(Number(num))
);
const isEmail = (email) => {
  const regexp = /^[^\\s]+[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?[.])+[a-z0-9](?:[a-z0-9-]*[a-z0-9])$/i;
  return regexp.test(email);
};
const validationTypes = Object.freeze({
  none: "none",
  number: "number",
  email: "email"
});
const computeValidationType = (type) => {
  switch (type) {
    case "number":
      return validationTypes.number;
    case "email":
      return validationTypes.email;
    default:
      return validationTypes.none;
  }
};
const hasBuiltInValidations = (required, validationType, minCharQuantity, maxCharQuantity, validation, inputProps) => required || validationType !== validationTypes.none || minCharQuantity != null || maxCharQuantity != null || validation != null || (inputProps == null ? void 0 : inputProps.required) != null || (inputProps == null ? void 0 : inputProps.minLength) != null || (inputProps == null ? void 0 : inputProps.maxLength) != null || (inputProps == null ? void 0 : inputProps.min) != null || (inputProps == null ? void 0 : inputProps.max) != null || (inputProps == null ? void 0 : inputProps.type) != null && (inputProps == null ? void 0 : inputProps.type) !== "text" && (inputProps == null ? void 0 : inputProps.type) !== "password" || (inputProps == null ? void 0 : inputProps.pattern) != null;
const computeValidationState = (inputValidity, isEmptyValue) => {
  if (inputValidity.valid && isEmptyValue) {
    return validationState.standBy;
  }
  return inputValidity.valid ? validationState.valid : validationState.invalid;
};
const computeValidationMessage = (inputValidity, errorMessages) => {
  if (inputValidity.valid) {
    return "";
  }
  if (inputValidity.valueMissing) {
    return errorMessages.requiredError;
  }
  if (inputValidity.tooLong) {
    return errorMessages.maxCharError;
  }
  if (inputValidity.tooShort) {
    return errorMessages.minCharError;
  }
  if (inputValidity.typeMismatch) {
    return errorMessages.typeMismatchError;
  }
  return errorMessages.error;
};
const validateInput = (input, value, required, minCharQuantity, maxCharQuantity, validationType, validation) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
  const inputValidity = {
    valid: ((_a = input == null ? void 0 : input.validity) == null ? void 0 : _a.valid) ?? true,
    badInput: (_b = input == null ? void 0 : input.validity) == null ? void 0 : _b.badInput,
    customError: (_c = input == null ? void 0 : input.validity) == null ? void 0 : _c.customError,
    patternMismatch: (_d = input == null ? void 0 : input.validity) == null ? void 0 : _d.patternMismatch,
    rangeOverflow: (_e = input == null ? void 0 : input.validity) == null ? void 0 : _e.rangeOverflow,
    rangeUnderflow: (_f = input == null ? void 0 : input.validity) == null ? void 0 : _f.rangeUnderflow,
    stepMismatch: (_g = input == null ? void 0 : input.validity) == null ? void 0 : _g.stepMismatch,
    tooLong: (_h = input == null ? void 0 : input.validity) == null ? void 0 : _h.tooLong,
    tooShort: (_i = input == null ? void 0 : input.validity) == null ? void 0 : _i.tooShort,
    typeMismatch: (_j = input == null ? void 0 : input.validity) == null ? void 0 : _j.typeMismatch,
    valueMissing: (_k = input == null ? void 0 : input.validity) == null ? void 0 : _k.valueMissing
  };
  if (!value) {
    if (required) {
      inputValidity.valueMissing = true;
      inputValidity.valid = false;
    }
  } else {
    if (minCharQuantity !== null && value.length < minCharQuantity) {
      inputValidity.tooShort = true;
      inputValidity.valid = false;
    }
    if (maxCharQuantity !== null && value.length > maxCharQuantity) {
      inputValidity.tooLong = true;
      inputValidity.valid = false;
    }
    switch (validationType) {
      case validationTypes.number:
        if (!isNumeric(value)) {
          inputValidity.typeMismatch = true;
          inputValidity.valid = false;
        }
        break;
      case validationTypes.email:
        if (!isEmail(value)) {
          inputValidity.typeMismatch = true;
          inputValidity.valid = false;
        }
        break;
    }
    if (validation != null && !validation(value)) {
      inputValidity.customError = true;
      inputValidity.valid = false;
    }
  }
  return inputValidity;
};
const DEFAULT_ERROR_MESSAGES = {
  error: "Invalid value",
  requiredError: "The value is required",
  minCharError: "The value is too short",
  maxCharError: "The value is too long",
  typeMismatchError: "Invalid value"
};
export {
  DEFAULT_ERROR_MESSAGES,
  computeValidationMessage,
  computeValidationState,
  computeValidationType,
  hasBuiltInValidations,
  validateInput,
  validationTypes
};
//# sourceMappingURL=validations.js.map

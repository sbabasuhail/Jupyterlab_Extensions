import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import React__default, { useContext, useCallback, useMemo } from "react";
import { useDefaultProps } from "../../../hooks/useDefaultProps.js";
import { useClasses } from "./ListItem.styles.js";
import { staticClasses } from "./ListItem.styles.js";
import HvListContext from "../ListContext/ListContext.js";
import { HvFocus } from "../../Focus/Focus.js";
const applyClassNameAndStateToElement = (element, selected, disabled, onClick, className) => {
  if (element != null) {
    return React__default.cloneElement(element, {
      className,
      checked: !!selected,
      disabled,
      onChange: (evt) => onClick == null ? void 0 : onClick(evt)
    });
  }
  return null;
};
const applyClassNameToElement = (element, className) => {
  if (element != null) {
    return React__default.cloneElement(element, {
      className
    });
  }
  return null;
};
const HvListItem = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    role,
    value,
    selected,
    disabled,
    interactive: interactiveProp,
    condensed: condensedProp,
    disableGutters: disableGuttersProp,
    startAdornment,
    endAdornment,
    onClick,
    children,
    tabIndex,
    ...others
  } = useDefaultProps("HvListItem", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const {
    topContainerRef,
    condensed: condensedContext,
    disableGutters: disableGuttersContext,
    interactive: interactiveContext
  } = useContext(HvListContext);
  const condensed = condensedProp != null ? condensedProp : condensedContext;
  const disableGutters = disableGuttersProp != null ? disableGuttersProp : disableGuttersContext;
  const interactive = interactiveProp != null ? interactiveProp : interactiveContext;
  const handleOnClick = useCallback((evt) => {
    if (!disabled) {
      onClick == null ? void 0 : onClick(evt);
    }
  }, [disabled, onClick]);
  const clonedStartAdornment = useMemo(() => applyClassNameAndStateToElement(startAdornment, selected, disabled, handleOnClick, cx(classes.startAdornment, {
    [classes.disabled]: disabled
  }, React__default.isValidElement(startAdornment) ? startAdornment.props.className : void 0)), [cx, classes == null ? void 0 : classes.startAdornment, classes == null ? void 0 : classes.disabled, disabled, handleOnClick, selected, startAdornment]);
  const clonedEndAdornment = useMemo(() => applyClassNameToElement(endAdornment, cx(classes.endAdornment, {
    [classes.disabled]: disabled
  }, React__default.isValidElement(endAdornment) ? endAdornment.props.className : void 0)), [cx, classes == null ? void 0 : classes.endAdornment, classes == null ? void 0 : classes.disabled, disabled, endAdornment]);
  const roleOptionAriaProps = role === "option" || role === "menuitem" ? {
    "aria-disabled": disabled || void 0,
    "aria-selected": selected
  } : {};
  const listItem = (
    // For later: this should only have an onClick event if interactive and has the appropriate role.
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    /* @__PURE__ */ jsxs(
      "li",
      {
        id,
        role,
        value,
        className: cx(classes.root, {
          [classes.gutters]: !disableGutters,
          [classes.condensed]: condensed,
          [classes.interactive]: interactive,
          [classes.selected]: !!selected,
          [classes.disabled]: !!disabled,
          [classes.withStartAdornment]: startAdornment != null,
          [classes.withEndAdornment]: endAdornment != null
        }, className),
        onClick: handleOnClick,
        onKeyDown: () => {
        },
        ...roleOptionAriaProps,
        ...others,
        children: [
          clonedStartAdornment,
          children,
          clonedEndAdornment
        ]
      }
    )
  );
  return interactive ? /* @__PURE__ */ jsx(HvFocus, { rootRef: topContainerRef, selected, disabledClass: disabled || void 0, strategy: role === "option" ? "listbox" : "menu", classes: {
    focus: classes.focus
  }, configuration: {
    tabIndex
  }, children: listItem }) : listItem;
};
export {
  HvListItem,
  staticClasses as listItemClasses
};
//# sourceMappingURL=ListItem.js.map

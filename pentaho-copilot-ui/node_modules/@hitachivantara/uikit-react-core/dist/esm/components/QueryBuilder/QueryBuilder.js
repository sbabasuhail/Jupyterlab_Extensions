import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import cloneDeep from "lodash/cloneDeep";
import isEqual from "lodash/isEqual";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { useState, useRef, useReducer, useContext, useMemo, useEffect } from "react";
import { QueryBuilderContext } from "./Context.js";
import { emptyGroup, clearNodeIds } from "./utils/index.js";
import reducer from "./utils/reducer.js";
import { RuleGroup } from "./RuleGroup/RuleGroup.js";
import { ConfirmationDialog } from "./ConfirmationDialog/ConfirmationDialog.js";
const HvQueryBuilder = (props) => {
  const {
    attributes,
    query,
    onChange,
    operators,
    combinators,
    maxDepth = 1,
    labels,
    readOnly = false,
    classes
  } = useDefaultProps("HvQueryBuilder", props);
  const [pendingAction, askAction] = useState();
  const currentAttributes = useRef(null);
  const [state, dispatchAction] = useReducer(reducer, query, (initialState2) => initialState2 || emptyGroup());
  const initialState = query === state;
  const [prevState, setPrevState] = useState();
  const defaultContext = useContext(QueryBuilderContext);
  const context = useMemo(() => ({
    dispatchAction,
    askAction,
    attributes,
    /* eslint-disable react/destructuring-assignment */
    operators: operators ?? defaultContext.operators,
    combinators: combinators ?? defaultContext.combinators,
    maxDepth: maxDepth ?? defaultContext.maxDepth,
    labels: labels ?? defaultContext.labels,
    initialTouched: initialState,
    readOnly
  }), [attributes, operators, defaultContext.operators, defaultContext.combinators, defaultContext.maxDepth, defaultContext.labels, combinators, maxDepth, labels, readOnly, initialState]);
  useEffect(() => {
    if (currentAttributes.current == null) {
      currentAttributes.current = attributes;
    } else if (currentAttributes.current !== attributes) {
      currentAttributes.current = attributes;
      dispatchAction({
        type: "reset-query"
      });
    }
  }, [attributes]);
  useEffect(() => {
    if (!initialState && !isEqual(state, prevState)) {
      onChange == null ? void 0 : onChange(clearNodeIds(state));
      setPrevState(cloneDeep(state));
    }
  }, [state, prevState, initialState, onChange]);
  const onConfirmHandler = () => {
    if (pendingAction) {
      askAction(void 0);
      pendingAction.actions.forEach((action) => dispatchAction(action));
    }
  };
  const onCancelHandler = () => {
    askAction(void 0);
  };
  return /* @__PURE__ */ jsxs(QueryBuilderContext.Provider, { value: context, children: [
    /* @__PURE__ */ jsx(RuleGroup, { level: 0, id: state.id, combinator: state.combinator, rules: state.rules, classes }),
    /* @__PURE__ */ jsx(ConfirmationDialog, { isOpen: pendingAction != null, onConfirm: onConfirmHandler, onCancel: onCancelHandler, title: (pendingAction == null ? void 0 : pendingAction.dialog.dialogTitle) || "", message: (pendingAction == null ? void 0 : pendingAction.dialog.dialogMessage) || "", confirmButtonLabel: (pendingAction == null ? void 0 : pendingAction.dialog.dialogConfirm) || "", cancelButtonLabel: (pendingAction == null ? void 0 : pendingAction.dialog.dialogCancel) || "", closeButtonTooltip: (pendingAction == null ? void 0 : pendingAction.dialog.dialogCloseTooltip) || "" })
  ] });
};
export {
  HvQueryBuilder
};
//# sourceMappingURL=QueryBuilder.js.map

{"version":3,"file":"CheckBoxGroup.js","sources":["../../../../src/components/CheckBoxGroup/CheckBoxGroup.tsx"],"sourcesContent":["import { Children, cloneElement, useCallback, useMemo, useRef } from \"react\";\n\nimport { useDefaultProps } from \"@core/hooks/useDefaultProps\";\nimport { HvBaseProps } from \"@core/types/generic\";\nimport { useUniqueId } from \"@core/hooks/useUniqueId\";\nimport { useControlled } from \"@core/hooks/useControlled\";\nimport { setId } from \"@core/utils/setId\";\nimport { multiSelectionEventHandler } from \"@core/utils/multiSelectionEventHandler\";\nimport { HvCheckBox } from \"@core/components/CheckBox\";\nimport {\n  HvFormElement,\n  HvFormStatus,\n  HvInfoMessage,\n  HvLabel,\n  HvWarningText,\n} from \"@core/components/Forms\";\nimport { ExtractNames } from \"@core/utils/classes\";\n\nimport { staticClasses, useClasses } from \"./CheckBoxGroup.styles\";\n\nconst computeSelectAllState = (selected: number, total: number) => {\n  if (selected === 0) {\n    return \"none\";\n  }\n\n  if (selected === total) {\n    return \"all\";\n  }\n\n  return \"some\";\n};\n\nconst getValueFromSelectedChildren = (children: React.ReactNode) => {\n  const selectedValues = Children.toArray(children)\n    .map((child: any) => {\n      const childIsControlled = child?.props?.checked !== undefined;\n      const childIsSelected = childIsControlled\n        ? child?.props?.checked\n        : child?.props?.defaultChecked;\n\n      return childIsSelected ? child?.props?.value : undefined;\n    })\n    .filter((v) => v !== undefined);\n\n  return selectedValues;\n};\n\nexport { staticClasses as checkBoxGroupClasses };\n\nexport type HvCheckBoxGroupClasses = ExtractNames<typeof useClasses>;\n\nexport interface HvCheckBoxGroupProps\n  extends HvBaseProps<HTMLDivElement, \"onChange\"> {\n  /**\n   * The form element name.\n   *\n   * It is propagated to the children checkboxes, unless they already have one.\n   */\n  name?: string;\n  /**\n   * The value of the form element. An array of values represented in the child checkboxes.\n   *\n   * When defined the checkbox group state becomes controlled.\n   */\n  value?: any[];\n  /**\n   * When uncontrolled, defines the initial value.\n   */\n  defaultValue?: any[];\n  /**\n   * The label of the form element.\n   *\n   * The form element must be labeled for accessibility reasons.\n   * If not provided, an aria-label or aria-labelledby must be provided instead.\n   */\n  label?: React.ReactNode;\n  /**\n   * Provide additional descriptive text for the form element.\n   */\n  description?: React.ReactNode;\n  /**\n   * Indicates that the form element is disabled.\n   * If `true` the state is propagated to the children checkboxes.\n   */\n  disabled?: boolean;\n  /**\n   * Indicates that the form element is not editable.\n   * If `true` the state is propagated to the children checkboxes.\n   */\n  readOnly?: boolean;\n  /**\n   * Indicates that user input is required on the form element.\n   */\n  required?: boolean;\n  /**\n   * The status of the form element.\n   *\n   * Valid is correct, invalid is incorrect and standBy means no validations have run.\n   *\n   * When uncontrolled and unspecified it will default to \"standBy\" and change to either \"valid\"\n   * or \"invalid\" after any change to the state.\n   */\n  status?: HvFormStatus;\n  /**\n   * The error message to show when the validation status is \"invalid\".\n   *\n   * Defaults to \"Required\" when the status is uncontrolled and no `aria-errormessage` is provided.\n   */\n  statusMessage?: React.ReactNode;\n  /**\n   * The callback fired when the value changes.\n   */\n  onChange?: (event: React.ChangeEvent<HTMLInputElement>, value: any[]) => void;\n  /**\n   * Indicates whether the checkbox group's orientation is horizontal or vertical.\n   *\n   * Defaults to vertical.\n   */\n  orientation?: \"vertical\" | \"horizontal\";\n  /**\n   * Indicates if an additional select all checkbox should be shown.\n   */\n  showSelectAll?: boolean;\n  /**\n   * The label of the select all checkbox. Defaults to \"All\".\n   */\n  selectAllLabel?: string;\n  /**\n   * Custom label for select all checkbox conjunction\n   */\n  selectAllConjunctionLabel?: string;\n  /**\n   * A Jss Object used to override or extend the component styles applied.\n   */\n  classes?: HvCheckBoxGroupClasses;\n}\n\n/**\n * A checkbox group is a type of selection list that allows the user to select multiple options through the use of checkboxes.\n */\nexport const HvCheckBoxGroup = (props: HvCheckBoxGroupProps) => {\n  const {\n    id,\n    classes: classesProp,\n    className,\n    children,\n    name,\n    label,\n    description,\n    status,\n    statusMessage,\n    defaultValue,\n    value: valueProp,\n    required = false,\n    readOnly = false,\n    disabled = false,\n    showSelectAll = false,\n    orientation = \"vertical\",\n    selectAllLabel = \"All\",\n    selectAllConjunctionLabel = \"/\",\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    \"aria-errormessage\": ariaErrorMessage,\n    onChange,\n    ...others\n  } = useDefaultProps(\"HvCheckBoxGroup\", props);\n\n  const { classes, cx } = useClasses(classesProp);\n\n  const [value, setValue] = useControlled(\n    valueProp,\n    defaultValue !== undefined\n      ? defaultValue\n      : // When uncontrolled and no default value is given,\n        // extract the initial selected values from the children own state\n        () => getValueFromSelectedChildren(children)\n  );\n\n  const [validationState, setValidationState] = useControlled(\n    status,\n    \"standBy\"\n  );\n\n  const [validationMessage] = useControlled(statusMessage, \"Required\");\n\n  const elementId = useUniqueId(id, \"hvcheckboxgroup\");\n\n  const selectionAnchor = useRef(undefined);\n\n  const [allValues, selectedState, selectedCount] = useMemo(() => {\n    const childValues: any[] = [];\n    const childSelectedState: boolean[] = [];\n    let childSelectedCounter = 0;\n\n    Children.toArray(children).forEach((child: any, i: number) => {\n      const childValue = child?.props?.value;\n      const childIsSelected = value.indexOf(childValue) !== -1;\n\n      childValues[i] = childValue;\n      childSelectedState[i] = childIsSelected;\n\n      if (childIsSelected) {\n        childSelectedCounter += 1;\n      }\n    });\n\n    return [childValues, childSelectedState, childSelectedCounter];\n  }, [children, value]);\n\n  const selectAllState = computeSelectAllState(\n    value.length,\n    selectedState.length\n  );\n\n  const onChildChangeInterceptor = useCallback(\n    (\n      index: number,\n      childOnChange: (\n        event: React.ChangeEvent<HTMLInputElement>,\n        isChecked: boolean\n      ) => void,\n      event: React.ChangeEvent<HTMLInputElement>,\n      isChecked: boolean\n    ) => {\n      const newValue = multiSelectionEventHandler(\n        event,\n        index,\n        selectionAnchor,\n        allValues,\n        selectedState,\n        isChecked\n      );\n\n      childOnChange?.(event, isChecked);\n\n      onChange?.(event, newValue);\n\n      setValue(() => {\n        // This will only run if uncontrolled\n\n        if (required && newValue.length === 0) {\n          setValidationState(\"invalid\");\n        } else {\n          setValidationState(\"valid\");\n        }\n\n        return newValue;\n      });\n    },\n    [allValues, onChange, required, selectedState, setValidationState, setValue]\n  );\n\n  const modifiedChildren = useMemo(() => {\n    return Children.map(children, (child: any, i: number) => {\n      const childIsSelected = selectedState[i];\n\n      return cloneElement(child, {\n        checked: childIsSelected,\n        name: child?.props?.name || name,\n        onChange: (\n          event: React.ChangeEvent<HTMLInputElement>,\n          isChecked: boolean\n        ) =>\n          onChildChangeInterceptor(i, child?.props?.onChange, event, isChecked),\n        disabled: disabled || child?.props?.disabled,\n        readOnly: readOnly || child?.props?.readOnly,\n      });\n    });\n  }, [\n    children,\n    disabled,\n    name,\n    onChildChangeInterceptor,\n    readOnly,\n    selectedState,\n  ]);\n\n  const handleSelectAll = (\n    event: React.ChangeEvent<HTMLInputElement>,\n    selectAllChecked: boolean\n  ) => {\n    let newValue: any[];\n    if (selectAllChecked) {\n      newValue = [...allValues];\n    } else {\n      newValue = [];\n    }\n\n    onChange?.(event, newValue);\n\n    setValue(() => {\n      // This will only run if uncontrolled\n      if (required && newValue.length === 0) {\n        setValidationState(\"invalid\");\n      } else {\n        setValidationState(\"valid\");\n      }\n\n      return newValue;\n    });\n  };\n\n  const selectAllLabelComponent =\n    selectedCount === 0 ? (\n      <>\n        <b>{selectAllLabel}</b>\n        {` (${Children.toArray(children).length})`}\n      </>\n    ) : (\n      <>\n        <b>{selectedCount}</b>\n        {` ${selectAllConjunctionLabel} ${Children.toArray(children).length}`}\n      </>\n    );\n\n  // The error message area will only be created if:\n  //   - an external element that provides an error message isn't identified via aria-errormessage AND\n  //   - both status and statusMessage properties are being controlled OR\n  //   - status is uncontrolled and required is true\n  const canShowError =\n    ariaErrorMessage == null &&\n    ((status !== undefined && statusMessage !== undefined) ||\n      (status === undefined && required));\n\n  const errorMessageId = canShowError\n    ? setId(elementId, \"error\")\n    : ariaErrorMessage;\n\n  return (\n    <HvFormElement\n      id={id}\n      name={name}\n      status={validationState}\n      disabled={disabled}\n      required={required}\n      readOnly={readOnly}\n      className={cx(classes.root, className)}\n    >\n      {label && (\n        <HvLabel\n          id={setId(elementId, \"label\")}\n          label={label}\n          className={classes.label}\n        />\n      )}\n\n      {description && (\n        <HvInfoMessage id={setId(elementId, \"description\")}>\n          {description}\n        </HvInfoMessage>\n      )}\n\n      <div\n        role=\"group\"\n        aria-label={ariaLabel}\n        aria-labelledby={\n          ariaLabelledBy || (label && setId(elementId, \"label\")) || undefined\n        }\n        aria-disabled={disabled ? true : undefined}\n        aria-invalid={validationState === \"invalid\" ? true : undefined}\n        aria-errormessage={\n          validationState === \"invalid\" ? errorMessageId : undefined\n        }\n        aria-describedby={\n          [description && setId(elementId, \"description\"), ariaDescribedBy]\n            .join(\" \")\n            .trim() || undefined\n        }\n        className={cx(classes.group, {\n          [classes.vertical]: orientation === \"vertical\",\n          [classes.horizontal]: orientation === \"horizontal\",\n          [classes.invalid]: validationState === \"invalid\",\n        })}\n        {...others}\n      >\n        {showSelectAll && (\n          <HvCheckBox\n            checked={selectAllState === \"all\"}\n            indeterminate={selectAllState === \"some\"}\n            label={selectAllLabelComponent}\n            disabled={disabled}\n            readOnly={readOnly}\n            className={classes.selectAll}\n            onChange={handleSelectAll}\n          />\n        )}\n        {modifiedChildren}\n      </div>\n\n      {canShowError && (\n        <HvWarningText\n          id={setId(elementId, \"error\")}\n          disableBorder\n          className={classes.error}\n        >\n          {validationMessage}\n        </HvWarningText>\n      )}\n    </HvFormElement>\n  );\n};\n"],"names":["computeSelectAllState","selected","total","getValueFromSelectedChildren","children","selectedValues","Children","toArray","map","child","childIsControlled","props","checked","undefined","childIsSelected","defaultChecked","value","filter","v","HvCheckBoxGroup","id","classes","classesProp","className","name","label","description","status","statusMessage","defaultValue","valueProp","required","readOnly","disabled","showSelectAll","orientation","selectAllLabel","selectAllConjunctionLabel","ariaLabel","ariaLabelledBy","ariaDescribedBy","ariaErrorMessage","onChange","others","useDefaultProps","cx","useClasses","setValue","useControlled","validationState","setValidationState","validationMessage","elementId","useUniqueId","selectionAnchor","useRef","allValues","selectedState","selectedCount","useMemo","childValues","childSelectedState","childSelectedCounter","forEach","i","childValue","indexOf","selectAllState","length","onChildChangeInterceptor","useCallback","index","childOnChange","event","isChecked","newValue","multiSelectionEventHandler","modifiedChildren","cloneElement","handleSelectAll","selectAllChecked","selectAllLabelComponent","canShowError","errorMessageId","setId","root","join","trim","group","vertical","horizontal","invalid","selectAll","error"],"mappings":"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"}
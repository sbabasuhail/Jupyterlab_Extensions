import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import _styled from "@emotion/styled/base";
import { useRef, useEffect } from "react";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { Calendar } from "@hitachivantara/uikit-react-icons";
import { theme } from "@hitachivantara/uikit-styles";
import { useControlled } from "../../hooks/useControlled.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useLabels } from "../../hooks/useLabels.js";
import { useTheme } from "../../hooks/useTheme.js";
import { setId } from "../../utils/setId.js";
import { useSavedState } from "../../utils/useSavedState.js";
import { isDate } from "../Calendar/utils.js";
import { getDateLabel } from "./utils.js";
import useVisibleDate from "./useVisibleDate.js";
import { useClasses } from "./DatePicker.styles.js";
import { staticClasses } from "./DatePicker.styles.js";
import { HvCalendar } from "../Calendar/Calendar.js";
import { HvButton } from "../Button/Button.js";
import { isInvalid } from "../Forms/FormElement/validationStates.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvBaseDropdown } from "../BaseDropdown/BaseDropdown.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
import { HvActionBar } from "../ActionBar/ActionBar.js";
import { HvTypography } from "../Typography/Typography.js";
const DEFAULT_LABELS = {
  applyLabel: "Apply",
  cancelLabel: "Cancel",
  clearLabel: "Clear",
  invalidLabel: "Invalid date"
};
const HvDatePicker = (props) => {
  const {
    classes: classesProp,
    className,
    id,
    name,
    required = false,
    disabled = false,
    readOnly,
    label,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    description,
    "aria-describedby": ariaDescribedBy,
    onChange,
    onCancel,
    onClear,
    status,
    statusMessage,
    "aria-errormessage": ariaErrorMessage,
    placeholder,
    labels: labelsProp,
    value,
    startValue,
    endValue,
    expanded,
    defaultExpanded,
    onToggle,
    rangeMode = false,
    startAdornment,
    horizontalPlacement = "right",
    locale: localeProp,
    showActions = false,
    showClear = false,
    disablePortal = true,
    escapeWithReference = true,
    dropdownProps,
    calendarProps,
    ...others
  } = useDefaultProps("HvDatePicker", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const labels = useLabels(DEFAULT_LABELS, labelsProp);
  const elementId = useUniqueId(id, "hvdatepicker");
  const [validationState, setValidationState] = useControlled(status, "standBy");
  const [validationMessage] = useControlled(statusMessage, "Required");
  const locale = localeProp || "en-US";
  const [calendarOpen, setCalendarOpen] = useControlled(expanded, Boolean(defaultExpanded));
  const [startDate, setStartDate, rollbackStartDate] = useSavedState(rangeMode ? startValue : value);
  const [endDate, setEndDate, rollbackEndDate] = useSavedState(endValue);
  const [visibleDate, dispatchAction] = useVisibleDate(startDate, endDate);
  const focusTarget = useRef(null);
  const {
    activeTheme
  } = useTheme();
  useEffect(() => {
    setStartDate(rangeMode ? startValue : value, true);
    setEndDate(endValue, true);
  }, [value, startValue, endValue, rangeMode, setStartDate, setEndDate]);
  const endDateIsSet = useRef(false);
  endDateIsSet.current = endDate != null;
  useEffect(() => {
    if (startDate != null) {
      dispatchAction({
        type: "month_year",
        target: endDateIsSet.current ? "left" : "best",
        year: startDate.getFullYear(),
        month: startDate.getMonth() + 1
      });
    }
  }, [dispatchAction, startDate]);
  useEffect(() => {
    if (endDate != null) {
      dispatchAction({
        type: "month_year",
        target: "right",
        year: endDate.getFullYear(),
        month: endDate.getMonth() + 1
      });
    }
  }, [dispatchAction, endDate]);
  const handleApply = () => {
    setStartDate(startDate, true);
    setEndDate(endDate ?? startDate, true);
    onChange == null ? void 0 : onChange(startDate, endDate);
    setValidationState(() => {
      if (required && (!isDate(startDate) || rangeMode && !isDate(endDate))) {
        return "invalid";
      }
      return "valid";
    });
    setCalendarOpen(false);
  };
  const handleCancel = () => {
    rollbackStartDate();
    rollbackEndDate();
    onCancel == null ? void 0 : onCancel();
    setCalendarOpen(false);
  };
  const handleClear = () => {
    setStartDate(void 0, false);
    setEndDate(void 0, false);
    onClear == null ? void 0 : onClear();
  };
  const handleCalendarClose = () => {
    const shouldSave = !(rangeMode || showActions);
    if (shouldSave) {
      handleApply();
    } else {
      handleCancel();
    }
  };
  const handleToggle = (evt, open) => {
    if (evt === null)
      return;
    onToggle == null ? void 0 : onToggle(evt, open);
    setCalendarOpen(open);
    if (!open)
      handleCalendarClose();
  };
  const focusOnContainer = () => {
    var _a;
    (_a = focusTarget.current) == null ? void 0 : _a.focus();
  };
  const handleDateChange = (event, newDate) => {
    if (!isDate(newDate))
      return;
    const autoSave = !showActions && !rangeMode;
    if (rangeMode) {
      if (!startDate || startDate && endDate || newDate < startDate) {
        setStartDate(newDate);
        setEndDate(void 0);
      } else {
        setEndDate(newDate);
      }
    } else {
      setStartDate(newDate, autoSave);
    }
    if (autoSave) {
      onChange == null ? void 0 : onChange(newDate);
      setValidationState(() => {
        if (required && !isDate(newDate)) {
          return "invalid";
        }
        return "valid";
      });
      setCalendarOpen(false);
    }
  };
  const handleInputDateChange = (event, newDate, position) => {
    if (!isDate(newDate))
      return;
    if (!rangeMode) {
      handleDateChange(event, newDate);
      return;
    }
    if (position === "left") {
      if (endDate)
        setStartDate(newDate > endDate ? endDate : newDate);
    } else if (position === "right") {
      if (!startDate) {
        if (endDate)
          setStartDate(newDate > endDate ? endDate : newDate);
        return;
      }
      setEndDate(newDate < startDate ? startDate : newDate);
    }
  };
  const renderActions = () => /* @__PURE__ */ jsxs(HvActionBar, { className: cx({
    [classes.actionContainer]: showClear
  }), children: [
    showClear && /* @__PURE__ */ jsx("div", { className: classes.leftContainer, children: /* @__PURE__ */ jsx(HvButton, { id: setId(id, "action", "clear"), className: classes.action, variant: "primaryGhost", onClick: handleClear, children: labels == null ? void 0 : labels.clearLabel }) }),
    /* @__PURE__ */ jsxs("div", { className: classes.rightContainer, children: [
      /* @__PURE__ */ jsx(HvButton, { id: setId(id, "action", "apply"), className: classes.action, variant: "primaryGhost", onClick: handleApply, children: labels == null ? void 0 : labels.applyLabel }),
      /* @__PURE__ */ jsx(HvButton, { id: setId(id, "action", "cancel"), className: classes.action, variant: "primaryGhost", onClick: handleCancel, children: labels == null ? void 0 : labels.cancelLabel })
    ] })
  ] });
  const styledTypography = (dateString, variant, text) => {
    const StyledTypography = /* @__PURE__ */ _styled(HvTypography, process.env.NODE_ENV === "production" ? {
      target: "e2irjnc0"
    } : {
      target: "e2irjnc0",
      label: "StyledTypography"
    })({
      color: dateString ? theme.colors.secondary : theme.datePicker.dropdownPlaceholderColor
    }, process.env.NODE_ENV === "production" ? "" : "/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9ob21lL3J1bm5lci93b3JrL2h2LXVpa2l0LXJlYWN0L2h2LXVpa2l0LXJlYWN0L3BhY2thZ2VzL2NvcmUvc3JjL2NvbXBvbmVudHMvRGF0ZVBpY2tlci9EYXRlUGlja2VyLnRzeCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFnYjZCIiwiZmlsZSI6Ii9ob21lL3J1bm5lci93b3JrL2h2LXVpa2l0LXJlYWN0L2h2LXVpa2l0LXJlYWN0L3BhY2thZ2VzL2NvcmUvc3JjL2NvbXBvbmVudHMvRGF0ZVBpY2tlci9EYXRlUGlja2VyLnRzeCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCBSZWFjdE5vZGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZURlZmF1bHRQcm9wcyB9IGZyb20gXCJAY29yZS9ob29rcy91c2VEZWZhdWx0UHJvcHNcIjtcblxuaW1wb3J0IHN0eWxlZCBmcm9tIFwiQGVtb3Rpb24vc3R5bGVkXCI7XG5cbmltcG9ydCB7IENhbGVuZGFyIH0gZnJvbSBcIkBoaXRhY2hpdmFudGFyYS91aWtpdC1yZWFjdC1pY29uc1wiO1xuaW1wb3J0IHsgdGhlbWUgfSBmcm9tIFwiQGhpdGFjaGl2YW50YXJhL3Vpa2l0LXN0eWxlc1wiO1xuXG5pbXBvcnQgeyB1c2VDb250cm9sbGVkIH0gZnJvbSBcIkBjb3JlL2hvb2tzL3VzZUNvbnRyb2xsZWRcIjtcbmltcG9ydCB7IHVzZVVuaXF1ZUlkIH0gZnJvbSBcIkBjb3JlL2hvb2tzL3VzZVVuaXF1ZUlkXCI7XG5pbXBvcnQgeyB1c2VMYWJlbHMgfSBmcm9tIFwiQGNvcmUvaG9va3MvdXNlTGFiZWxzXCI7XG5pbXBvcnQgeyB1c2VUaGVtZSB9IGZyb20gXCJAY29yZS9ob29rcy91c2VUaGVtZVwiO1xuaW1wb3J0IHsgRXh0cmFjdE5hbWVzIH0gZnJvbSBcIkBjb3JlL3V0aWxzL2NsYXNzZXNcIjtcbmltcG9ydCB7IHNldElkIH0gZnJvbSBcIkBjb3JlL3V0aWxzL3NldElkXCI7XG5pbXBvcnQgeyB1c2VTYXZlZFN0YXRlIH0gZnJvbSBcIkBjb3JlL3V0aWxzL3VzZVNhdmVkU3RhdGVcIjtcbmltcG9ydCB7XG4gIGlzSW52YWxpZCxcbiAgSHZMYWJlbCxcbiAgSHZGb3JtU3RhdHVzLFxuICBIdldhcm5pbmdUZXh0LFxuICBIdkZvcm1FbGVtZW50LFxuICBIdkluZm9NZXNzYWdlLFxuICBIdkZvcm1FbGVtZW50UHJvcHMsXG59IGZyb20gXCJAY29yZS9jb21wb25lbnRzL0Zvcm1zXCI7XG5pbXBvcnQgeyBpc0RhdGUgfSBmcm9tIFwiQGNvcmUvY29tcG9uZW50cy9DYWxlbmRhci91dGlsc1wiO1xuaW1wb3J0IHsgSHZDYWxlbmRhciwgSHZDYWxlbmRhclByb3BzIH0gZnJvbSBcIkBjb3JlL2NvbXBvbmVudHMvQ2FsZW5kYXJcIjtcbmltcG9ydCB7XG4gIEh2QmFzZURyb3Bkb3duLFxuICBIdkJhc2VEcm9wZG93blByb3BzLFxufSBmcm9tIFwiQGNvcmUvY29tcG9uZW50cy9CYXNlRHJvcGRvd25cIjtcbmltcG9ydCB7IEh2VHlwb2dyYXBoeSB9IGZyb20gXCJAY29yZS9jb21wb25lbnRzL1R5cG9ncmFwaHlcIjtcbmltcG9ydCB7IEh2QWN0aW9uQmFyIH0gZnJvbSBcIkBjb3JlL2NvbXBvbmVudHMvQWN0aW9uQmFyXCI7XG5pbXBvcnQgeyBIdkJ1dHRvbiB9IGZyb20gXCJAY29yZS9jb21wb25lbnRzL0J1dHRvblwiO1xuXG5pbXBvcnQgeyBnZXREYXRlTGFiZWwgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHVzZVZpc2libGVEYXRlIGZyb20gXCIuL3VzZVZpc2libGVEYXRlXCI7XG5pbXBvcnQgeyBzdGF0aWNDbGFzc2VzLCB1c2VDbGFzc2VzIH0gZnJvbSBcIi4vRGF0ZVBpY2tlci5zdHlsZXNcIjtcblxuZXhwb3J0IHsgc3RhdGljQ2xhc3NlcyBhcyBkYXRlUGlja2VyQ2xhc3NlcyB9O1xuXG5leHBvcnQgdHlwZSBIdkRhdGVQaWNrZXJDbGFzc2VzID0gRXh0cmFjdE5hbWVzPHR5cGVvZiB1c2VDbGFzc2VzPjtcblxuY29uc3QgREVGQVVMVF9MQUJFTFMgPSB7XG4gIGFwcGx5TGFiZWw6IFwiQXBwbHlcIixcbiAgY2FuY2VsTGFiZWw6IFwiQ2FuY2VsXCIsXG4gIGNsZWFyTGFiZWw6IFwiQ2xlYXJcIixcbiAgaW52YWxpZExhYmVsOiBcIkludmFsaWQgZGF0ZVwiLFxufTtcblxuLyoqIEBkZXByZWNhdGVkIHVzZSBgSHZGb3JtU3RhdHVzYCBpbnN0ZWFkICovXG5leHBvcnQgdHlwZSBIdkRhdGVQaWNrZXJTdGF0dXMgPSBIdkZvcm1TdGF0dXM7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSHZEYXRlUGlja2VyUHJvcHNcbiAgZXh0ZW5kcyBPbWl0PEh2Rm9ybUVsZW1lbnRQcm9wcywgXCJvbkNoYW5nZVwiPixcbiAgICBQaWNrPFxuICAgICAgSHZCYXNlRHJvcGRvd25Qcm9wcyxcbiAgICAgIFwiZGlzYWJsZVBvcnRhbFwiIHwgXCJleHBhbmRlZFwiIHwgXCJkZWZhdWx0RXhwYW5kZWRcIiB8IFwib25Ub2dnbGVcIlxuICAgID4ge1xuICAvKipcbiAgICogSWRlbnRpZmllcyB0aGUgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGFuIGVycm9yIG1lc3NhZ2UgZm9yIHRoZSBkYXRlIHBpY2tlci5cbiAgICpcbiAgICogV2lsbCBvbmx5IGJlIHVzZWQgd2hlbiB0aGUgdmFsaWRhdGlvbiBzdGF0dXMgaXMgaW52YWxpZC5cbiAgICovXG4gIFwiYXJpYS1lcnJvcm1lc3NhZ2VcIj86IHN0cmluZztcbiAgLyoqXG4gICAqIFRoZSBjYWxsYmFjayBmaXJlZCB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLlxuICAgKi9cbiAgb25DaGFuZ2U/OiAoZGF0ZT86IERhdGUsIGVuZERhdGU/OiBEYXRlKSA9PiB2b2lkO1xuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIGZpcmVkIHdoZW4gdXNlciBjbGlja3Mgb24gY2FuY2VsLlxuICAgKi9cbiAgb25DYW5jZWw/OiAoKSA9PiB2b2lkO1xuICAvKipcbiAgICogVGhlIGNhbGxiYWNrIGZpcmVkIHdoZW4gdXNlciBjbGlja3Mgb24gY2xlYXIuXG4gICAqL1xuICBvbkNsZWFyPzogKCkgPT4gdm9pZDtcbiAgLyoqXG4gICAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgbGFiZWxzIGZvciB0aGUgZGF0ZXBpY2tlci5cbiAgICovXG4gIGxhYmVscz86IHtcbiAgICAvKipcbiAgICAgKiBBcHBseSBidXR0b24gbGFiZWwuXG4gICAgICovXG4gICAgYXBwbHlMYWJlbD86IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYnV0dG9uIGxhYmVsLlxuICAgICAqL1xuICAgIGNhbmNlbExhYmVsPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIENsZWFyIGJ1dHRvbiBsYWJlbC5cbiAgICAgKi9cbiAgICBjbGVhckxhYmVsPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEludmFsaWQgRGF0ZSBsYWJlbC5cbiAgICAgKi9cbiAgICBpbnZhbGlkRGF0ZUxhYmVsPzogc3RyaW5nO1xuICB9O1xuICAvKipcbiAgICogVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGlucHV0IHdoZW4gaW4gc2luZ2xlIGNhbGVuZGFyIG1vZGUuXG4gICAqL1xuICB2YWx1ZT86IERhdGU7XG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIHN0YXJ0IGRhdGUgd2hlbiBpbiByYW5nZSBtb2RlLlxuICAgKi9cbiAgc3RhcnRWYWx1ZT86IERhdGU7XG4gIC8qKlxuICAgKiBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhlIGVuZCBkYXRlIHdoZW4gaW4gcmFuZ2UgbW9kZS5cbiAgICovXG4gIGVuZFZhbHVlPzogRGF0ZTtcbiAgLyoqXG4gICAqIEZsYWcgaW5mb3JtaW5nIGlmIHRoZSB0aGUgY29tcG9uZW50IHNob3VsZCBiZSBpbiByYW5nZSBtb2RlIG9yIGluIHNpbmdsZSBtb2RlLlxuICAgKi9cbiAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgaW4gZmF2b3VyIG9mIGRpc2NyaW1pbmF0ZWQgdW5pb25cbiAgcmFuZ2VNb2RlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFRoZSBwbGFjZW1lbnQgd2hlcmUgdGhlIGNhbGVuZGFyIHNob3VsZCBiZSBwbGFjZWQgYWNjb3JkaW5nIHRvIHRoZSBpbnB1dC4gT3B0aW9ucyBhcmUgYGxlZnRgIG9yIGByaWdodGAuXG4gICAqIE5vdGUgdGhpcyBwcm9wIG9ubHkgYWZmZWN0cyB0aGUgY2FsZW5kYXIgd2hlbiBpbiBgcmFuZ2VNb2RlYC5cbiAgICovXG4gIGhvcml6b250YWxQbGFjZW1lbnQ/OiBcImxlZnRcIiB8IFwicmlnaHRcIjtcbiAgLyoqXG4gICAqIFRoZSBjYWxlbmRhciBsb2NhbGUuIElmIHVuZGVmaW5lZCwgaXQgdXNlcyBjYWxlbmRhciBkZWZhdWx0XG4gICAqL1xuICBsb2NhbGU/OiBzdHJpbmc7XG4gIC8qKlxuICAgKiBDb250cm9scyBpZiBhY3Rpb25zIGJ1dHRvbnMgYXJlIHZpc2libGUgYXQgdGhlIGNhbGVuZGFyLlxuICAgKi9cbiAgc2hvd0FjdGlvbnM/OiBib29sZWFuO1xuICAvKipcbiAgICogQ29udHJvbHMgaWYgY2xlYXIgYnV0dG9uIGlzIHZpc2libGUgYXQgdGhlIGNhbGVuZGFyLFxuICAgKiBvbmx5IHdvcmtzIGlmIHNob3dpbmcgYWN0aW9ucyBvciBpbiByYW5nZSBtb2RlLlxuICAgKi9cbiAgc2hvd0NsZWFyPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFNldHMgaWYgdGhlIGNhbGVuZGFyIGNvbnRhaW5lciBzaG91bGQgZm9sbG93IHRoZSBkYXRlIHBpY2tlciBpbnB1dCBvdXQgb2YgdGhlIHNjcmVlbiBvciBzdGF5IHZpc2libGUuXG4gICAqL1xuICBlc2NhcGVXaXRoUmVmZXJlbmNlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEFuIGVsZW1lbnQgcGxhY2VkIGJlZm9yZSB0aGUgQ2FsZW5kYXJcbiAgICovXG4gIHN0YXJ0QWRvcm5tZW50PzogUmVhY3QuUmVhY3ROb2RlO1xuICAvKipcbiAgICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcHMgdG8gYmUgcGFzc2VkIG9udG8gdGhlIGJhc2VEcm9wZG93bi5cbiAgICovXG4gIGRyb3Bkb3duUHJvcHM/OiBQYXJ0aWFsPEh2QmFzZURyb3Bkb3duUHJvcHM+O1xuICAvKipcbiAgICogQWRkaXRpb25hbCBwcm9wcyBwYXNzZWQgdG8gdGhlIEh2Q2FsZW5kYXIgY29tcG9uZW50LlxuICAgKi9cbiAgY2FsZW5kYXJQcm9wcz86IFBhcnRpYWw8SHZDYWxlbmRhclByb3BzPjtcbiAgLyoqXG4gICAqIEEgSnNzIE9iamVjdCB1c2VkIHRvIG92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgY29tcG9uZW50IHN0eWxlcyBhcHBsaWVkLlxuICAgKi9cbiAgY2xhc3Nlcz86IEh2RGF0ZVBpY2tlckNsYXNzZXM7XG59XG5cbi8qKlxuICogQSBkYXRlIHBpY2tlciwgcG9wdXAgY2FsZW5kYXIgb3IgZGF0ZSByYW5nZSBwaWNrZXIgaXMgYSBncmFwaGljYWwgdXNlclxuICogaW50ZXJmYWNlIHdpZGdldCB3aGljaCBhbGxvd3MgdGhlIHVzZXIgdG8gc2VsZWN0IGEgZGF0ZSBmcm9tIGEgY2FsZW5kYXIuXG4gKi9cbmV4cG9ydCBjb25zdCBIdkRhdGVQaWNrZXIgPSAocHJvcHM6IEh2RGF0ZVBpY2tlclByb3BzKSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGFzc2VzOiBjbGFzc2VzUHJvcCxcbiAgICBjbGFzc05hbWUsXG5cbiAgICBpZCxcbiAgICBuYW1lLFxuXG4gICAgcmVxdWlyZWQgPSBmYWxzZSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIHJlYWRPbmx5LFxuXG4gICAgbGFiZWwsXG4gICAgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCxcbiAgICBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSxcbiAgICBkZXNjcmlwdGlvbixcbiAgICBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LFxuXG4gICAgb25DaGFuZ2UsXG4gICAgb25DYW5jZWwsXG4gICAgb25DbGVhcixcbiAgICBzdGF0dXMsXG4gICAgc3RhdHVzTWVzc2FnZSxcbiAgICBcImFyaWEtZXJyb3JtZXNzYWdlXCI6IGFyaWFFcnJvck1lc3NhZ2UsXG5cbiAgICBwbGFjZWhvbGRlcixcblxuICAgIGxhYmVsczogbGFiZWxzUHJvcCxcblxuICAgIHZhbHVlLFxuICAgIHN0YXJ0VmFsdWUsXG4gICAgZW5kVmFsdWUsXG5cbiAgICBleHBhbmRlZCxcbiAgICBkZWZhdWx0RXhwYW5kZWQsXG4gICAgb25Ub2dnbGUsXG4gICAgcmFuZ2VNb2RlID0gZmFsc2UsXG4gICAgc3RhcnRBZG9ybm1lbnQsXG4gICAgaG9yaXpvbnRhbFBsYWNlbWVudCA9IFwicmlnaHRcIixcbiAgICBsb2NhbGU6IGxvY2FsZVByb3AsXG4gICAgc2hvd0FjdGlvbnMgPSBmYWxzZSxcbiAgICBzaG93Q2xlYXIgPSBmYWxzZSxcbiAgICBkaXNhYmxlUG9ydGFsID0gdHJ1ZSxcbiAgICBlc2NhcGVXaXRoUmVmZXJlbmNlID0gdHJ1ZSxcbiAgICBkcm9wZG93blByb3BzLFxuICAgIGNhbGVuZGFyUHJvcHMsXG4gICAgLi4ub3RoZXJzXG4gIH0gPSB1c2VEZWZhdWx0UHJvcHMoXCJIdkRhdGVQaWNrZXJcIiwgcHJvcHMpO1xuXG4gIGNvbnN0IHsgY2xhc3NlcywgY3ggfSA9IHVzZUNsYXNzZXMoY2xhc3Nlc1Byb3ApO1xuICBjb25zdCBsYWJlbHMgPSB1c2VMYWJlbHMoREVGQVVMVF9MQUJFTFMsIGxhYmVsc1Byb3ApO1xuXG4gIGNvbnN0IGVsZW1lbnRJZCA9IHVzZVVuaXF1ZUlkKGlkLCBcImh2ZGF0ZXBpY2tlclwiKTtcblxuICBjb25zdCBbdmFsaWRhdGlvblN0YXRlLCBzZXRWYWxpZGF0aW9uU3RhdGVdID0gdXNlQ29udHJvbGxlZChcbiAgICBzdGF0dXMsXG4gICAgXCJzdGFuZEJ5XCJcbiAgKTtcblxuICBjb25zdCBbdmFsaWRhdGlvbk1lc3NhZ2VdID0gdXNlQ29udHJvbGxlZChzdGF0dXNNZXNzYWdlLCBcIlJlcXVpcmVkXCIpO1xuXG4gIGNvbnN0IGxvY2FsZSA9IGxvY2FsZVByb3AgfHwgXCJlbi1VU1wiO1xuXG4gIGNvbnN0IFtjYWxlbmRhck9wZW4sIHNldENhbGVuZGFyT3Blbl0gPSB1c2VDb250cm9sbGVkKFxuICAgIGV4cGFuZGVkLFxuICAgIEJvb2xlYW4oZGVmYXVsdEV4cGFuZGVkKVxuICApO1xuXG4gIGNvbnN0IFtzdGFydERhdGUsIHNldFN0YXJ0RGF0ZSwgcm9sbGJhY2tTdGFydERhdGVdID0gdXNlU2F2ZWRTdGF0ZShcbiAgICByYW5nZU1vZGUgPyBzdGFydFZhbHVlIDogdmFsdWVcbiAgKTtcbiAgY29uc3QgW2VuZERhdGUsIHNldEVuZERhdGUsIHJvbGxiYWNrRW5kRGF0ZV0gPSB1c2VTYXZlZFN0YXRlKGVuZFZhbHVlKTtcblxuICBjb25zdCBbdmlzaWJsZURhdGUsIGRpc3BhdGNoQWN0aW9uXSA9IHVzZVZpc2libGVEYXRlKHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG5cbiAgY29uc3QgZm9jdXNUYXJnZXQgPSB1c2VSZWY8SFRNTERpdkVsZW1lbnQ+KG51bGwpO1xuXG4gIGNvbnN0IHsgYWN0aXZlVGhlbWUgfSA9IHVzZVRoZW1lKCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRTdGFydERhdGUocmFuZ2VNb2RlID8gc3RhcnRWYWx1ZSA6IHZhbHVlLCB0cnVlKTtcbiAgICBzZXRFbmREYXRlKGVuZFZhbHVlLCB0cnVlKTtcbiAgfSwgW3ZhbHVlLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgcmFuZ2VNb2RlLCBzZXRTdGFydERhdGUsIHNldEVuZERhdGVdKTtcblxuICBjb25zdCBlbmREYXRlSXNTZXQgPSB1c2VSZWYoZmFsc2UpO1xuICBlbmREYXRlSXNTZXQuY3VycmVudCA9IGVuZERhdGUgIT0gbnVsbDtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChzdGFydERhdGUgIT0gbnVsbCkge1xuICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiBcIm1vbnRoX3llYXJcIixcbiAgICAgICAgdGFyZ2V0OiBlbmREYXRlSXNTZXQuY3VycmVudCA/IFwibGVmdFwiIDogXCJiZXN0XCIsXG4gICAgICAgIHllYXI6IHN0YXJ0RGF0ZS5nZXRGdWxsWWVhcigpLFxuICAgICAgICBtb250aDogc3RhcnREYXRlLmdldE1vbnRoKCkgKyAxLFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbZGlzcGF0Y2hBY3Rpb24sIHN0YXJ0RGF0ZV0pO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKGVuZERhdGUgIT0gbnVsbCkge1xuICAgICAgZGlzcGF0Y2hBY3Rpb24oe1xuICAgICAgICB0eXBlOiBcIm1vbnRoX3llYXJcIixcbiAgICAgICAgdGFyZ2V0OiBcInJpZ2h0XCIsXG4gICAgICAgIHllYXI6IGVuZERhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgbW9udGg6IGVuZERhdGUuZ2V0TW9udGgoKSArIDEsXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtkaXNwYXRjaEFjdGlvbiwgZW5kRGF0ZV0pO1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBgQXBwbHlgIGFjdGlvbi4gQm90aCBzaW5nbGUgYW5kIHJhbmdlZCBtb2RlcyBhcmUgaGFuZGxlZCBoZXJlLlxuICAgKi9cbiAgY29uc3QgaGFuZGxlQXBwbHkgPSAoKSA9PiB7XG4gICAgc2V0U3RhcnREYXRlKHN0YXJ0RGF0ZSwgdHJ1ZSk7XG4gICAgc2V0RW5kRGF0ZShlbmREYXRlID8/IHN0YXJ0RGF0ZSwgdHJ1ZSk7XG5cbiAgICBvbkNoYW5nZT8uKHN0YXJ0RGF0ZSwgZW5kRGF0ZSk7XG5cbiAgICBzZXRWYWxpZGF0aW9uU3RhdGUoKCkgPT4ge1xuICAgICAgLy8gdGhpcyB3aWxsIG9ubHkgcnVuIGlmIHN0YXR1cyBpcyB1bmNvbnRyb2xsZWRcbiAgICAgIGlmIChyZXF1aXJlZCAmJiAoIWlzRGF0ZShzdGFydERhdGUpIHx8IChyYW5nZU1vZGUgJiYgIWlzRGF0ZShlbmREYXRlKSkpKSB7XG4gICAgICAgIHJldHVybiBcImludmFsaWRcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFwidmFsaWRcIjtcbiAgICB9KTtcblxuICAgIHNldENhbGVuZGFyT3BlbihmYWxzZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGBDYW5jZWxgIGFjdGlvbi4gQm90aCBzaW5nbGUgYW5kIHJhbmdlZCBtb2RlcyBhcmUgaGFuZGxlZCBoZXJlLlxuICAgKi9cbiAgY29uc3QgaGFuZGxlQ2FuY2VsID0gKCkgPT4ge1xuICAgIHJvbGxiYWNrU3RhcnREYXRlKCk7XG4gICAgcm9sbGJhY2tFbmREYXRlKCk7XG5cbiAgICBvbkNhbmNlbD8uKCk7XG5cbiAgICBzZXRDYWxlbmRhck9wZW4oZmFsc2UpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBgQ2FuY2VsYCBhY3Rpb24uIEJvdGggc2luZ2xlIGFuZCByYW5nZWQgbW9kZXMgYXJlIGhhbmRsZWQgaGVyZS5cbiAgICovXG4gIGNvbnN0IGhhbmRsZUNsZWFyID0gKCkgPT4ge1xuICAgIHNldFN0YXJ0RGF0ZSh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICBzZXRFbmREYXRlKHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIG9uQ2xlYXI/LigpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZUNhbGVuZGFyQ2xvc2UgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2hvdWxkU2F2ZSA9ICEocmFuZ2VNb2RlIHx8IHNob3dBY3Rpb25zKTtcbiAgICBpZiAoc2hvdWxkU2F2ZSkge1xuICAgICAgaGFuZGxlQXBwbHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFuZGxlQ2FuY2VsKCk7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVRvZ2dsZTogSHZCYXNlRHJvcGRvd25Qcm9wc1tcIm9uVG9nZ2xlXCJdID0gKGV2dCwgb3BlbikgPT4ge1xuICAgIC8qIFxuICAgICBJZiBldnQgaXMgbnVsbCB0aGlzIHRvZ2dsZSB3YXNuJ3QgdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyLlxuICAgICBpbnN0ZWFkIGl0IHdhcyB0cmlnZ2VyZWQgYnkgdGhlIGJhc2VEcm9wZG93biB1c2VFZmZlY3QgYWZ0ZXJcbiAgICAgdGhlIGRhdGVwaWNrZXIgY2hhbmdlZCB0aGUgZXhwYW5kZWQgdmFsdWUgdGhpcyBiYXNlRHJvcGRvd24gYmVoYXZpb3IgbmVlZHMgYSByZXZpZXdcbiAgICAqL1xuICAgIGlmIChldnQgPT09IG51bGwpIHJldHVybjtcbiAgICBvblRvZ2dsZT8uKGV2dCwgb3Blbik7XG4gICAgc2V0Q2FsZW5kYXJPcGVuKG9wZW4pO1xuICAgIGlmICghb3BlbikgaGFuZGxlQ2FsZW5kYXJDbG9zZSgpO1xuICB9O1xuXG4gIGNvbnN0IGZvY3VzT25Db250YWluZXIgPSAoKSA9PiB7XG4gICAgZm9jdXNUYXJnZXQuY3VycmVudD8uZm9jdXMoKTtcbiAgfTtcblxuICBjb25zdCBoYW5kbGVEYXRlQ2hhbmdlOiBIdkNhbGVuZGFyUHJvcHNbXCJvbkNoYW5nZVwiXSA9IChldmVudCwgbmV3RGF0ZSkgPT4ge1xuICAgIGlmICghaXNEYXRlKG5ld0RhdGUpKSByZXR1cm47XG5cbiAgICBjb25zdCBhdXRvU2F2ZSA9ICFzaG93QWN0aW9ucyAmJiAhcmFuZ2VNb2RlO1xuXG4gICAgaWYgKHJhbmdlTW9kZSkge1xuICAgICAgaWYgKCFzdGFydERhdGUgfHwgKHN0YXJ0RGF0ZSAmJiBlbmREYXRlKSB8fCBuZXdEYXRlIDwgc3RhcnREYXRlKSB7XG4gICAgICAgIHNldFN0YXJ0RGF0ZShuZXdEYXRlKTtcbiAgICAgICAgc2V0RW5kRGF0ZSh1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0RW5kRGF0ZShuZXdEYXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3RhcnREYXRlKG5ld0RhdGUsIGF1dG9TYXZlKTtcbiAgICB9XG5cbiAgICBpZiAoYXV0b1NhdmUpIHtcbiAgICAgIG9uQ2hhbmdlPy4obmV3RGF0ZSk7XG5cbiAgICAgIHNldFZhbGlkYXRpb25TdGF0ZSgoKSA9PiB7XG4gICAgICAgIC8vIHRoaXMgd2lsbCBvbmx5IHJ1biBpZiBzdGF0dXMgaXMgdW5jb250cm9sbGVkXG4gICAgICAgIGlmIChyZXF1aXJlZCAmJiAhaXNEYXRlKG5ld0RhdGUpKSB7XG4gICAgICAgICAgcmV0dXJuIFwiaW52YWxpZFwiO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwidmFsaWRcIjtcbiAgICAgIH0pO1xuXG4gICAgICBzZXRDYWxlbmRhck9wZW4oZmFsc2UpO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBoYW5kbGVJbnB1dERhdGVDaGFuZ2U6IEh2Q2FsZW5kYXJQcm9wc1tcIm9uSW5wdXRDaGFuZ2VcIl0gPSAoXG4gICAgZXZlbnQsXG4gICAgbmV3RGF0ZSxcbiAgICBwb3NpdGlvblxuICApID0+IHtcbiAgICBpZiAoIWlzRGF0ZShuZXdEYXRlKSkgcmV0dXJuO1xuXG4gICAgaWYgKCFyYW5nZU1vZGUpIHtcbiAgICAgIGhhbmRsZURhdGVDaGFuZ2UoZXZlbnQgYXMgYW55LCBuZXdEYXRlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPT09IFwibGVmdFwiKSB7XG4gICAgICBpZiAoZW5kRGF0ZSkgc2V0U3RhcnREYXRlKG5ld0RhdGUgPiBlbmREYXRlID8gZW5kRGF0ZSA6IG5ld0RhdGUpO1xuICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwicmlnaHRcIikge1xuICAgICAgaWYgKCFzdGFydERhdGUpIHtcbiAgICAgICAgaWYgKGVuZERhdGUpIHNldFN0YXJ0RGF0ZShuZXdEYXRlID4gZW5kRGF0ZSA/IGVuZERhdGUgOiBuZXdEYXRlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0RW5kRGF0ZShuZXdEYXRlIDwgc3RhcnREYXRlID8gc3RhcnREYXRlIDogbmV3RGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBjb250YWluZXIgZm9yIHRoZSBhY3Rpb24gZWxlbWVudHMuXG4gICAqL1xuICBjb25zdCByZW5kZXJBY3Rpb25zID0gKCkgPT4gKFxuICAgIDxIdkFjdGlvbkJhciBjbGFzc05hbWU9e2N4KHsgW2NsYXNzZXMuYWN0aW9uQ29udGFpbmVyXTogc2hvd0NsZWFyIH0pfT5cbiAgICAgIHtzaG93Q2xlYXIgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Y2xhc3Nlcy5sZWZ0Q29udGFpbmVyfT5cbiAgICAgICAgICA8SHZCdXR0b25cbiAgICAgICAgICAgIGlkPXtzZXRJZChpZCwgXCJhY3Rpb25cIiwgXCJjbGVhclwiKX1cbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy5hY3Rpb259XG4gICAgICAgICAgICB2YXJpYW50PVwicHJpbWFyeUdob3N0XCJcbiAgICAgICAgICAgIG9uQ2xpY2s9e2hhbmRsZUNsZWFyfVxuICAgICAgICAgID5cbiAgICAgICAgICAgIHtsYWJlbHM/LmNsZWFyTGFiZWx9XG4gICAgICAgICAgPC9IdkJ1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMucmlnaHRDb250YWluZXJ9PlxuICAgICAgICA8SHZCdXR0b25cbiAgICAgICAgICBpZD17c2V0SWQoaWQsIFwiYWN0aW9uXCIsIFwiYXBwbHlcIil9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLmFjdGlvbn1cbiAgICAgICAgICB2YXJpYW50PVwicHJpbWFyeUdob3N0XCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVBcHBseX1cbiAgICAgICAgPlxuICAgICAgICAgIHtsYWJlbHM/LmFwcGx5TGFiZWx9XG4gICAgICAgIDwvSHZCdXR0b24+XG4gICAgICAgIDxIdkJ1dHRvblxuICAgICAgICAgIGlkPXtzZXRJZChpZCwgXCJhY3Rpb25cIiwgXCJjYW5jZWxcIil9XG4gICAgICAgICAgY2xhc3NOYW1lPXtjbGFzc2VzLmFjdGlvbn1cbiAgICAgICAgICB2YXJpYW50PVwicHJpbWFyeUdob3N0XCJcbiAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVDYW5jZWx9XG4gICAgICAgID5cbiAgICAgICAgICB7bGFiZWxzPy5jYW5jZWxMYWJlbH1cbiAgICAgICAgPC9IdkJ1dHRvbj5cbiAgICAgIDwvZGl2PlxuICAgIDwvSHZBY3Rpb25CYXI+XG4gICk7XG5cbiAgY29uc3Qgc3R5bGVkVHlwb2dyYXBoeSA9IChcbiAgICBkYXRlU3RyaW5nOiBzdHJpbmcsXG4gICAgdmFyaWFudDogYW55LFxuICAgIHRleHQ6IFJlYWN0Tm9kZVxuICApID0+IHtcbiAgICBjb25zdCBTdHlsZWRUeXBvZ3JhcGh5ID0gc3R5bGVkKEh2VHlwb2dyYXBoeSkoe1xuICAgICAgY29sb3I6IGRhdGVTdHJpbmdcbiAgICAgICAgPyB0aGVtZS5jb2xvcnMuc2Vjb25kYXJ5XG4gICAgICAgIDogdGhlbWUuZGF0ZVBpY2tlci5kcm9wZG93blBsYWNlaG9sZGVyQ29sb3IsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gPFN0eWxlZFR5cG9ncmFwaHkgdmFyaWFudD17dmFyaWFudH0+e3RleHR9PC9TdHlsZWRUeXBvZ3JhcGh5PjtcbiAgfTtcblxuICBjb25zdCByZW5kZXJJbnB1dCA9IChkYXRlU3RyaW5nOiBzdHJpbmcpID0+XG4gICAgc3R5bGVkVHlwb2dyYXBoeShcbiAgICAgIGRhdGVTdHJpbmcsXG4gICAgICBhY3RpdmVUaGVtZT8uZGF0ZVBpY2tlci5wbGFjZWhvbGRlclZhcmlhbnQsXG4gICAgICAoZGF0ZVN0cmluZyB8fCBwbGFjZWhvbGRlcikgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBkYXRlU3RyaW5nIHx8IHBsYWNlaG9sZGVyXG4gICAgKTtcblxuICBjb25zdCBkYXRlVmFsdWUgPSByYW5nZU1vZGUgPyB7IHN0YXJ0RGF0ZSwgZW5kRGF0ZSB9IDogc3RhcnREYXRlO1xuXG4gIGNvbnN0IGhhc0xhYmVsID0gbGFiZWwgIT0gbnVsbDtcbiAgY29uc3QgaGFzRGVzY3JpcHRpb24gPSBkZXNjcmlwdGlvbiAhPSBudWxsO1xuXG4gIC8vIHRoZSBlcnJvciBtZXNzYWdlIGFyZWEgd2lsbCBvbmx5IGJlIGNyZWF0ZWQgaWY6XG4gIC8vIC0gYW4gZXh0ZXJuYWwgZWxlbWVudCB0aGF0IHByb3ZpZGVzIGFuIGVycm9yIG1lc3NhZ2UgaXNuJ3QgaWRlbnRpZmllZCB2aWEgYXJpYS1lcnJvcm1lc3NhZ2UgQU5EXG4gIC8vICAgLSBib3RoIHN0YXR1cyBhbmQgc3RhdHVzTWVzc2FnZSBwcm9wZXJ0aWVzIGFyZSBiZWluZyBjb250cm9sbGVkIE9SXG4gIC8vICAgLSBzdGF0dXMgaXMgdW5jb250cm9sbGVkIGFuZCByZXF1aXJlZCBpcyB0cnVlXG4gIGNvbnN0IGNhblNob3dFcnJvciA9XG4gICAgYXJpYUVycm9yTWVzc2FnZSA9PSBudWxsICYmXG4gICAgKChzdGF0dXMgIT09IHVuZGVmaW5lZCAmJiBzdGF0dXNNZXNzYWdlICE9PSB1bmRlZmluZWQpIHx8XG4gICAgICAoc3RhdHVzID09PSB1bmRlZmluZWQgJiYgcmVxdWlyZWQpKTtcblxuICBjb25zdCBpc1N0YXRlSW52YWxpZCA9IGlzSW52YWxpZCh2YWxpZGF0aW9uU3RhdGUpO1xuXG4gIGxldCBlcnJvck1lc3NhZ2VJZDtcbiAgaWYgKGlzU3RhdGVJbnZhbGlkKSB7XG4gICAgZXJyb3JNZXNzYWdlSWQgPSBjYW5TaG93RXJyb3JcbiAgICAgID8gc2V0SWQoZWxlbWVudElkLCBcImVycm9yXCIpXG4gICAgICA6IGFyaWFFcnJvck1lc3NhZ2U7XG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxIdkZvcm1FbGVtZW50XG4gICAgICBpZD17aWR9XG4gICAgICBuYW1lPXtuYW1lfVxuICAgICAgdmFsdWU9e2RhdGVWYWx1ZX1cbiAgICAgIHN0YXR1cz17dmFsaWRhdGlvblN0YXRlfVxuICAgICAgZGlzYWJsZWQ9e2Rpc2FibGVkfVxuICAgICAgcmVxdWlyZWQ9e3JlcXVpcmVkfVxuICAgICAgY2xhc3NOYW1lPXtjeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSl9XG4gICAgICByZWFkT25seT17cmVhZE9ubHl9XG4gICAgICB7Li4ub3RoZXJzfVxuICAgID5cbiAgICAgIHsoaGFzTGFiZWwgfHwgaGFzRGVzY3JpcHRpb24pICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMubGFiZWxDb250YWluZXJ9PlxuICAgICAgICAgIHtoYXNMYWJlbCAmJiAoXG4gICAgICAgICAgICA8SHZMYWJlbFxuICAgICAgICAgICAgICBpZD17c2V0SWQoZWxlbWVudElkLCBcImxhYmVsXCIpfVxuICAgICAgICAgICAgICBsYWJlbD17bGFiZWx9XG4gICAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy5sYWJlbH1cbiAgICAgICAgICAgIC8+XG4gICAgICAgICAgKX1cblxuICAgICAgICAgIHtoYXNEZXNjcmlwdGlvbiAmJiAoXG4gICAgICAgICAgICA8SHZJbmZvTWVzc2FnZVxuICAgICAgICAgICAgICBpZD17c2V0SWQoZWxlbWVudElkLCBcImRlc2NyaXB0aW9uXCIpfVxuICAgICAgICAgICAgICBjbGFzc05hbWU9e2NsYXNzZXMuZGVzY3JpcHRpb259XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtkZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIDwvSHZJbmZvTWVzc2FnZT5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICA8SHZCYXNlRHJvcGRvd25cbiAgICAgICAgcm9sZT1cImNvbWJvYm94XCJcbiAgICAgICAgY2xhc3Nlcz17e1xuICAgICAgICAgIHJvb3Q6IGNsYXNzZXMuZHJvcGRvd24sXG4gICAgICAgICAgcGFuZWw6IGNsYXNzZXMucGFuZWwsXG4gICAgICAgICAgaGVhZGVyOiBjeCh7IFtjbGFzc2VzLmRyb3Bkb3duSGVhZGVySW52YWxpZF06IGlzU3RhdGVJbnZhbGlkIH0pLFxuICAgICAgICAgIGhlYWRlck9wZW46IGNsYXNzZXMuZHJvcGRvd25IZWFkZXJPcGVuLFxuICAgICAgICB9fVxuICAgICAgICByZWFkT25seT17cmVhZE9ubHl9XG4gICAgICAgIGRpc2FibGVkPXtkaXNhYmxlZH1cbiAgICAgICAgZGlzYWJsZVBvcnRhbD17ZGlzYWJsZVBvcnRhbH1cbiAgICAgICAgdmFyaWFibGVXaWR0aFxuICAgICAgICBwbGFjZW1lbnQ9e2hvcml6b250YWxQbGFjZW1lbnR9XG4gICAgICAgIGV4cGFuZGVkPXtjYWxlbmRhck9wZW59XG4gICAgICAgIG9uVG9nZ2xlPXtoYW5kbGVUb2dnbGV9XG4gICAgICAgIG9uQ2xpY2tPdXRzaWRlPXtoYW5kbGVDYWxlbmRhckNsb3NlfVxuICAgICAgICBvbkNvbnRhaW5lckNyZWF0aW9uPXtmb2N1c09uQ29udGFpbmVyfVxuICAgICAgICBwbGFjZWhvbGRlcj17cmVuZGVySW5wdXQoZ2V0RGF0ZUxhYmVsKGRhdGVWYWx1ZSwgcmFuZ2VNb2RlLCBsb2NhbGUpKX1cbiAgICAgICAgYWRvcm5tZW50PXtcbiAgICAgICAgICA8Q2FsZW5kYXJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy5pY29ufVxuICAgICAgICAgICAgY29sb3I9e2Rpc2FibGVkID8gXCJzZWNvbmRhcnlfODBcIiA6IHVuZGVmaW5lZH1cbiAgICAgICAgICAvPlxuICAgICAgICB9XG4gICAgICAgIHBvcHBlclByb3BzPXt7XG4gICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwicHJldmVudE92ZXJmbG93XCIsIGVuYWJsZWQ6IGVzY2FwZVdpdGhSZWZlcmVuY2UgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9fVxuICAgICAgICBhcmlhLWhhc3BvcHVwPVwiZGlhbG9nXCJcbiAgICAgICAgYXJpYS1sYWJlbD17YXJpYUxhYmVsfVxuICAgICAgICBhcmlhLWxhYmVsbGVkYnk9e1xuICAgICAgICAgIFtsYWJlbCAmJiBzZXRJZChlbGVtZW50SWQsIFwibGFiZWxcIiksIGFyaWFMYWJlbGxlZEJ5XVxuICAgICAgICAgICAgLmpvaW4oXCIgXCIpXG4gICAgICAgICAgICAudHJpbSgpIHx8IHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgICAgIGFyaWEtaW52YWxpZD17aXNTdGF0ZUludmFsaWQgPyB0cnVlIDogdW5kZWZpbmVkfVxuICAgICAgICBhcmlhLWVycm9ybWVzc2FnZT17ZXJyb3JNZXNzYWdlSWR9XG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9e1xuICAgICAgICAgIFtkZXNjcmlwdGlvbiAmJiBzZXRJZChlbGVtZW50SWQsIFwiZGVzY3JpcHRpb25cIiksIGFyaWFEZXNjcmliZWRCeV1cbiAgICAgICAgICAgIC5qb2luKFwiIFwiKVxuICAgICAgICAgICAgLnRyaW0oKSB8fCB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgICAgICB7Li4uZHJvcGRvd25Qcm9wc31cbiAgICAgID5cbiAgICAgICAgPGRpdiByZWY9e2ZvY3VzVGFyZ2V0fSB0YWJJbmRleD17LTF9IC8+XG4gICAgICAgIDxIdkNhbGVuZGFyXG4gICAgICAgICAgaWQ9e3NldElkKGlkLCBcImNhbGVuZGFyXCIpfVxuICAgICAgICAgIHN0YXJ0QWRvcm5tZW50PXtzdGFydEFkb3JubWVudH1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlRGF0ZUNoYW5nZX1cbiAgICAgICAgICBvbklucHV0Q2hhbmdlPXtoYW5kbGVJbnB1dERhdGVDaGFuZ2V9XG4gICAgICAgICAgb25WaXNpYmxlRGF0ZUNoYW5nZT17KF9ldmVudCwgdHlwZSwgbW9udGgsIHRhcmdldCkgPT4ge1xuICAgICAgICAgICAgZGlzcGF0Y2hBY3Rpb24oeyB0eXBlLCB0YXJnZXQsIG1vbnRoIH0pO1xuICAgICAgICAgIH19XG4gICAgICAgICAgbG9jYWxlPXtsb2NhbGV9XG4gICAgICAgICAgey4uLnZpc2libGVEYXRlfVxuICAgICAgICAgIHsuLi5jYWxlbmRhclByb3BzfVxuICAgICAgICAgIGludmFsaWREYXRlTGFiZWw9e2xhYmVscz8uaW52YWxpZERhdGVMYWJlbH1cbiAgICAgICAgLz5cbiAgICAgICAgeyhyYW5nZU1vZGUgfHwgc2hvd0FjdGlvbnMpICYmIHJlbmRlckFjdGlvbnMoKX1cbiAgICAgIDwvSHZCYXNlRHJvcGRvd24+XG4gICAgICB7Y2FuU2hvd0Vycm9yICYmIChcbiAgICAgICAgPEh2V2FybmluZ1RleHRcbiAgICAgICAgICBpZD17c2V0SWQoZWxlbWVudElkLCBcImVycm9yXCIpfVxuICAgICAgICAgIGRpc2FibGVCb3JkZXJcbiAgICAgICAgICBjbGFzc05hbWU9e2N4KGNsYXNzZXMuZXJyb3IpfVxuICAgICAgICA+XG4gICAgICAgICAge3ZhbGlkYXRpb25NZXNzYWdlfVxuICAgICAgICA8L0h2V2FybmluZ1RleHQ+XG4gICAgICApfVxuICAgIDwvSHZGb3JtRWxlbWVudD5cbiAgKTtcbn07XG4iXX0= */");
    return /* @__PURE__ */ jsx(StyledTypography, { variant, children: text });
  };
  const renderInput = (dateString) => styledTypography(dateString, activeTheme == null ? void 0 : activeTheme.datePicker.placeholderVariant, (dateString || placeholder) === void 0 ? "" : dateString || placeholder);
  const dateValue = rangeMode ? {
    startDate,
    endDate
  } : startDate;
  const hasLabel = label != null;
  const hasDescription = description != null;
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const isStateInvalid = isInvalid(validationState);
  let errorMessageId;
  if (isStateInvalid) {
    errorMessageId = canShowError ? setId(elementId, "error") : ariaErrorMessage;
  }
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, value: dateValue, status: validationState, disabled, required, className: cx(classes.root, className), readOnly, ...others, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsx(HvLabel, { id: setId(elementId, "label"), label, className: classes.label }),
      hasDescription && /* @__PURE__ */ jsx(HvInfoMessage, { id: setId(elementId, "description"), className: classes.description, children: description })
    ] }),
    /* @__PURE__ */ jsxs(HvBaseDropdown, { role: "combobox", classes: {
      root: classes.dropdown,
      panel: classes.panel,
      header: cx({
        [classes.dropdownHeaderInvalid]: isStateInvalid
      }),
      headerOpen: classes.dropdownHeaderOpen
    }, readOnly, disabled, disablePortal, variableWidth: true, placement: horizontalPlacement, expanded: calendarOpen, onToggle: handleToggle, onClickOutside: handleCalendarClose, onContainerCreation: focusOnContainer, placeholder: renderInput(getDateLabel(dateValue, rangeMode, locale)), adornment: /* @__PURE__ */ jsx(Calendar, { className: classes.icon, color: disabled ? "secondary_80" : void 0 }), popperProps: {
      modifiers: [{
        name: "preventOverflow",
        enabled: escapeWithReference
      }]
    }, "aria-haspopup": "dialog", "aria-label": ariaLabel, "aria-labelledby": [label && setId(elementId, "label"), ariaLabelledBy].join(" ").trim() || void 0, "aria-invalid": isStateInvalid ? true : void 0, "aria-errormessage": errorMessageId, "aria-describedby": [description && setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, ...dropdownProps, children: [
      /* @__PURE__ */ jsx("div", { ref: focusTarget, tabIndex: -1 }),
      /* @__PURE__ */ jsx(HvCalendar, { id: setId(id, "calendar"), startAdornment, onChange: handleDateChange, onInputChange: handleInputDateChange, onVisibleDateChange: (_event, type, month, target) => {
        dispatchAction({
          type,
          target,
          month
        });
      }, locale, ...visibleDate, ...calendarProps, invalidDateLabel: labels == null ? void 0 : labels.invalidDateLabel }),
      (rangeMode || showActions) && renderActions()
    ] }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), disableBorder: true, className: cx(classes.error), children: validationMessage })
  ] });
};
export {
  HvDatePicker,
  staticClasses as datePickerClasses
};
//# sourceMappingURL=DatePicker.js.map

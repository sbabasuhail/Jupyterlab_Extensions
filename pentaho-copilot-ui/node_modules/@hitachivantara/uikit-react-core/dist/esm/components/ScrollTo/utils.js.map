{"version":3,"file":"utils.js","sources":["../../../../src/components/ScrollTo/utils.ts"],"sourcesContent":["import { HvScrollToVerticalOption } from \"./types\";\n\ntype ExtendedWindow = Window & typeof globalThis & HTMLElement;\n\nexport const getScrollTop = (\n  c: HTMLElement | (Window & typeof globalThis) = window\n) => {\n  if (c === window) {\n    return (\n      window.scrollY ||\n      window.pageYOffset ||\n      (document.documentElement && document.documentElement.scrollTop) ||\n      document.body.scrollTop\n    );\n  }\n\n  return (c as ExtendedWindow).scrollTop;\n};\n\nexport const verticalScrollOffset = (\n  t: HTMLElement | (Window & typeof globalThis),\n  c: HTMLElement | (Window & typeof globalThis) = window\n) => {\n  if (c === window) {\n    return (\n      ((t as ExtendedWindow)?.getBoundingClientRect?.().top || 0) +\n      (window.scrollY || window.pageYOffset)\n    );\n  }\n  if (getComputedStyle(c as ExtendedWindow).position !== \"static\") {\n    return (t as ExtendedWindow).offsetTop;\n  }\n\n  return (t as ExtendedWindow).offsetTop - (c as ExtendedWindow).offsetTop;\n};\n\nexport const horizontalScrollOffset = (\n  t: HTMLElement,\n  c: HTMLElement | (Window & typeof globalThis) = window\n) => {\n  if (c === window) {\n    return (\n      (t?.getBoundingClientRect?.().left || 0) +\n      (window.scrollX || window.pageXOffset)\n    );\n  }\n  if (getComputedStyle(c as ExtendedWindow).position !== \"static\") {\n    return t.offsetLeft;\n  }\n\n  return t.offsetLeft - (c as ExtendedWindow).offsetLeft;\n};\n\nexport const scrollElement = (\n  element: HTMLElement,\n  container: HTMLElement | (Window & typeof globalThis),\n  offset: number = 0,\n  direction?: \"row\" | \"column\"\n) => {\n  if (direction === \"row\") {\n    const elemLeft = horizontalScrollOffset(element, container);\n    container?.scrollTo?.({\n      left: elemLeft - offset,\n      behavior: \"smooth\",\n    });\n  } else {\n    const elemTop = verticalScrollOffset(element, container);\n    container?.scrollTo?.({\n      top: elemTop - offset,\n      behavior: \"smooth\",\n    });\n  }\n  element.focus({ preventScroll: true });\n};\n\nexport const isScrolledToTheBottom = (\n  container: HTMLElement | (Window & typeof globalThis)\n) => {\n  const containerScrollTop = getScrollTop(container);\n\n  if (container === window) {\n    // Accounting for cases where html/body are set to height:100%\n    const scrollHeight =\n      (document.documentElement && document.documentElement.scrollHeight) ||\n      document.body.scrollHeight;\n\n    return containerScrollTop + window.innerHeight >= scrollHeight;\n  }\n\n  return (\n    containerScrollTop + (container as ExtendedWindow).offsetHeight >=\n    (container as ExtendedWindow).scrollHeight\n  );\n};\n\nexport const findFirstVisibleElement = (\n  container: HTMLElement | (Window & typeof globalThis),\n  options: HvScrollToVerticalOption[],\n  offset: number\n) => {\n  const boundsTop = verticalScrollOffset(container);\n\n  let i = 0;\n\n  // Find index of first element whose top is still visible inside the container\n  for (; i < options.length; i += 1) {\n    const ele = document.getElementById(options[i].value);\n\n    if (ele) {\n      const elemTop = verticalScrollOffset(ele) - (options[i].offset || offset);\n\n      if (elemTop > boundsTop) {\n        break;\n      }\n    }\n  }\n\n  // Return the previous index, the element that last scrolled past the top\n  return i - 1;\n};\n"],"names":["getScrollTop","c","window","scrollY","pageYOffset","document","documentElement","scrollTop","body","verticalScrollOffset","t","getBoundingClientRect","top","getComputedStyle","position","offsetTop","horizontalScrollOffset","left","scrollX","pageXOffset","offsetLeft","scrollElement","element","container","offset","direction","elemLeft","scrollTo","behavior","elemTop","focus","preventScroll","isScrolledToTheBottom","containerScrollTop","scrollHeight","innerHeight","offsetHeight","findFirstVisibleElement","options","boundsTop","i","length","ele","getElementById","value"],"mappings":"AAIaA,MAAAA,eAAeA,CAC1BC,IAAgDC,WAC7C;AACH,MAAID,MAAMC,QAAQ;AAEdA,WAAAA,OAAOC,WACPD,OAAOE,eACNC,SAASC,mBAAmBD,SAASC,gBAAgBC,aACtDF,SAASG,KAAKD;AAAAA,EAElB;AAEA,SAAQN,EAAqBM;AAC/B;AAEO,MAAME,uBAAuBA,CAClCC,GACAT,IAAgDC,WAC7C;AAlBQF;AAmBX,MAAIC,MAAMC,QAAQ;AAChB,cACIQ,4BAAsBC,0BAAtBD,2BAAgDE,QAAO,MACxDV,OAAOC,WAAWD,OAAOE;AAAAA,EAE9B;AACA,MAAIS,iBAAiBZ,GAAqBa,aAAa,UAAU;AAC/D,WAAQJ,EAAqBK;AAAAA,EAC/B;AAEQL,SAAAA,EAAqBK,YAAad,EAAqBc;AACjE;AAEO,MAAMC,yBAAyBA,CACpCN,GACAT,IAAgDC,WAC7C;AAnCQF;AAoCX,MAAIC,MAAMC,QAAQ;AAChB,cACGQ,4BAAGC,0BAAHD,2BAA6BO,SAAQ,MACrCf,OAAOgB,WAAWhB,OAAOiB;AAAAA,EAE9B;AACA,MAAIN,iBAAiBZ,GAAqBa,aAAa,UAAU;AAC/D,WAAOJ,EAAEU;AAAAA,EACX;AAEOV,SAAAA,EAAEU,aAAcnB,EAAqBmB;AAC9C;AAEO,MAAMC,gBAAgBA,CAC3BC,SACAC,WACAC,SAAiB,GACjBC,cACG;AAtDQzB;AAuDX,MAAIyB,cAAc,OAAO;AACjBC,UAAAA,WAAWV,uBAAuBM,SAASC,SAAS;AAC1DA,iDAAWI,aAAXJ,mCAAsB;AAAA,MACpBN,MAAMS,WAAWF;AAAAA,MACjBI,UAAU;AAAA,IAAA;AAAA,EACX,OACI;AACCC,UAAAA,UAAUpB,qBAAqBa,SAASC,SAAS;AACvDA,iDAAWI,aAAXJ,mCAAsB;AAAA,MACpBX,KAAKiB,UAAUL;AAAAA,MACfI,UAAU;AAAA,IAAA;AAAA,EAEd;AACAN,UAAQQ,MAAM;AAAA,IAAEC,eAAe;AAAA,EAAA,CAAM;AACvC;AAEaC,MAAAA,wBAAwBA,CACnCT,cACG;AACGU,QAAAA,qBAAqBjC,aAAauB,SAAS;AAEjD,MAAIA,cAAcrB,QAAQ;AAExB,UAAMgC,eACH7B,SAASC,mBAAmBD,SAASC,gBAAgB4B,gBACtD7B,SAASG,KAAK0B;AAETD,WAAAA,qBAAqB/B,OAAOiC,eAAeD;AAAAA,EACpD;AAGED,SAAAA,qBAAsBV,UAA6Ba,gBAClDb,UAA6BW;AAElC;AAEO,MAAMG,0BAA0BA,CACrCd,WACAe,SACAd,WACG;AACGe,QAAAA,YAAY9B,qBAAqBc,SAAS;AAEhD,MAAIiB,IAAI;AAGR,SAAOA,IAAIF,QAAQG,QAAQD,KAAK,GAAG;AACjC,UAAME,MAAMrC,SAASsC,eAAeL,QAAQE,CAAC,EAAEI,KAAK;AAEpD,QAAIF,KAAK;AACP,YAAMb,UAAUpB,qBAAqBiC,GAAG,KAAKJ,QAAQE,CAAC,EAAEhB,UAAUA;AAElE,UAAIK,UAAUU,WAAW;AACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAGA,SAAOC,IAAI;AACb;"}
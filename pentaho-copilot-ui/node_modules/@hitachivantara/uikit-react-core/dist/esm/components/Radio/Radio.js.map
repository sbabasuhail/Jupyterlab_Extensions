{"version":3,"file":"Radio.js","sources":["../../../../src/components/Radio/Radio.tsx"],"sourcesContent":["import React, { useCallback, useState } from \"react\";\n\nimport { RadioProps as MuiRadioProps } from \"@mui/material\";\n\nimport { useDefaultProps } from \"@core/hooks/useDefaultProps\";\nimport { HvBaseProps } from \"@core/types/generic\";\nimport { HvBaseRadio } from \"@core/components/BaseRadio\";\nimport {\n  HvWarningText,\n  HvLabelProps,\n  isInvalid,\n  HvFormElement,\n  HvLabel,\n} from \"@core/components/Forms\";\nimport { useUniqueId } from \"@core/hooks/useUniqueId\";\nimport { useControlled } from \"@core/hooks/useControlled\";\nimport { setId } from \"@core/utils/setId\";\nimport { ExtractNames } from \"@core/utils/classes\";\n\nimport { staticClasses, useClasses } from \"./Radio.styles\";\n\nexport { staticClasses as radioClasses };\n\nexport type HvRadioClasses = ExtractNames<typeof useClasses>;\n\nexport type HvRadioStatus = \"standBy\" | \"valid\" | \"invalid\";\n\nexport interface HvRadioProps\n  extends Omit<MuiRadioProps, \"onChange\" | \"classes\">,\n    HvBaseProps<HTMLButtonElement, \"onChange\" | \"color\"> {\n  /**\n   * A Jss Object used to override or extend the styles applied to the radio button.\n   */\n  classes?: HvRadioClasses;\n  /**\n   * The form element name.\n   */\n  name?: string;\n  /**\n   * The value of the form element.\n   *\n   * The default value is \"on\".\n   */\n  value?: any;\n  /**\n   * The label of the form element.\n   *\n   * The form element must be labeled for accessibility reasons.\n   * If not provided, an aria-label or aria-labelledby must be provided.\n   */\n  label?: React.ReactNode;\n  /**\n   * Properties passed on to the label element.\n   */\n  labelProps?: HvLabelProps;\n  /**\n   * Indicates that user input is required on the form element.\n   *\n   * If a single radio button in a group has the required attribute, a radio button in\n   * that group must be check, though it doesn't have to be the one with the attribute is applied.\n   *\n   * For that reason, the component doesn't make any uncontrolled changes to its validation status.\n   * That should ideally be managed in the context of a radio button group.\n   */\n  required?: boolean;\n  /**\n   * Indicates that the form element is not editable.\n   */\n  readOnly?: boolean;\n  /**\n   * Indicates that the form element is disabled.\n   */\n  disabled?: boolean;\n  /**\n   * If `true` the radio button is selected, if set to `false` the radio button is not selected.\n   *\n   * When defined the radio button state becomes controlled.\n   */\n  checked?: boolean;\n  /**\n   * When uncontrolled, defines the initial checked state.\n   */\n  defaultChecked?: boolean;\n  /**\n   * The status of the form element.\n   *\n   * Valid is correct, invalid is incorrect and standBy means no validations have run.\n   */\n  status?: HvRadioStatus;\n  /**\n   * The error message to show when `status` is \"invalid\".\n   */\n  statusMessage?: string;\n  /**\n   * Identifies the element that provides an error message for the radio button.\n   *\n   * Will only be used when the validation status is invalid.\n   */\n  \"aria-errormessage\"?: string;\n  /**\n   * The callback fired when the radio button is pressed.\n   */\n  onChange?: (\n    event: React.ChangeEvent<HTMLInputElement>,\n    checked: boolean,\n    value: any\n  ) => void;\n  /**\n   * Whether the selector should use semantic colors.\n   */\n  semantic?: boolean;\n  /**\n   * Properties passed on to the input element.\n   */\n  inputProps?: React.InputHTMLAttributes<HTMLInputElement>;\n  /**\n   * Callback fired when the component is focused with a keyboard.\n   * We trigger a `onFocus` callback too.\n   */\n  onFocusVisible?: (event: React.FocusEvent<any>) => void;\n  /** @ignore */\n  ref?: MuiRadioProps[\"ref\"];\n  /** @ignore */\n  component?: MuiRadioProps[\"component\"];\n}\n\n/**\n * A Radio Button is a mechanism that allows user to select just an option from a group of options.\n *\n * It should used in a Radio Button Group to present the user with a range of options from\n * which the user <b>may select just one option</b> to complete their task.\n *\n * Individual use of radio buttons, at least uncontrolled, is unadvised as React state management doesn't\n * respond to the browser's native management of radio inputs checked state.\n */\nexport const HvRadio = (props: HvRadioProps) => {\n  const {\n    classes: classesProp,\n    className,\n    id,\n    name,\n    value = \"on\",\n    required = false,\n    readOnly = false,\n    disabled = false,\n    label,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    \"aria-describedby\": ariaDescribedBy,\n    labelProps,\n    checked,\n    defaultChecked = false,\n    onChange,\n    status = \"standBy\",\n    statusMessage,\n    \"aria-errormessage\": ariaErrorMessage,\n    semantic = false,\n    inputProps,\n    onFocusVisible,\n    onBlur,\n    ...others\n  } = useDefaultProps(\"HvRadio\", props);\n\n  const { classes, cx } = useClasses(classesProp);\n\n  const elementId = useUniqueId(id, \"hvradio\");\n\n  const [focusVisible, setFocusVisible] = useState(false);\n\n  const onFocusVisibleCallback = useCallback(\n    (evt: React.FocusEvent<any>) => {\n      setFocusVisible(true);\n      onFocusVisible?.(evt);\n    },\n    [onFocusVisible]\n  );\n\n  const onBlurCallback = useCallback(\n    (evt: React.FocusEvent<any>) => {\n      setFocusVisible(false);\n      onBlur?.(evt);\n    },\n    [onBlur]\n  );\n\n  const [isChecked, setIsChecked] = useControlled(\n    checked,\n    Boolean(defaultChecked)\n  );\n\n  const onLocalChange = useCallback(\n    (evt: React.ChangeEvent<HTMLInputElement>, newChecked: boolean) => {\n      setIsChecked(newChecked);\n\n      onChange?.(evt, newChecked, value);\n    },\n    [onChange, setIsChecked, value]\n  );\n\n  // the error message area will only be created if:\n  // - an external element that provides an error message isn't identified via aria-errormessage AND\n  //   - both status and statusMessage properties are being controlled\n  const canShowError =\n    ariaErrorMessage == null &&\n    status !== undefined &&\n    statusMessage !== undefined;\n\n  const hasLabel = label != null;\n\n  const isStateInvalid = isInvalid(status);\n\n  let errorMessageId: string | undefined;\n  if (isStateInvalid) {\n    errorMessageId = canShowError\n      ? setId(elementId, \"error\")\n      : ariaErrorMessage;\n  }\n\n  const radio = (\n    <HvBaseRadio\n      id={label ? setId(elementId, \"input\") : setId(id, \"input\")}\n      name={name}\n      className={cx(classes.radio, { [classes.invalidRadio]: isStateInvalid })}\n      disabled={disabled}\n      readOnly={readOnly}\n      onChange={onLocalChange}\n      value={value}\n      checked={isChecked}\n      semantic={semantic}\n      inputProps={{\n        \"aria-invalid\": isStateInvalid ? true : undefined,\n        \"aria-errormessage\": errorMessageId,\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": ariaLabelledBy,\n        \"aria-describedby\": ariaDescribedBy,\n        ...inputProps,\n      }}\n      onFocusVisible={onFocusVisibleCallback}\n      onBlur={onBlurCallback}\n      {...others}\n    />\n  );\n\n  return (\n    <HvFormElement\n      id={id}\n      name={name}\n      status={status || \"standBy\"}\n      disabled={disabled}\n      required={required}\n      readOnly={readOnly}\n      className={cx(classes.root, className)}\n    >\n      {hasLabel ? (\n        <div\n          className={cx(classes.container, {\n            [classes.disabled]: disabled,\n            [classes.focusVisible]: !!(focusVisible && label),\n            [classes.invalidContainer]: isStateInvalid,\n          })}\n        >\n          {radio}\n          <HvLabel\n            id={setId(elementId, \"label\")}\n            htmlFor={setId(elementId, \"input\")}\n            label={label}\n            className={classes.label}\n            {...labelProps}\n          />\n        </div>\n      ) : (\n        radio\n      )}\n      {canShowError && (\n        <HvWarningText id={setId(elementId, \"error\")} disableBorder>\n          {statusMessage}\n        </HvWarningText>\n      )}\n    </HvFormElement>\n  );\n};\n"],"names":["HvRadio","props","classes","classesProp","className","id","name","value","required","readOnly","disabled","label","ariaLabel","ariaLabelledBy","ariaDescribedBy","labelProps","checked","defaultChecked","onChange","status","statusMessage","ariaErrorMessage","semantic","inputProps","onFocusVisible","onBlur","others","useDefaultProps","cx","useClasses","elementId","useUniqueId","focusVisible","setFocusVisible","useState","onFocusVisibleCallback","useCallback","evt","onBlurCallback","isChecked","setIsChecked","useControlled","Boolean","onLocalChange","newChecked","canShowError","undefined","hasLabel","isStateInvalid","isInvalid","errorMessageId","setId","radio","invalidRadio","root","container","invalidContainer"],"mappings":"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"}
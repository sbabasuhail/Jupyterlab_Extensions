import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import { useCallback, useMemo, Children, cloneElement } from "react";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useControlled } from "../../hooks/useControlled.js";
import { setId } from "../../utils/setId.js";
import { useClasses } from "./RadioGroup.styles.js";
import { staticClasses } from "./RadioGroup.styles.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
const getValueFromSelectedChildren = (children) => {
  var _a, _b, _c, _d;
  const childrenArray = Children.toArray(children);
  const childrenCount = childrenArray.length;
  for (let i = 0; i !== childrenCount; i += 1) {
    const child = childrenArray[i];
    const childIsControlled = ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.checked) !== void 0;
    const childIsSelected = childIsControlled ? (_b = child == null ? void 0 : child.props) == null ? void 0 : _b.checked : (_c = child == null ? void 0 : child.props) == null ? void 0 : _c.defaultChecked;
    if (childIsSelected) {
      return (_d = child == null ? void 0 : child.props) == null ? void 0 : _d.value;
    }
  }
  return null;
};
const HvRadioGroup = (props) => {
  const {
    id,
    classes: classesProp,
    className,
    children,
    name,
    value: valueProp,
    defaultValue,
    label,
    description,
    status,
    statusMessage,
    required = false,
    readOnly = false,
    disabled = false,
    orientation = "vertical",
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy,
    "aria-errormessage": ariaErrorMessage,
    onChange,
    ...others
  } = useDefaultProps("HvRadioGroup", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const elementId = useUniqueId(id, "hvradiogroup");
  const [value, setValue] = useControlled(valueProp, defaultValue !== void 0 ? defaultValue : (
    // When uncontrolled and no default value is given,
    // extract the initial selected values from the children own state
    () => getValueFromSelectedChildren(children)
  ));
  const onChildChangeInterceptor = useCallback((childOnChange, event, isChecked, newValue) => {
    childOnChange == null ? void 0 : childOnChange(event, isChecked, newValue);
    onChange == null ? void 0 : onChange(event, newValue);
    setValue(newValue);
  }, [onChange, setValue]);
  const modifiedChildren = useMemo(() => {
    return Children.map(children, (child) => {
      var _a, _b, _c, _d, _e;
      const childValue = ((_a = child == null ? void 0 : child.props) == null ? void 0 : _a.value) ?? "on";
      const childIsSelected = childValue === value;
      return cloneElement(child, {
        checked: childIsSelected,
        name: ((_b = child == null ? void 0 : child.props) == null ? void 0 : _b.name) || name || elementId,
        onChange: (event, isChecked, newValue) => {
          var _a2;
          return onChildChangeInterceptor((_a2 = child == null ? void 0 : child.props) == null ? void 0 : _a2.onChange, event, isChecked, newValue);
        },
        inputProps: {
          ...(_c = child == null ? void 0 : child.props) == null ? void 0 : _c.inputProps,
          // Set the required attribute directly in the input
          // the radio form element context shouldn't be aware so the
          // label doesn't show redundant asterisk
          required
        },
        disabled: disabled || ((_d = child == null ? void 0 : child.props) == null ? void 0 : _d.disabled),
        readOnly: readOnly || ((_e = child == null ? void 0 : child.props) == null ? void 0 : _e.readOnly)
      });
    });
  }, [children, disabled, elementId, name, onChildChangeInterceptor, readOnly, required, value]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && required);
  const errorMessageId = canShowError ? setId(elementId, "error") : ariaErrorMessage;
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, status: status || "standBy", disabled, required, readOnly, className: cx(classes.root, className), children: [
    label && /* @__PURE__ */ jsx(HvLabel, { id: setId(elementId, "label"), label, className: classes.label }),
    description && /* @__PURE__ */ jsx(HvInfoMessage, { id: setId(elementId, "description"), children: description }),
    /* @__PURE__ */ jsx("div", { role: "radiogroup", "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy || label && setId(elementId, "label") || void 0, "aria-invalid": status === "invalid" ? true : void 0, "aria-errormessage": status === "invalid" ? errorMessageId : void 0, "aria-describedby": [description && setId(elementId, "description"), ariaDescribedBy].join(" ").trim() || void 0, className: cx(classes.group, {
      [classes.vertical]: orientation === "vertical",
      [classes.horizontal]: orientation === "horizontal",
      [classes.invalid]: status === "invalid"
    }), ...others, children: modifiedChildren }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), disableBorder: true, className: classes.error, children: statusMessage })
  ] });
};
export {
  HvRadioGroup,
  staticClasses as radioGroupClasses
};
//# sourceMappingURL=RadioGroup.js.map

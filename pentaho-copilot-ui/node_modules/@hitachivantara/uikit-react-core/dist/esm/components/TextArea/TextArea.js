import { jsxs, jsx } from "@emotion/react/jsx-runtime";
import { forwardRef, useRef, useState, useMemo, useCallback, useEffect } from "react";
import { useForkRef } from "@mui/material";
import isNil from "lodash/isNil";
import { setId } from "../../utils/setId.js";
import { useUniqueId } from "../../hooks/useUniqueId.js";
import { useControlled } from "../../hooks/useControlled.js";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import validationState, { isInvalid } from "../Forms/FormElement/validationStates.js";
import { DEFAULT_ERROR_MESSAGES, validateInput, validationTypes, computeValidationState, computeValidationMessage, hasBuiltInValidations } from "../BaseInput/validations.js";
import { useClasses } from "./TextArea.styles.js";
import { staticClasses } from "./TextArea.styles.js";
import { HvCharCounter } from "../Forms/CharCounter/CharCounter.js";
import { HvFormElement } from "../Forms/FormElement/FormElement.js";
import { HvLabel } from "../Forms/Label/Label.js";
import { HvInfoMessage } from "../Forms/InfoMessage/InfoMessage.js";
import { HvBaseInput } from "../BaseInput/BaseInput.js";
import { HvWarningText } from "../Forms/WarningText/WarningText.js";
const HvTextArea = forwardRef((props, ref) => {
  const {
    id,
    className,
    classes: classesProp,
    name,
    label,
    description,
    placeholder,
    status,
    statusMessage,
    validationMessages,
    maxCharQuantity,
    minCharQuantity,
    value: valueProp,
    inputRef: inputRefProp,
    rows = 1,
    defaultValue = "",
    middleCountLabel = "/",
    countCharProps = {},
    inputProps = {},
    required = false,
    readOnly = false,
    disabled = false,
    autoFocus = false,
    resizable = false,
    autoScroll = false,
    hideCounter = false,
    blockMax = false,
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabelledBy,
    "aria-describedby": ariaDescribedBy,
    "aria-errormessage": ariaErrorMessage,
    validation,
    onChange,
    onBlur,
    onFocus,
    ...others
  } = useDefaultProps("HvTextArea", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const elementId = useUniqueId(id, "hvtextarea");
  const isDirty = useRef(false);
  const inputRef = useRef(null);
  const forkedRef = useForkRef(ref, inputRefProp, inputRef);
  const [focused, setFocused] = useState(false);
  const [autoScrolling, setAutoScrolling] = useState(autoScroll);
  const [validationState$1, setValidationState] = useControlled(status, validationState.standBy);
  const [validationMessage, setValidationMessage] = useControlled(statusMessage, "");
  const [value, setValue] = useControlled(valueProp, defaultValue);
  const isStateInvalid = isInvalid(validationState$1);
  const isEmptyValue = value == null || value === "";
  const hasLabel = label != null;
  const hasDescription = description != null;
  const hasCounter = maxCharQuantity != null && !hideCounter;
  const errorMessages = useMemo(() => ({
    ...DEFAULT_ERROR_MESSAGES,
    ...validationMessages
  }), [validationMessages]);
  const performValidation = useCallback(() => {
    const inputValidity = validateInput(inputRef.current, value, required, minCharQuantity, maxCharQuantity, validationTypes.none, validation);
    setValidationState(computeValidationState(inputValidity, isEmptyValue));
    setValidationMessage(computeValidationMessage(inputValidity, errorMessages));
    return inputValidity;
  }, [errorMessages, inputRef, isEmptyValue, maxCharQuantity, minCharQuantity, required, setValidationMessage, setValidationState, validation, value]);
  const isOverflow = (currentValue) => isNil(maxCharQuantity) ? false : currentValue.length > maxCharQuantity;
  const limitValue = (currentValue) => {
    if (currentValue === void 0 || !blockMax)
      return currentValue;
    return !isOverflow(currentValue) ? currentValue : currentValue.substring(0, maxCharQuantity);
  };
  const onContainerBlurHandler = (event) => {
    setFocused(false);
    const inputValidity = performValidation();
    onBlur == null ? void 0 : onBlur(event, value, inputValidity);
  };
  const onChangeHandler = (event, currentValue) => {
    isDirty.current = true;
    const limitedValue = blockMax ? limitValue(currentValue) : currentValue;
    setValue(limitedValue);
    onChange == null ? void 0 : onChange(event, limitedValue);
  };
  const onFocusHandler = (event) => {
    setFocused(true);
    setValidationState(validationState.standBy);
    onFocus == null ? void 0 : onFocus(event, value);
  };
  const isScrolledDown = useCallback(() => {
    const el = inputRef.current;
    return el == null || el.offsetHeight + el.scrollTop >= el.scrollHeight;
  }, [inputRef]);
  const scrollDown = useCallback(() => {
    const el = inputRef.current;
    if (el != null) {
      el.scrollTop = el.scrollHeight - el.clientHeight;
    }
  }, [inputRef]);
  const addScrollListener = useCallback(() => {
    var _a;
    const scrollHandler = {
      handleEvent: () => {
        setAutoScrolling(isScrolledDown());
      }
    };
    (_a = inputRef.current) == null ? void 0 : _a.addEventListener("scroll", scrollHandler);
  }, [inputRef, isScrolledDown]);
  useEffect(() => {
    if (autoScroll) {
      addScrollListener();
    }
  }, [autoScroll, addScrollListener]);
  useEffect(() => {
    if (autoScrolling) {
      scrollDown();
    }
  }, [valueProp, autoScrolling, scrollDown]);
  useEffect(() => {
    if (focused || !isDirty.current && isEmptyValue) {
      return;
    }
    performValidation();
  }, [focused, isEmptyValue, performValidation]);
  const canShowError = ariaErrorMessage == null && (status !== void 0 && statusMessage !== void 0 || status === void 0 && hasBuiltInValidations(
    required,
    validationTypes.none,
    minCharQuantity,
    // If blockMax is true maxCharQuantity will never produce an error
    // unless the value is controlled, so we can't prevent it to overflow maxCharQuantity
    maxCharQuantity != null && (blockMax !== true || value != null) ? maxCharQuantity : null,
    validation,
    inputProps
  ));
  let errorMessageId;
  if (isStateInvalid) {
    errorMessageId = canShowError ? setId(elementId, "error") : ariaErrorMessage;
  }
  return /* @__PURE__ */ jsxs(HvFormElement, { id, name, status: validationState$1, disabled, required, readOnly, className: cx(classes.root, {
    [classes.resizable]: resizable,
    [classes.disabled]: disabled,
    [classes.invalid]: isStateInvalid
  }, className), onBlur: onContainerBlurHandler, children: [
    (hasLabel || hasDescription) && /* @__PURE__ */ jsxs("div", { className: classes.labelContainer, children: [
      hasLabel && /* @__PURE__ */ jsx(HvLabel, { className: classes.label, id: setId(id, "label"), htmlFor: setId(elementId, "input"), label }),
      hasDescription && /* @__PURE__ */ jsx(HvInfoMessage, { className: classes.description, id: setId(elementId, "description"), children: description })
    ] }),
    hasCounter && /* @__PURE__ */ jsx(HvCharCounter, { id: setId(elementId, "charCounter"), className: classes.characterCounter, separator: middleCountLabel, currentCharQuantity: value.length, maxCharQuantity, ...countCharProps }),
    /* @__PURE__ */ jsx(HvBaseInput, { classes: {
      root: classes.baseInput,
      input: classes.input,
      inputResizable: classes.inputResizable
    }, id: hasLabel ? setId(elementId, "input") : setId(id, "input"), name, value, required, readOnly, disabled, onChange: onChangeHandler, autoFocus, onFocus: onFocusHandler, placeholder, invalid: isStateInvalid, resizable, multiline: true, rows, inputProps: {
      "aria-label": ariaLabel,
      "aria-labelledby": ariaLabelledBy,
      "aria-invalid": isStateInvalid ? true : void 0,
      "aria-errormessage": errorMessageId,
      "aria-describedby": ariaDescribedBy != null ? ariaDescribedBy : description && setId(elementId, "description") || void 0,
      "aria-controls": maxCharQuantity ? setId(elementId, "charCounter") : void 0,
      ...inputProps
    }, inputRef: forkedRef, ...others }),
    canShowError && /* @__PURE__ */ jsx(HvWarningText, { id: setId(elementId, "error"), className: classes.error, disableBorder: true, children: validationMessage })
  ] });
});
export {
  HvTextArea,
  staticClasses as textAreaClasses
};
//# sourceMappingURL=TextArea.js.map

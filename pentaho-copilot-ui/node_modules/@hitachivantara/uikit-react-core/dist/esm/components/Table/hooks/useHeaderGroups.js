const replaceHeaderPlaceholders = (headerGroups) => {
  const [headerGroup] = headerGroups;
  const hasPlaceholderHeaders = headerGroup.headers.some((h) => h.placeholderOf != null);
  if (!hasPlaceholderHeaders) {
    return;
  }
  const maxDepth = headerGroups.length - 1;
  const leafGroup = headerGroups[maxDepth];
  headerGroup.headers.forEach((header, position) => {
    const {
      placeholderOf
    } = header;
    const isPlaceholderHeader = placeholderOf != null;
    if (isPlaceholderHeader) {
      const leafIndex = leafGroup.headers.slice(position).findIndex(({
        id
      }) => id === placeholderOf.id) + position;
      header.variant = placeholderOf.variant;
      header.depth = maxDepth;
      leafGroup.headers[leafIndex] = header;
      placeholderOf.rowSpan = maxDepth + 1;
      headerGroup.headers[position] = placeholderOf;
    }
  });
};
const getCellProps = (column, isHeaderCell = false) => ({
  groupColumnMostLeft: column.isGroupLeftColumn,
  groupColumnMostRight: column.isGroupRightColumn,
  rowSpan: isHeaderCell && column.rowSpan != null ? column.rowSpan : 1
});
const getHeaderPropsHook = (props, {
  instance,
  column
}) => {
  var _a;
  const nextProps = instance.hasGroupedColumns ? getCellProps(column, true) : {};
  if (instance.hasGroupedColumns) {
    const isPlaceholder = column.placeholderOf != null;
    nextProps.style = {
      display: isPlaceholder ? "none" : (_a = props.style) == null ? void 0 : _a.display
    };
    if (instance.hasStickyColumns) {
      if (isPlaceholder) {
        nextProps.style.visibility = "hidden";
      }
      if (column.rowSpan > 1) {
        nextProps.style.height = `calc(var(--first-row-cell-height) + var(--cell-height) * ${column.rowSpan - 1})`;
      }
    }
  }
  return [props, nextProps];
};
const getCellPropsHook = (props, {
  instance,
  cell
}) => {
  const nextProps = instance.hasGroupedColumns ? getCellProps(cell.column) : {};
  return [props, nextProps];
};
const visibleColumnsHook = (visibleColumns, {
  instance
}) => {
  const parentList = /* @__PURE__ */ new Set();
  visibleColumns.forEach(({
    parent
  }) => {
    if (parent != null && !parentList.has(parent)) {
      parentList.add(parent);
    }
  });
  const hasGroupedColumns = parentList.size > 0;
  if (hasGroupedColumns) {
    parentList.forEach((parent) => {
      parent.align = "center";
      parent.isGroupLeftColumn = true;
      parent.isGroupRightColumn = true;
      const {
        columns
      } = parent;
      columns[0].isGroupLeftColumn = true;
      columns[columns.length - 1].isGroupRightColumn = true;
    });
  }
  Object.assign(instance, {
    hasGroupedColumns
  });
  return visibleColumns;
};
const useInstanceHook = (instance) => {
  if (instance.hasGroupedColumns) {
    replaceHeaderPlaceholders(instance.headerGroups);
  }
};
const useHeaderGroups = (hooks) => {
  hooks.visibleColumns.push(visibleColumnsHook);
  hooks.useInstance.push(useInstanceHook);
  hooks.getHeaderProps.push(getHeaderPropsHook);
  hooks.getCellProps.push(getCellPropsHook);
};
useHeaderGroups.pluginName = "useHvHeaderGroups";
const useHeaderGroups$1 = useHeaderGroups;
export {
  useHeaderGroups$1 as default
};
//# sourceMappingURL=useHeaderGroups.js.map

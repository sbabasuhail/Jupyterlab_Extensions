import { jsx } from "@emotion/react/jsx-runtime";
import { useState, useRef, useLayoutEffect } from "react";
import { useDefaultProps } from "../../hooks/useDefaultProps.js";
import { Edit } from "@hitachivantara/uikit-react-icons";
import { useControlled } from "../../hooks/useControlled.js";
import { useTheme } from "../../hooks/useTheme.js";
import { isKey } from "../../utils/keyboardUtils.js";
import { useClasses } from "./InlineEditor.styles.js";
import { staticClasses } from "./InlineEditor.styles.js";
import { HvButton } from "../Button/Button.js";
import { HvInput } from "../Input/Input.js";
import { HvTypography } from "../Typography/Typography.js";
const HvInlineEditor = (props) => {
  const {
    className,
    classes: classesProp,
    value: valueProp,
    defaultValue,
    showIcon,
    component: InputComponent = HvInput,
    variant = "body",
    placeholder = "Enter text",
    onBlur,
    onChange,
    onKeyDown,
    buttonProps,
    typographyProps,
    ...others
  } = useDefaultProps("HvInlineEditor", props);
  const {
    classes,
    cx
  } = useClasses(classesProp);
  const [value, setValue] = useControlled(valueProp, defaultValue);
  const [editMode, setEditMode] = useState(false);
  const [cachedValue, setCachedValue] = useState(value);
  const inputRef = useRef();
  const {
    activeTheme
  } = useTheme();
  const typographyStyles = (activeTheme == null ? void 0 : activeTheme.typography[variant]) || {};
  const {
    lineHeight
  } = typographyStyles;
  useLayoutEffect(() => {
    const input = inputRef.current;
    if (editMode && input) {
      input.focus();
      input.select();
    }
  }, [editMode]);
  const handleClick = () => {
    setEditMode(true);
    setCachedValue(value);
  };
  const handleBlur = (event) => {
    setEditMode(false);
    const newValue = value || cachedValue;
    setValue(newValue);
    onBlur == null ? void 0 : onBlur(event, newValue);
  };
  const handleKeyDown = (event) => {
    if (isKey(event, "Esc")) {
      setEditMode(false);
      setValue(cachedValue);
    }
    onKeyDown == null ? void 0 : onKeyDown(event);
  };
  const handleChange = (event, val) => {
    setValue(val);
    onChange == null ? void 0 : onChange(event, val);
  };
  return /* @__PURE__ */ jsx("div", { className: cx(classes.root, className), children: editMode ? /* @__PURE__ */ jsx(InputComponent, { inputRef, classes: {
    root: classes.inputRoot,
    input: classes.input,
    inputBorderContainer: classes.inputBorderContainer
  }, inputProps: {
    style: {
      ...typographyStyles,
      height: InputComponent === HvInput ? lineHeight : void 0
    }
  }, value, onBlur: handleBlur, onChange: handleChange, onKeyDown: handleKeyDown, ...others }) : /* @__PURE__ */ jsx(HvButton, { variant: "secondaryGhost", overrideIconColors: false, endIcon: /* @__PURE__ */ jsx(Edit, { color: "secondary_60", role: "none", className: cx(classes.icon, {
    [classes.iconVisible]: showIcon
  }) }), className: cx(classes.button, {
    [classes.largeText]: parseInt(lineHeight, 10) >= 28
  }), onClick: handleClick, ...buttonProps, children: /* @__PURE__ */ jsx(HvTypography, { variant, noWrap: true, className: cx(classes.text, {
    [classes.textEmpty]: !value
  }), ...typographyProps, children: value || placeholder }) }) });
};
export {
  HvInlineEditor,
  staticClasses as inlineEditorClasses
};
//# sourceMappingURL=InlineEditor.js.map

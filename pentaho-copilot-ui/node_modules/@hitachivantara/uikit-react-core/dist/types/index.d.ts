/// <reference types="react" />

import { ActionType } from 'react-table';
import { AvatarProps } from '@mui/material/Avatar';
import { Breakpoint as Breakpoint_2 } from '@mui/material';
import { CardContentProps } from '@mui/material/CardContent';
import { CardHeaderProps } from '@mui/material/CardHeader';
import { CardMediaProps } from '@mui/material/CardMedia';
import { Cell } from 'react-table';
import { ChangeEvent } from 'react';
import { CheckboxProps } from '@mui/material/Checkbox';
import { ChipProps } from '@mui/material/Chip';
import { ClassNameMap } from '@mui/material';
import { ColumnInstance } from 'react-table';
import { ColumnInterface } from 'react-table';
import type { CombinedClassKey } from 'notistack';
import type { ComponentProps } from 'react';
import { ContainerProps } from '@mui/material/Container';
import type { Context } from 'react';
import { CSSInterpolation } from '@emotion/serialize';
import { CSSInterpolation as CSSInterpolation_2 } from '@emotion/css';
import { CSSProperties } from 'react';
import { defaultCacheKey } from '@hitachivantara/uikit-react-shared';
import { defaultEmotionCache } from '@hitachivantara/uikit-react-shared';
import { DialogActionsProps } from '@mui/material/DialogActions';
import { DialogContentProps } from '@mui/material/DialogContent';
import { DialogProps } from '@mui/material/Dialog';
import { DialogTitleProps } from '@mui/material/DialogTitle';
import { DividerProps } from '@mui/material/Divider';
import { DrawerProps } from '@mui/material';
import { ds3 } from '@hitachivantara/uikit-styles';
import { ds5 } from '@hitachivantara/uikit-styles';
import { EmblaOptionsType } from 'embla-carousel-react';
import { EmotionCache } from '@emotion/cache';
import { EmotionContext } from '@hitachivantara/uikit-react-shared';
import type { ForwardRefExoticComponent } from 'react';
import { GridProps } from '@mui/material';
import { Hooks } from 'react-table';
import { HTMLAttributes } from 'react';
import { HTMLInputTypeAttribute } from 'react';
import { HvAccentColor } from '@hitachivantara/uikit-styles';
import { HvAtmosphereColor } from '@hitachivantara/uikit-styles';
import { HvBaseColor } from '@hitachivantara/uikit-styles';
import { HvBaseTheme } from '@hitachivantara/uikit-styles';
import { HvBreakpoints } from '@hitachivantara/uikit-styles';
import { HvCategoricalColor } from '@hitachivantara/uikit-styles';
import { HvColor } from '@hitachivantara/uikit-styles';
import { HvColorAny } from '@hitachivantara/uikit-styles';
import type { HvExtraDeepProps } from '@hitachivantara/uikit-react-shared';
import type { HvExtraProps } from '@hitachivantara/uikit-react-shared';
import { HvSemanticColor } from '@hitachivantara/uikit-styles';
import { HvSize } from '@hitachivantara/uikit-styles';
import { HvSupportColor } from '@hitachivantara/uikit-styles';
import { PluginHook as HvTablePluginHook } from 'react-table';
import type { HvTheme } from '@hitachivantara/uikit-react-shared';
import { HvTheme as HvTheme_2 } from '@hitachivantara/uikit-styles';
import { HvThemeBreakpoint } from '@hitachivantara/uikit-styles';
import { HvThemeColorMode } from '@hitachivantara/uikit-styles';
import { HvThemeColorModeStructure } from '@hitachivantara/uikit-styles';
import { HvThemeContext } from '@hitachivantara/uikit-react-shared';
import type { HvThemeContextValue } from '@hitachivantara/uikit-react-shared';
import { HvThemeStructure } from '@hitachivantara/uikit-styles';
import { IconBaseProps } from '@hitachivantara/uikit-react-icons';
import { IdType as IdType_2 } from 'react-table';
import { ImgHTMLAttributes } from 'react';
import { InputBaseComponentProps } from '@mui/material';
import { InputBaseProps } from '@mui/material';
import { InputProps } from '@mui/material';
import type { JSX as JSX_2 } from '@emotion/react/jsx-runtime';
import { MouseEvent as MouseEvent_2 } from 'react';
import { MouseEventHandler } from 'react';
import type { OptionsObject } from 'notistack';
import { PopperProps } from '@mui/material';
import { PropGetter } from 'react-table';
import { RadioProps } from '@mui/material/Radio';
import { RadioProps as RadioProps_2 } from '@mui/material';
import { default as React_2 } from 'react';
import { ReactElement } from 'react';
import { ReactNode } from 'react';
import { ReducerTableState } from 'react-table';
import type { RefAttributes } from 'react';
import { RefObject } from 'react';
import { Renderer } from 'react-table';
import { Row } from 'react-table';
import { SliderProps } from 'rc-slider';
import { SnackbarCloseReason } from '@mui/material/Snackbar';
import { SnackbarContentProps } from '@mui/material/SnackbarContent';
import type { SnackbarKey } from 'notistack';
import { SnackbarOrigin } from '@mui/material/Snackbar';
import { SnackbarProps } from '@mui/material/Snackbar';
import { SwitchProps } from '@mui/material/Switch';
import { SwitchProps as SwitchProps_2 } from '@mui/material';
import { SyntheticEvent } from 'react';
import { TableCellProps } from 'react-table';
import { TableCommonProps } from 'react-table';
import { TableExpandedToggleProps } from 'react-table';
import { TableFooterProps } from 'react-table';
import { TableHeaderProps } from 'react-table';
import type { TableHTMLAttributes } from 'react';
import { TableInstance } from 'react-table';
import { TableOptions } from 'react-table';
import { TableProps } from 'react-table';
import { TableRowProps } from 'react-table';
import { TableState } from 'react-table';
import { TabProps } from '@mui/material';
import { TabsProps } from '@mui/material';
import type { TdHTMLAttributes } from 'react';
import { theme } from '@hitachivantara/uikit-styles';
import { themes } from '@hitachivantara/uikit-styles';
import type { ThHTMLAttributes } from 'react';
import { TooltipProps } from '@mui/material';
import { UseColumnOrderInstanceProps } from 'react-table';
import { UseColumnOrderState } from 'react-table';
import { useEffect } from 'react';
import { UseExpandedHooks } from 'react-table';
import { UseExpandedInstanceProps } from 'react-table';
import { UseExpandedOptions } from 'react-table';
import { UseExpandedRowProps } from 'react-table';
import { UseExpandedState } from 'react-table';
import { UseFiltersColumnOptions } from 'react-table';
import { UseFiltersColumnProps } from 'react-table';
import { UseFiltersInstanceProps } from 'react-table';
import { UseFiltersOptions } from 'react-table';
import { UseFiltersState } from 'react-table';
import { UseGlobalFiltersColumnOptions } from 'react-table';
import { UseGlobalFiltersInstanceProps } from 'react-table';
import { UseGlobalFiltersOptions } from 'react-table';
import { UseGlobalFiltersState } from 'react-table';
import { UseGroupByCellProps } from 'react-table';
import { UseGroupByColumnOptions } from 'react-table';
import { UseGroupByColumnProps } from 'react-table';
import { UseGroupByHooks } from 'react-table';
import { UseGroupByInstanceProps } from 'react-table';
import { UseGroupByOptions } from 'react-table';
import { UseGroupByRowProps } from 'react-table';
import { UseGroupByState } from 'react-table';
import { UsePaginationInstanceProps } from 'react-table';
import { UsePaginationOptions } from 'react-table';
import { UsePaginationState } from 'react-table';
import { UseResizeColumnsColumnOptions } from 'react-table';
import { UseResizeColumnsColumnProps } from 'react-table';
import { UseResizeColumnsOptions } from 'react-table';
import { UseResizeColumnsState } from 'react-table';
import { UseRowStateInstanceProps } from 'react-table';
import { UseRowStateOptions } from 'react-table';
import { UseRowStateRowProps } from 'react-table';
import { UseRowStateState } from 'react-table';
import { UseSortByColumnOptions } from 'react-table';
import { UseSortByColumnProps } from 'react-table';
import { UseSortByHooks } from 'react-table';
import { UseSortByInstanceProps } from 'react-table';
import { UseSortByOptions } from 'react-table';
import { UseSortByState } from 'react-table';
import { UseTableHeaderGroupProps } from 'react-table';

declare type Accessor<D extends object> = (originalRow: D, index: number, sub: {
    subRows: D[];
    depth: number;
    data: D[];
}) => CellValue;

export declare const accordionClasses: {
    hidden: "HvAccordion-hidden";
    label: "HvAccordion-label";
    root: "HvAccordion-root";
    container: "HvAccordion-container";
    disabled: "HvAccordion-disabled";
};

export declare const actionBarClasses: {
    root: "HvActionBar-root";
};

export declare const actionClasses: {
    action: "HvVerticalNavigationAction-action";
    noIcon: "HvVerticalNavigationAction-noIcon";
    minimized: "HvVerticalNavigationAction-minimized";
};

export declare const actionsClasses: {
    root: "HvVerticalNavigationActions-root";
    hide: "HvVerticalNavigationActions-hide";
};

export declare const actionsGenericClasses: {
    button: "HvActionsGeneric-button";
    root: "HvActionsGeneric-root";
    dropDownMenu: "HvActionsGeneric-dropDownMenu";
    actionContainer: "HvActionsGeneric-actionContainer";
    dropDownMenuButton: "HvActionsGeneric-dropDownMenuButton";
    dropDownMenuButtonSelected: "HvActionsGeneric-dropDownMenuButtonSelected";
};

export declare const adornmentClasses: {
    root: "HvAdornment-root";
    icon: "HvAdornment-icon";
    adornment: "HvAdornment-adornment";
    adornmentButton: "HvAdornment-adornmentButton";
    adornmentIcon: "HvAdornment-adornmentIcon";
    hideIcon: "HvAdornment-hideIcon";
};

export declare const appSwitcherActionClasses: {
    title: "HvAppSwitcher-Action-title";
    root: "HvAppSwitcher-Action-root";
    typography: "HvAppSwitcher-Action-typography";
    icon: "HvAppSwitcher-Action-icon";
    disabled: "HvAppSwitcher-Action-disabled";
    selected: "HvAppSwitcher-Action-selected";
    iconUrl: "HvAppSwitcher-Action-iconUrl";
    iconInfo: "HvAppSwitcher-Action-iconInfo";
};

export declare const appSwitcherClasses: {
    title: "HvAppSwitcher-title";
    open: "HvAppSwitcher-open";
    root: "HvAppSwitcher-root";
    single: "HvAppSwitcher-single";
    item: "HvAppSwitcher-item";
    itemSelected: "HvAppSwitcher-itemSelected";
    itemDisabled: "HvAppSwitcher-itemDisabled";
    itemTrigger: "HvAppSwitcher-itemTrigger";
    itemIcon: "HvAppSwitcher-itemIcon";
    itemTitle: "HvAppSwitcher-itemTitle";
    itemInfoIcon: "HvAppSwitcher-itemInfoIcon";
    actionsContainer: "HvAppSwitcher-actionsContainer";
    footerContainer: "HvAppSwitcher-footerContainer";
    closed: "HvAppSwitcher-closed";
    dual: "HvAppSwitcher-dual";
    fluid: "HvAppSwitcher-fluid";
};

export declare type Arrayable<T> = T | T[];

declare type AsProp<C extends React.ElementType> = {
    component?: C;
};

declare interface Attribute extends Record<string, unknown> {
    id?: string;
    label: string;
    type: string;
    value?: unknown;
    order?: number;
}

export declare const avatarClasses: {
    img: "HvAvatar-img";
    root: "HvAvatar-root";
    container: "HvAvatar-container";
    status: "HvAvatar-status";
    square: "HvAvatar-square";
    xs: "HvAvatar-xs";
    sm: "HvAvatar-sm";
    md: "HvAvatar-md";
    lg: "HvAvatar-lg";
    xl: "HvAvatar-xl";
    fallback: "HvAvatar-fallback";
    avatar: "HvAvatar-avatar";
    badge: "HvAvatar-badge";
    circular: "HvAvatar-circular";
};

export declare const badgeClasses: {
    root: "HvBadge-root";
    badge: "HvBadge-badge";
    badgeContainer: "HvBadge-badgeContainer";
    badgePosition: "HvBadge-badgePosition";
    showCount: "HvBadge-showCount";
    showLabel: "HvBadge-showLabel";
    badgeIcon: "HvBadge-badgeIcon";
    badgeOneDigit: "HvBadge-badgeOneDigit";
};

export declare const bannerClasses: {
    root: "HvBanner-root";
    rootClosed: "HvBanner-rootClosed";
    anchorOriginTopCenter: "HvBanner-anchorOriginTopCenter";
    anchorOriginBottomCenter: "HvBanner-anchorOriginBottomCenter";
};

export declare const bannerContentClasses: {
    root: "HvBannerContent-root";
    default: "HvBannerContent-default";
    warning: "HvBannerContent-warning";
    action: "HvBannerContent-action";
    error: "HvBannerContent-error";
    success: "HvBannerContent-success";
    message: "HvBannerContent-message";
    baseVariant: "HvBannerContent-baseVariant";
    outContainer: "HvBannerContent-outContainer";
};

export declare const baseCheckBoxClasses: {
    root: "HvBaseCheckBox-root";
    icon: "HvBaseCheckBox-icon";
    disabled: "HvBaseCheckBox-disabled";
    focusVisible: "HvBaseCheckBox-focusVisible";
};

export declare const baseDropdownClasses: {
    placeholder: "HvBaseDropdown-placeholder";
    arrow: "HvBaseDropdown-arrow";
    anchor: "HvBaseDropdown-anchor";
    header: "HvBaseDropdown-header";
    root: "HvBaseDropdown-root";
    container: "HvBaseDropdown-container";
    rootDisabled: "HvBaseDropdown-rootDisabled";
    headerOpen: "HvBaseDropdown-headerOpen";
    headerOpenUp: "HvBaseDropdown-headerOpenUp";
    headerOpenDown: "HvBaseDropdown-headerOpenDown";
    headerDisabled: "HvBaseDropdown-headerDisabled";
    headerReadOnly: "HvBaseDropdown-headerReadOnly";
    arrowContainer: "HvBaseDropdown-arrowContainer";
    selection: "HvBaseDropdown-selection";
    selectionDisabled: "HvBaseDropdown-selectionDisabled";
    panel: "HvBaseDropdown-panel";
    panelOpenedUp: "HvBaseDropdown-panelOpenedUp";
    panelOpenedDown: "HvBaseDropdown-panelOpenedDown";
    inputExtensionOpen: "HvBaseDropdown-inputExtensionOpen";
    inputExtensionLeftPosition: "HvBaseDropdown-inputExtensionLeftPosition";
    inputExtensionOpenShadow: "HvBaseDropdown-inputExtensionOpenShadow";
    inputExtensionFloatRight: "HvBaseDropdown-inputExtensionFloatRight";
    inputExtensionFloatLeft: "HvBaseDropdown-inputExtensionFloatLeft";
};

export declare const baseInputClasses: {
    input: "HvBaseInput-input";
    root: "HvBaseInput-root";
    disabled: "HvBaseInput-disabled";
    readOnly: "HvBaseInput-readOnly";
    invalid: "HvBaseInput-invalid";
    resizable: "HvBaseInput-resizable";
    inputBorderContainer: "HvBaseInput-inputBorderContainer";
    inputRootInvalid: "HvBaseInput-inputRootInvalid";
    inputRootReadOnly: "HvBaseInput-inputRootReadOnly";
    inputRoot: "HvBaseInput-inputRoot";
    inputRootFocused: "HvBaseInput-inputRootFocused";
    inputRootDisabled: "HvBaseInput-inputRootDisabled";
    inputRootMultiline: "HvBaseInput-inputRootMultiline";
    inputDisabled: "HvBaseInput-inputDisabled";
    inputReadOnly: "HvBaseInput-inputReadOnly";
    inputResizable: "HvBaseInput-inputResizable";
};

export declare const baseRadioClasses: {
    root: "HvBaseRadio-root";
    icon: "HvBaseRadio-icon";
    disabled: "HvBaseRadio-disabled";
    focusVisible: "HvBaseRadio-focusVisible";
};

export declare const baseSwitchClasses: {
    track: "HvBaseSwitch-track";
    switch: "HvBaseSwitch-switch";
    root: "HvBaseSwitch-root";
    disabled: "HvBaseSwitch-disabled";
    checked: "HvBaseSwitch-checked";
    readOnly: "HvBaseSwitch-readOnly";
    focusVisible: "HvBaseSwitch-focusVisible";
    thumb: "HvBaseSwitch-thumb";
    switchBase: "HvBaseSwitch-switchBase";
};

export declare const breadCrumbClasses: {
    link: "HvBreadCrumb-link";
    a: "HvBreadCrumb-a";
    root: "HvBreadCrumb-root";
    orderedList: "HvBreadCrumb-orderedList";
    currentPage: "HvBreadCrumb-currentPage";
    centerContainer: "HvBreadCrumb-centerContainer";
    separatorContainer: "HvBreadCrumb-separatorContainer";
};

export declare interface Breakpoint {
    cols?: number;
    maxWidth?: number;
    minWidth?: number;
    spacing?: Spacing;
}

export declare const buildAriaPropsFromContext: (props: any, context: any, isInvalid: any, inputId: any) => {
    "aria-labelledby": any;
    "aria-describedby": any;
    "aria-controls": any;
};

export declare const buildFormElementPropsFromContext: (name: any, disabled: any, readOnly: any, required: any, context: any) => {
    name: any;
    disabled: any;
    readOnly: any;
    required: any;
    status: any;
};

export declare const bulkActionsClasses: {
    root: "HvBulkActions-root";
    semantic: "HvBulkActions-semantic";
    actions: "HvBulkActions-actions";
    selectAllContainer: "HvBulkActions-selectAllContainer";
    selectAll: "HvBulkActions-selectAll";
    selectAllPages: "HvBulkActions-selectAllPages";
    divider: "HvBulkActions-divider";
};

export declare const buttonClasses: {
    root: "HvButton-root";
    icon: "HvButton-icon";
    disabled: "HvButton-disabled";
    startIcon: "HvButton-startIcon";
    endIcon: "HvButton-endIcon";
    focusVisible: "HvButton-focusVisible";
};

export declare const buttonRadius: readonly ["none", "base", "round", "circle", "full"];

export declare const buttonSize: readonly ["xs", "sm", "md", "lg", "xl"];

export declare const buttonVariant: readonly ["primary", "primarySubtle", "primaryGhost", "secondarySubtle", "secondaryGhost", "semantic", "secondary", "ghost"];

export declare const calendarClasses: {
    root: "HvCalendar-root";
    rangeCalendarContainer: "HvCalendar-rangeCalendarContainer";
    singleCalendar: "HvCalendar-singleCalendar";
    focusSelection: "HvCalendar-focusSelection";
    calendarMonthlyCell: "HvCalendar-calendarMonthlyCell";
    calendarMonthlyCellSelected: "HvCalendar-calendarMonthlyCellSelected";
};

export declare const calendarHeaderClasses: {
    input: "HvCalendarHeader-input";
    root: "HvCalendarHeader-root";
    invalid: "HvCalendarHeader-invalid";
    inputBorderContainer: "HvCalendarHeader-inputBorderContainer";
    headerDayOfWeek: "HvCalendarHeader-headerDayOfWeek";
    headerDate: "HvCalendarHeader-headerDate";
    invalidMessageStyling: "HvCalendarHeader-invalidMessageStyling";
};

export declare const cardClasses: {
    root: "HvCard-root";
    icon: "HvCard-icon";
    selected: "HvCard-selected";
    selectable: "HvCard-selectable";
    semanticContainer: "HvCard-semanticContainer";
    semanticBar: "HvCard-semanticBar";
};

export declare const cardContentClasses: {
    content: "HvCardContent-content";
};

export declare const cardHeaderClasses: {
    title: "HvCardHeader-title";
    content: "HvCardHeader-content";
    root: "HvCardHeader-root";
    action: "HvCardHeader-action";
    titleShort: "HvCardHeader-titleShort";
    subheader: "HvCardHeader-subheader";
};

export declare const cardMediaClasses: {
    root: "HvCardMedia-root";
    media: "HvCardMedia-media";
};

export declare const carouselClasses: {
    title: "HvCarousel-title";
    main: "HvCarousel-main";
    root: "HvCarousel-root";
    dot: "HvCarousel-dot";
    controls: "HvCarousel-controls";
    xs: "HvCarousel-xs";
    actions: "HvCarousel-actions";
    panel: "HvCarousel-panel";
    fullscreen: "HvCarousel-fullscreen";
    closeButton: "HvCarousel-closeButton";
    mainContainer: "HvCarousel-mainContainer";
    pageCounter: "HvCarousel-pageCounter";
    mainXs: "HvCarousel-mainXs";
    mainFullscreen: "HvCarousel-mainFullscreen";
    counterContainer: "HvCarousel-counterContainer";
    counter: "HvCarousel-counter";
    slideControls: "HvCarousel-slideControls";
    slidesViewport: "HvCarousel-slidesViewport";
    slidesContainer: "HvCarousel-slidesContainer";
    dots: "HvCarousel-dots";
    dotsXs: "HvCarousel-dotsXs";
    dotSelected: "HvCarousel-dotSelected";
    thumbnail: "HvCarousel-thumbnail";
    thumbnailSelected: "HvCarousel-thumbnailSelected";
};

declare type CellValue<V = any> = V;

export declare const CellWithCheckBox: ({ row, labels: labelsProp }: {
    row: any;
    labels: any;
}) => JSX_2.Element;

export declare const CellWithExpandButton: ({ row, cell, labels: labelsProp }: {
    row: any;
    cell: any;
    labels: any;
}) => JSX_2.Element;

export declare const charCounterClasses: {
    root: "HvCharCounter-root";
    counterDisabled: "HvCharCounter-counterDisabled";
    gutter: "HvCharCounter-gutter";
    overloaded: "HvCharCounter-overloaded";
};

export declare const checkBoxClasses: {
    label: "HvCheckBox-label";
    root: "HvCheckBox-root";
    container: "HvCheckBox-container";
    checkbox: "HvCheckBox-checkbox";
    disabled: "HvCheckBox-disabled";
    focusVisible: "HvCheckBox-focusVisible";
    invalidContainer: "HvCheckBox-invalidContainer";
    invalidCheckbox: "HvCheckBox-invalidCheckbox";
};

export declare const checkBoxGroupClasses: {
    label: "HvCheckBoxGroup-label";
    root: "HvCheckBoxGroup-root";
    group: "HvCheckBoxGroup-group";
    horizontal: "HvCheckBoxGroup-horizontal";
    vertical: "HvCheckBoxGroup-vertical";
    error: "HvCheckBoxGroup-error";
    invalid: "HvCheckBoxGroup-invalid";
    selectAll: "HvCheckBoxGroup-selectAll";
};

export declare const checkValidHexColorValue: (value?: string) => boolean;

export declare const colorPickerClasses: {
    label: "HvColorPicker-label";
    root: "HvColorPicker-root";
    colorPicker: "HvColorPicker-colorPicker";
    panel: "HvColorPicker-panel";
    description: "HvColorPicker-description";
    labelContainer: "HvColorPicker-labelContainer";
    headerColorValue: "HvColorPicker-headerColorValue";
    headerColorIcon: "HvColorPicker-headerColorIcon";
    colorPickerIcon: "HvColorPicker-colorPickerIcon";
    recommendedColorsRoot: "HvColorPicker-recommendedColorsRoot";
    dropdownRootIconOnly: "HvColorPicker-dropdownRootIconOnly";
    headerColorIconOnly: "HvColorPicker-headerColorIconOnly";
    pickerFields: "HvColorPicker-pickerFields";
};

export declare const containerClasses: {
    fixed: "HvContainer-fixed";
    root: "HvContainer-root";
    disableGutters: "HvContainer-disableGutters";
    maxWidthXs: "HvContainer-maxWidthXs";
    maxWidthSm: "HvContainer-maxWidthSm";
    maxWidthMd: "HvContainer-maxWidthMd";
    maxWidthLg: "HvContainer-maxWidthLg";
    maxWidthXl: "HvContainer-maxWidthXl";
};

export declare const controlsClasses: {
    section: "HvControls-section";
    root: "HvControls-root";
    rightSection: "HvControls-rightSection";
    leftSection: "HvControls-leftSection";
};

/** Utility function to create classes for a component. */
export declare function createClasses<Name extends string, ClassName extends string>(
/** Component name in PascalCase (ie. `HvTableCell`). */
name: Name, stylesObject: Record<ClassName, CSSInterpolation_2>): {
    useClasses: (classesProp?: Partial<Record<ClassName, string>>, addStatic?: boolean) => {
        classes: { [P in ClassName]: string; };
        css: {
            (template: TemplateStringsArray, ...args: CSSInterpolation_2[]): string;
            (...args: CSSInterpolation_2[]): string;
        };
        cx: (...args: any) => string;
    };
    staticClasses: { [P_1 in ClassName]: `${Name}-${P_1}`; };
};

/**
 * Creates a customized theme based on the base theme and customizations given.
 * For the color modes, the colors that are not defined will be replaced by the values from the dawn mode of the base theme.
 */
export declare const createTheme: (props: HvCreateThemeProps) => HvTheme | HvThemeStructure;

export declare const datePickerClasses: {
    label: "HvDatePicker-label";
    root: "HvDatePicker-root";
    icon: "HvDatePicker-icon";
    dropdown: "HvDatePicker-dropdown";
    action: "HvDatePicker-action";
    error: "HvDatePicker-error";
    actionContainer: "HvDatePicker-actionContainer";
    panel: "HvDatePicker-panel";
    description: "HvDatePicker-description";
    labelContainer: "HvDatePicker-labelContainer";
    leftContainer: "HvDatePicker-leftContainer";
    rightContainer: "HvDatePicker-rightContainer";
    dropdownHeaderInvalid: "HvDatePicker-dropdownHeaderInvalid";
    dropdownHeaderOpen: "HvDatePicker-dropdownHeaderOpen";
};

export declare interface DateRangeProp {
    startDate: Date;
    endDate?: Date;
}

declare interface DateTimeRange {
    start?: DateTimeStrings;
    end?: DateTimeStrings;
}

declare interface DateTimeStrings {
    date?: string;
    time?: string;
}

export declare const decreaseSize: (size: string) => "L" | "M" | "S" | "XS";

/** This type allows to do a deep partial by applying the Partial type to each key recursively */
export declare type DeepPartial<T> = Partial<{
    [P in keyof T]: DeepPartial<T[P]>;
}>;

export { defaultCacheKey }

export { defaultEmotionCache }

export declare const defaultgetHvBulkActionsProps: (props: any, { instance }: {
    instance: any;
}) => any[];

export declare const defaultGetHvPaginationProps: (props: any, { instance }: {
    instance: any;
}) => any[];

export declare const defaultGetToggleAllPageRowsSelectedProps: (props: any, { instance }: {
    instance: any;
}) => any[];

export declare const defaultGetToggleAllRowsSelectedProps: (props: any, { instance }: {
    instance: any;
}) => any[];

export declare const defaultGetToggleRowSelectedProps: (props: any, meta: any) => any[];

declare interface Descriptor {
    id?: string;
    htmlFor?: string;
}

export declare const dialogActionClasses: {
    root: "HvDialog-Action-root";
    spacing: "HvDialog-Action-spacing";
    fullscreen: "HvDialog-Action-fullscreen";
};

export declare const dialogClasses: {
    root: "HvDialog-root";
    background: "HvDialog-background";
    warning: "HvDialog-warning";
    error: "HvDialog-error";
    success: "HvDialog-success";
    fullscreen: "HvDialog-fullscreen";
    closeButton: "HvDialog-closeButton";
    paper: "HvDialog-paper";
    statusBar: "HvDialog-statusBar";
};

export declare const dialogContentClasses: {
    root: "HvDialog-Content-root";
    textContent: "HvDialog-Content-textContent";
};

declare interface DialogLabels {
    dialogTitle: string;
    dialogMessage: string;
    dialogConfirm: string;
    dialogCancel: string;
    dialogCloseTooltip: string;
}

export declare const dialogTitleClasses: {
    root: "HvDialog-Title-root";
    fullscreen: "HvDialog-Title-fullscreen";
    messageContainer: "HvDialog-Title-messageContainer";
    textWithIcon: "HvDialog-Title-textWithIcon";
};

export declare const dotPaginationClasses: {
    root: "HvDotPagination-root";
    radio: "HvDotPagination-radio";
    horizontal: "HvDotPagination-horizontal";
    icon: "HvDotPagination-icon";
    radioRoot: "HvDotPagination-radioRoot";
};

export declare const drawerClasses: {
    root: "HvDrawer-root";
    background: "HvDrawer-background";
    closeButton: "HvDrawer-closeButton";
    paper: "HvDrawer-paper";
};

export declare const dropdownClasses: {
    placeholder: "HvDropdown-placeholder";
    arrow: "HvDropdown-arrow";
    label: "HvDropdown-label";
    root: "HvDropdown-root";
    dropdown: "HvDropdown-dropdown";
    error: "HvDropdown-error";
    selectionDisabled: "HvDropdown-selectionDisabled";
    description: "HvDropdown-description";
    labelContainer: "HvDropdown-labelContainer";
    dropdownHeaderInvalid: "HvDropdown-dropdownHeaderInvalid";
    dropdownHeaderOpen: "HvDropdown-dropdownHeaderOpen";
    dropdownHeader: "HvDropdown-dropdownHeader";
    dropdownListContainer: "HvDropdown-dropdownListContainer";
    rootList: "HvDropdown-rootList";
};

export declare const dropDownMenuClasses: {
    root: "HvDropDownMenu-root";
    container: "HvDropDownMenu-container";
    icon: "HvDropDownMenu-icon";
    baseContainer: "HvDropDownMenu-baseContainer";
    iconSelected: "HvDropDownMenu-iconSelected";
    menuListRoot: "HvDropDownMenu-menuListRoot";
    menuList: "HvDropDownMenu-menuList";
};

export { ds3 }

export { ds5 }

export { EmotionContext }

export declare const emptyStateClasses: {
    root: "HvEmptyState-root";
    container: "HvEmptyState-container";
    actionContainer: "HvEmptyState-actionContainer";
    containerMessageOnly: "HvEmptyState-containerMessageOnly";
    iconContainer: "HvEmptyState-iconContainer";
    titleContainer: "HvEmptyState-titleContainer";
    textContainer: "HvEmptyState-textContainer";
    messageContainer: "HvEmptyState-messageContainer";
};

export declare type ExtractNames<T extends (...args: any) => {
    classes: Record<string, any>;
    cx: any;
}> = Partial<ReturnType<T>["classes"]>;

export declare const fileClasses: {
    root: "HvFile-root";
    progressbar: "HvFile-progressbar";
    icon: "HvFile-icon";
    removeButton: "HvFile-removeButton";
    fail: "HvFile-fail";
    progressbarContainer: "HvFile-progressbarContainer";
    progressbarBack: "HvFile-progressbarBack";
    nameText: "HvFile-nameText";
    progressTextContainer: "HvFile-progressTextContainer";
    previewContainer: "HvFile-previewContainer";
};

export declare const fileUploaderPreviewClasses: {
    overlay: "HvFileUploaderPreview-overlay";
    previewButton: "HvFileUploaderPreview-previewButton";
};

export declare const filterGroupClasses: {
    label: "HvFilterGroup-label";
    root: "HvFilterGroup-root";
    error: "HvFilterGroup-error";
    description: "HvFilterGroup-description";
    labelContainer: "HvFilterGroup-labelContainer";
};

/** Filter out `undefined` entries from `props` object. */
export declare function filterProps(props: Record<string, any>): Record<string, any>;

/**
 * Scans the element's children looking for the children IDs that match the different form element types.
 * This function will produce an object that has a key for each provided name
 * Inside each key there will be an array with each id of the found descriptor.
 *
 * @param {Array} children - The children inside the form element to scan.
 * @param {Object} descriptors - Initial descriptors map (used for recursion).
 *
 */
export declare const findDescriptors: (children: any, descriptors?: {
    input: Descriptor[];
    label: Descriptor[];
    description: Descriptor[];
    controlled: Descriptor[];
    errormessage: Descriptor[];
    HvCalendarHeader?: Descriptor[];
}) => {
    input: Descriptor[];
    label: Descriptor[];
    description: Descriptor[];
    controlled: Descriptor[];
    errormessage: Descriptor[];
    HvCalendarHeader?: Descriptor[] | undefined;
};

export declare const focusClasses: {
    root: "HvFocus-root";
    disabled: "HvFocus-disabled";
    selected: "HvFocus-selected";
    focus: "HvFocus-focus";
    focused: "HvFocus-focused";
    focusDisabled: "HvFocus-focusDisabled";
    externalReference: "HvFocus-externalReference";
    falseFocus: "HvFocus-falseFocus";
};

export declare const footerClasses: {
    small: "HvFooter-small";
    root: "HvFooter-root";
    separator: "HvFooter-separator";
    name: "HvFooter-name";
    rightContainer: "HvFooter-rightContainer";
    copyright: "HvFooter-copyright";
};

export declare const formElementClasses: {
    root: "HvFormElement-root";
};

export declare const getBorderStyles: (type: "row", color?: string, rowBorderRadius?: string) => {
    "& td": {
        borderTop: string;
        borderBottom: string;
    };
    "& td:first-of-type": {
        borderLeft: string;
        borderRadius: string;
    };
    "& td:last-of-type": {
        borderRight: string;
        borderRadius: string;
    };
};

export declare const getClasses: <T extends string, N extends string>(keys: T[], name: N) => { [P in T]: `${N}-${P}`; };

export declare const getComponentName: (Component: any) => any;

/**
 * Get the first and last focusable element from a node.
 *
 * @param nodeId
 * @returns {{last: *, first: *}}
 */
export declare const getFirstAndLastFocus: (node: any) => {
    first: any;
    last: any;
};

/**
 * Gets the list of focusable elements.
 * @param node
 * @returns {*|NodeListOf<HTMLElementTagNameMap[string]>|NodeListOf<*>|NodeListOf<SVGElementTagNameMap[string]>|*[]}
 */
export declare const getFocusableList: (node: any) => any;

export declare const getHeaderFooterPropsHook: (props: any, { column }: {
    column: any;
}) => any[];

export declare const getHeaderGroupPropsHook: (props: any, { instance }: {
    instance: any;
}) => any[];

export declare const getIdReferenceFor: (formElementType: any, descriptors: any, filterFor?: null) => any;

export declare const getIdReferenceListFor: (formElementType: any, descriptors: any, filterFor?: null) => any;

/**
 * Auxiliary function to find adjacent nodes to focus.
 *
 * @param nodeId
 * @returns {{prevFocus: *, nextFocus: *}}
 */
export declare const getPrevNextFocus: (nodeId: any) => {
    nextFocus: any;
    prevFocus: any;
};

export declare const getSelectorIcons: (options: {
    disabled: boolean;
    semantic: boolean;
}, classes: HvBaseRadioClasses) => {
    radio: JSX_2.Element;
    radioChecked: JSX_2.Element;
};

export declare const getTableHeadPropsHook: (props: any, { instance }: {
    instance: any;
}) => any[];

export declare const getVarValue: (cssVar: string, rootElementId?: string) => string | undefined;

export declare const globalActionsClasses: {
    root: "HvGlobalActions-root";
    name: "HvGlobalActions-name";
    global: "HvGlobalActions-global";
    wrapper: "HvGlobalActions-wrapper";
    actions: "HvGlobalActions-actions";
    positionSticky: "HvGlobalActions-positionSticky";
    positionFixed: "HvGlobalActions-positionFixed";
    globalWrapperComplement: "HvGlobalActions-globalWrapperComplement";
    globalSectionArea: "HvGlobalActions-globalSectionArea";
    backButton: "HvGlobalActions-backButton";
};

export declare const gridClasses: {
    root: "HvGrid-root";
    container: "HvGrid-container";
    item: "HvGrid-item";
    zeroMinWidth: "HvGrid-zeroMinWidth";
    "direction-xs-column": "HvGrid-direction-xs-column";
    "direction-xs-reverse": "HvGrid-direction-xs-reverse";
    "direction-xs-row-reverse": "HvGrid-direction-xs-row-reverse";
    "wrap-xs-nowrap": "HvGrid-wrap-xs-nowrap";
    "wrap-xs-wrap-reverse": "HvGrid-wrap-xs-wrap-reverse";
    "spacing-xs-1": "HvGrid-spacing-xs-1";
    "spacing-xs-2": "HvGrid-spacing-xs-2";
    "spacing-xs-3": "HvGrid-spacing-xs-3";
    "spacing-xs-4": "HvGrid-spacing-xs-4";
    "spacing-xs-5": "HvGrid-spacing-xs-5";
    "spacing-xs-6": "HvGrid-spacing-xs-6";
    "spacing-xs-7": "HvGrid-spacing-xs-7";
    "spacing-xs-8": "HvGrid-spacing-xs-8";
    "spacing-xs-9": "HvGrid-spacing-xs-9";
    "spacing-xs-10": "HvGrid-spacing-xs-10";
    "grid-xs-auto": "HvGrid-grid-xs-auto";
    "grid-xs-true": "HvGrid-grid-xs-true";
    "grid-xs-1": "HvGrid-grid-xs-1";
    "grid-xs-2": "HvGrid-grid-xs-2";
    "grid-xs-3": "HvGrid-grid-xs-3";
    "grid-xs-4": "HvGrid-grid-xs-4";
    "grid-xs-5": "HvGrid-grid-xs-5";
    "grid-xs-6": "HvGrid-grid-xs-6";
    "grid-xs-7": "HvGrid-grid-xs-7";
    "grid-xs-8": "HvGrid-grid-xs-8";
    "grid-xs-9": "HvGrid-grid-xs-9";
    "grid-xs-10": "HvGrid-grid-xs-10";
    "grid-xs-11": "HvGrid-grid-xs-11";
    "grid-xs-12": "HvGrid-grid-xs-12";
};

export declare const headerActionsClasses: {
    root: "HvHeader-Actions-root";
};

export declare const headerBrandClasses: {
    root: "HvHeader-Brand-root";
    separator: "HvHeader-Brand-separator";
};

export declare const headerClasses: {
    header: "HvHeader-header";
    root: "HvHeader-root";
    backgroundColor: "HvHeader-backgroundColor";
};

export declare const headerNavigationClasses: {
    root: "HvHeader-Navigation-root";
};

export declare const hexToRgbA: (hex: any, factor?: number) => string;

export declare const horizontalScrollListItemClasses: {
    button: "HvHorizontalScrollListItem-button";
    text: "HvHorizontalScrollListItem-text";
    root: "HvHorizontalScrollListItem-root";
    selected: "HvHorizontalScrollListItem-selected";
};

export { HvAccentColor }

export declare type HvAccentColorKeys = HvAccentColor;

export declare type HvAccentColors = Record<HvAccentColorKeys, string>;

/**
 * A accordion is a design element that expands in place to expose hidden information.
 */
export declare const HvAccordion: (props: HvAccordionProps) => JSX_2.Element;

export declare type HvAccordionClasses = ExtractNames<typeof useClasses_16>;

export declare interface HvAccordionProps extends HvBaseProps<HTMLDivElement, "onChange" | "children"> {
    /**
     * Content to be rendered
     */
    children: React_2.ReactNode;
    /**
     * The accordion label button.
     */
    label?: string;
    /**
     * The function that will be executed whenever the accordion toggles it will receive the state of the accordion
     */
    onChange?: (event: React_2.SyntheticEvent, value: boolean) => void;
    /**
     * Whether the accordion is open or not, if this property is defined the accordion must be fully controlled.
     */
    expanded?: boolean;
    /**
     * When uncontrolled, defines the initial expanded state.
     */
    defaultExpanded?: boolean;
    /**
     * An object containing props to be passed onto container holding the accordion children.
     */
    containerProps?: HTMLAttributes<HTMLDivElement>;
    /**
     * Heading Level to apply to accordion button if ´undefined´ the button won't have a header wrapper.
     */
    headingLevel?: 1 | 2 | 3 | 4 | 5 | 6;
    /**
     * Is the accordion disabled.
     */
    disabled?: boolean;
    /**
     * Typography variant for the label.
     */
    labelVariant?: HvTypographyVariants;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvAccordionClasses;
}

export declare const HvActionBar: (props: HvActionBarProps) => JSX_2.Element;

export declare type HvActionBarClasses = ExtractNames<typeof useClasses_15>;

export declare interface HvActionBarProps extends HvBaseProps {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvActionBarClasses;
}

declare type HvActionContainerClasses = ExtractNames<typeof useClasses_73>;

declare interface HvActionContainerProps extends HvBaseProps<HTMLButtonElement> {
    /** onClose function. */
    onClose?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Actions to display. */
    action?: React.ReactNode | HvActionGeneric[];
    /**  The callback function ran when an action is triggered, receiving `action` as param */
    actionCallback?: (event: React.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvActionContainerClasses;
}

export declare interface HvActionGeneric {
    id: string;
    label: string;
    icon?: React_2.ReactNode | ((params: {
        isDisabled?: boolean;
    }) => React_2.ReactNode);
    disabled?: boolean;
}

export declare const HvActionsGeneric: (props: HvActionsGenericProps) => JSX_2.Element | null;

export declare type HvActionsGenericClasses = ExtractNames<typeof useClasses_69>;

export declare interface HvActionsGenericProps extends HvBaseProps {
    /** Button category. */
    category?: HvButtonVariant;
    /**  Whether actions should be all disabled */
    disabled?: boolean;
    /** The renderable content inside the actions slot of the footer, or an Array of actions `{id, label, icon, disabled}` */
    actions: React_2.ReactNode | HvActionGeneric[];
    /**  The callback function ran when an action is triggered, receiving `action` as param */
    actionsCallback?: (event: React_2.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /**  The number of maximum visible actions before they're collapsed into a `DropDownMenu`. */
    maxVisibleActions?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvActionsGenericClasses;
}

/**
 * Allows to add a decorative icon or an action to a form element, usually on the right side of an input.
 * E.g., the reveal password button.
 *
 * In addition to the showWhen feature, which uses the form element's context validation state to determine
 * its visibility, this component also ensures that it does not steal focus from the input and that it is
 * not accessible using the keyboard.
 *
 * As such, its functionality, if any, for accessibility purposes must be provided through an alternative mean,
 * or by using a regular icon button or toggle button instead.
 */
export declare const HvAdornment: ForwardRefExoticComponent<HvAdornmentProps & RefAttributes<HTMLDivElement | HTMLButtonElement>>;

export declare type HvAdornmentClasses = ExtractNames<typeof useClasses_6>;

export declare interface HvAdornmentProps extends HvBaseProps<HTMLDivElement | HTMLButtonElement, "onMouseDown" | "onKeyDown"> {
    /** The icon to be added into the input. */
    icon: React.ReactNode;
    /** When the adornment should be displayed. */
    showWhen?: HvFormStatus;
    /** Function to be executed when this element is clicked. */
    onClick?: MouseEventHandler<HTMLButtonElement> | undefined;
    /** If this property is defined the adornment visibility will be exclusively controlled by this value. */
    isVisible?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAdornmentClasses;
}

export declare const HvAppSwitcher: (props: HvAppSwitcherProps) => JSX_2.Element;

export declare const HvAppSwitcherAction: ({ id, className, classes: classesProp, application, onClickCallback, isSelectedCallback, }: HvAppSwitcherActionProps) => JSX_2.Element;

export declare interface HvAppSwitcherActionApplication {
    /** Id of the application. */
    id?: string;
    /** Name of the application, this is the value that will be displayed on the component. */
    name: string;
    /** URL with the icon location to be used to represent the application. iconUrl will only be used if no iconElement is provided. */
    iconUrl?: string;
    /** Element to be added as the icon representing the application. The iconElement will be the primary option to be displayed. */
    iconElement?: React.ReactElement;
    /** Small description of the application. */
    description?: string;
    /**  URL where the application is accessible. */
    url?: string;
    /** Defines if the application should be opened in the same tab or in a new one. */
    target?: "_top" | "_blank";
    /** If true, the item will be disabled. */
    disabled?: boolean;
    /** True when the application is selected, false otherwise. */
    isSelected?: boolean;
    /** The color of the application. */
    color?: HvColorAny;
}

export declare type HvAppSwitcherActionClasses = ExtractNames<typeof useClasses_54>;

export declare interface HvAppSwitcherActionProps extends HvBaseProps {
    /** The application data to be used to render the Action object. */
    application: HvAppSwitcherActionApplication;
    /** Callback triggered when the action is clicked. */
    onClickCallback?: (event: React.MouseEvent, application: HvAppSwitcherActionApplication) => void;
    /** Must return a boolean stating if the action element is selected or not. */
    isSelectedCallback?: (application: HvAppSwitcherActionApplication) => boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAppSwitcherActionClasses;
}

export declare type HvAppSwitcherClasses = ExtractNames<typeof useClasses_53>;

export declare interface HvAppSwitcherProps extends HvBaseProps {
    /** Number of columns to render. One, two, or whatever fits the component's width. */
    layout?: "single" | "dual" | "fluid";
    /** Title to be displayed on the header of the component. */
    title?: string;
    /** The list of applications to be used to render the actions on the component. */
    applications?: HvAppSwitcherActionApplication[];
    /** Triggered when an action is clicked. */
    onActionClickedCallback?: (event: React.MouseEvent, application: HvAppSwitcherActionApplication) => void;
    /** Must return a boolean stating if the action element is selected or not. */
    isActionSelectedCallback?: (application: HvAppSwitcherActionApplication) => boolean;
    /** Element to be added to the header container, if none is provided a label with the title will be added. */
    header?: React.ReactNode;
    /** Element to be added to the footer container. */
    footer?: React.ReactNode;
    /**
     * Flag stating if the panel is opened or closed.
     *
     * @deprecated This logic should be external, i.e. using the HvAppSwitcher inside a Drawer component.
     */
    isOpen?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAppSwitcherClasses;
}

export { HvAtmosphereColor }

export declare type HvAtmosphereColorKeys = HvAtmosphereColor;

export declare type HvAtmosphereColors = Record<HvAtmosphereColorKeys, string>;

/**
 * Avatars can be used to represent a user or a brand.
 * They can show an image, an icon or the initial letters of a name, for example.
 */
export declare const HvAvatar: ForwardRefExoticComponent<HvAvatarProps & RefAttributes<any>>;

export declare type HvAvatarClasses = ExtractNames<typeof useClasses_17>;

export declare interface HvAvatarProps extends HvBaseProps {
    /** Inline styles to be applied to the root element. */
    style?: CSSProperties;
    /** The component used for the root node. Either a string to use a DOM element or a component. */
    component?: React.ElementType;
    /** Sets one of the standard sizes of the icons */
    size?: HvAvatarSize;
    /** A color representing the foreground color of the avatar's letters or the generic User icon fallback. */
    color?: HvColorAny;
    /** A String representing the background color of the avatar. */
    backgroundColor?: HvColorAny;
    /** The `src` attribute for the `img` element. */
    src?: string;
    /** The `srcSet` attribute for the `img` element. Use this attribute for responsive image display. */
    srcSet?: string;
    /** The `sizes` attribute for the `img` element. */
    sizes?: string;
    /** Used in combination with `src` or `srcSet` to provide an alt attribute for the rendered `img` element. */
    alt?: string;
    /**
     * Attributes applied to the `img` element if the component is used to display an image.
     * It can be used to listen for the loading error event.
     */
    imgProps?: HTMLAttributes<HTMLImageElement>;
    /** A string representing the type of avatar to display, circular or square. */
    variant?: HvAvatarVariant;
    /** A string representing the color of the avatar border that represents its status. */
    status?: string;
    /** A string representing the color of the avatar badge. */
    badge?: string;
    /** Attributes applied to the avatar element. */
    avatarProps?: AvatarProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvAvatarClasses;
}

export declare type HvAvatarSize = "xs" | "sm" | "md" | "lg" | "xl";

export declare type HvAvatarVariant = "circular" | "square";

/**
 * The badge is a component used to notify the user that something has occurred, in the app context.
 */
export declare const HvBadge: (props: HvBadgeProps) => JSX_2.Element;

export declare type HvBadgeClasses = ExtractNames<typeof useClasses_18>;

export declare interface HvBadgeProps extends HvBaseProps {
    /**
     * Count is the number of unread notifications.
     * Note count and label are mutually exclusive.
     * count is ignored when label is specified at the same time.
     */
    count?: number;
    /**
     * True if count should be displayed.
     * Note showCount and label are mutually exclusive.
     * showCount is ignored when label is specified at the same time.
     */
    showCount?: boolean;
    /** The maximum number of unread notifications to be displayed */
    maxCount?: number;
    /**
     * Custom text to show in place of count.
     * Note showCount and label are mutually exclusive.
     * showCount is ignored when label is specified at the same time.
     */
    label?: string;
    /** Icon which the notification will be attached. */
    icon?: React.ReactNode;
    /** Text which the notification will be attached. */
    text?: string;
    /** Text variant. */
    textVariant?: HvTypographyVariants;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBadgeClasses;
}

/**
 * A Banner displays an important and succinct message. It can also provide actions for the user to address, or dismiss.
 * It requires a user action, for it to be dismissed. Banners should appear at the top of the screen, below a top app bar.
 */
export declare const HvBanner: (props: HvBannerProps) => JSX_2.Element;

export declare type HvBannerActionPosition = "auto" | "inline" | "bottom-right";

export declare type HvBannerClasses = ExtractNames<typeof useClasses_72>;

export declare const HvBannerContent: ForwardRefExoticComponent<Omit<HvBannerContentProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvBannerContentClasses = ExtractNames<typeof useClasses_74>;

export declare interface HvBannerContentProps extends Omit<SnackbarContentProps, "variant" | "classes" | "onClose">, HvBaseProps {
    /** The message to display. */
    content?: string;
    /** Variant of the snackbar. */
    variant?: HvBannerVariant;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** onClose function. */
    onClose?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** Actions to display on the right side. */
    actions?: React.ReactNode | HvActionGeneric[];
    /**  The callback function ran when an action is triggered, receiving `action` as param */
    actionsCallback?: (event: React.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /** The position property of the header. */
    actionsPosition?: HvBannerActionPosition;
    /** The props to pass down to the Action Container. */
    actionProps?: HvActionContainerProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBannerContentClasses;
}

export declare interface HvBannerProps extends Omit<SnackbarProps, "anchorOrigin" | "classes" | "onClose">, HvBaseProps<HTMLDivElement, "children"> {
    /** If true, the snackbar is open. */
    open: boolean;
    /** Callback fired when the component requests to be closed. Typically onClose is used to set state in the parent component, which is used to control the Snackbar open prop. The reason parameter can optionally be used to control the response to onClose, for example ignoring clickaway. */
    onClose?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** The message to display. */
    label?: string;
    /** The anchor of the Snackbar. */
    anchorOrigin?: "top" | "bottom";
    /** Variant of the snackbar. */
    variant?: HvBannerVariant;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Actions to display on the right side. */
    actions?: React.ReactNode | HvActionGeneric[];
    /** The callback function ran when an action is triggered, receiving `action` as param */
    actionsCallback?: (event: React.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /** The position property of the header. */
    actionsPosition?: HvBannerActionPosition;
    /** How much the transition animation last in milliseconds, if 0 no animation is played. */
    transitionDuration?: number;
    /** Direction of slide transition. */
    transitionDirection?: "up" | "down" | "left" | "right";
    /** Offset from top/bottom of the page, in px. Defaults to 60px. */
    offset?: number;
    /** Props to pass down to the Banner Wrapper. An object `actionProps` can be included to be passed as others to actions. */
    bannerContentProps?: HvBannerContentProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBannerClasses;
    /** @ignore */
    ref?: SnackbarProps["ref"];
}

export declare type HvBannerVariant = "success" | "warning" | "error" | "default";

/**
 * A Checkbox is a mechanism that allows user to select one or more options.
 *
 * The Base Checkbox is a building block of the Checkbox form element. Don't use unless
 * implementing a custom use case not covered by the Checkbox form element.
 */
export declare const HvBaseCheckBox: (props: HvBaseCheckBoxProps) => JSX_2.Element;

export declare type HvBaseCheckBoxClasses = ExtractNames<typeof useClasses_51>;

export declare interface HvBaseCheckBoxProps extends Omit<CheckboxProps, "onChange" | "classes">, HvBaseProps<HTMLButtonElement, "onChange" | "color"> {
    /**
     * The input name.
     */
    name?: string;
    /**
     * The value of the input.
     *
     * Is up to the application's logic when to consider the submission of this value.
     * Generally it should be used only when the checkbox is neither unchecked nor indeterminate.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * Indicates that the input is disabled.
     */
    disabled?: boolean;
    /**
     * Indicates that the input is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required.
     */
    required?: boolean;
    /**
     * If `true` the checkbox is selected, if set to `false` the checkbox is not selected.
     *
     * When defined the checkbox state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * If `true` the checkbox visually shows the indeterminate state.
     */
    indeterminate?: boolean;
    /**
     * The callback fired when the checkbox is pressed.
     */
    onChange?: (event: React_2.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Whether the selector should use semantic colors.
     */
    semantic?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React_2.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React_2.FocusEvent<any>) => void;
    /**
     * Callback fired when the component is blurred.
     */
    onBlur?: (event: React_2.FocusEvent<HTMLButtonElement>) => void;
    /**
     * A Jss Object used to override or extend the styles applied to the checkbox.
     */
    classes?: HvBaseCheckBoxClasses;
}

export { HvBaseColor }

export declare type HvBaseColorKeys = HvBaseColor;

export declare type HvBaseColors = Record<HvBaseColorKeys, string>;

export declare const HvBaseDropdown: (props: HvBaseDropdownProps) => JSX_2.Element;

export declare type HvBaseDropdownClasses = ExtractNames<typeof useClasses_14>;

export declare interface HvBaseDropdownProps extends HvBaseProps<HTMLDivElement, "placeholder"> {
    /**
     * The role of the element that triggers the popup.
     *
     * Defaults to "combobox" if `component` and the default
     * "textbox" header is used, undefined otherwise.
     */
    role?: string;
    /**
     * Header placeholder.
     */
    placeholder?: string | React_2.ReactNode;
    /**
     * If `true` the dropdown is disabled unable to be interacted, if `false` it is enabled.
     */
    disabled?: boolean;
    /**
     * If `true` the dropdown will be in read only mode, unable to be interacted.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal?: boolean;
    /**
     * If `true` the dropdown width depends size of content if `false` the width depends on the header size.
     * Defaults to `false`.
     */
    variableWidth?: boolean;
    /**
     * If `true` the dropdown starts opened if `false` it starts closed.
     */
    expanded?: boolean;
    /**
     * When uncontrolled, defines the initial expanded state.
     */
    defaultExpanded?: boolean;
    /**
     * An object containing props to be wired to the popper component.
     */
    popperProps?: Partial<PopperProps>;
    /**
     * Placement of the dropdown.
     */
    placement?: "left" | "right";
    /**
     * Replacement for the header component.
     */
    component?: React_2.ReactNode;
    /**
     * Adornment to replace the default arrows.
     */
    adornment?: React_2.ReactNode;
    /**
     * When dropdown changes the expanded state.
     */
    onToggle?: (event: Event, open: boolean) => void;
    /**
     * When user click outside the open container.
     */
    onClickOutside?: (event: Event) => void;
    /**
     * Callback called when the dropdown is opened and ready,
     * commonly used to set focus to the content.
     */
    onContainerCreation?: (container: HTMLElement | null) => void;
    /**
     * Attributes applied to the dropdown header element.
     */
    dropdownHeaderProps?: React_2.DetailedHTMLProps<React_2.HTMLAttributes<HTMLDivElement>, HTMLDivElement>;
    /**
     * Pass a ref to the dropdown header element.
     */
    dropdownHeaderRef?: React_2.Ref<any>;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvBaseDropdownClasses;
}

/**
 * An Input component that only posses the most basic functionalities.
 * It should be used alongside the other form elements to construct a proper accessible form.
 */
export declare const HvBaseInput: (props: HvBaseInputProps) => JSX_2.Element;

export declare type HvBaseInputClasses = ExtractNames<typeof useClasses_13>;

export declare interface HvBaseInputProps extends Omit<InputProps, "onChange" | "classes">, HvBaseProps<HTMLDivElement, "onChange" | "color" | "onBlur" | "onFocus" | "onInvalid" | "onKeyDown" | "onKeyUp"> {
    /** The input name. */
    name?: string;
    /** The value of the input, when controlled. */
    value?: string;
    /** The initial value of the input, when uncontrolled. */
    defaultValue?: string;
    /** If `true` the input is disabled. */
    disabled?: boolean;
    /** Indicates that the input is not editable. */
    readOnly?: boolean;
    /** If true, the input element will be required. */
    required?: boolean;
    /** The function that will be executed onChange, allows modification of the input,
     * it receives the value. If a new value should be presented it must returned it. */
    onChange?: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, value: string) => void;
    /** The input type. */
    type?: string;
    /** Label inside the input used to help user. */
    placeholder?: string;
    /** If true, a textarea element will be rendered. */
    multiline?: boolean;
    /** If true and multiline is also true the textarea element will be resizable. */
    resizable?: boolean;
    /** Denotes if the input is in an invalid state. */
    invalid?: boolean;
    /** Attributes applied to the input element. */
    inputProps?: InputBaseComponentProps;
    /** Allows passing a ref to the underlying input */
    inputRef?: InputBaseProps["inputRef"];
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBaseInputClasses;
}

/** HV Base Props. Extends `HTMLAttributes` of an element `E`, and filters `K` keys. */
export declare type HvBaseProps<E extends HTMLElement = HTMLDivElement, K extends keyof HTMLAttributes<E> = never> = Omit<HTMLAttributes<E>, K>;

/**
 * A Radio Button is a mechanism that allows user to select one or more options.
 *
 * The Base Radio Button is a building block of the Radio Button form element. Don't
 * use unless implementing a custom use case not covered by the Radio Button form element.
 */
export declare const HvBaseRadio: (props: HvBaseRadioProps) => JSX_2.Element;

export declare type HvBaseRadioClasses = ExtractNames<typeof useClasses_52>;

export declare interface HvBaseRadioProps extends Omit<RadioProps, "onChange" | "classes">, HvBaseProps<HTMLButtonElement, "onChange" | "color"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the radio button.
     */
    classes?: HvBaseRadioClasses;
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * The input name.
     */
    name?: string;
    /**
     * The value of the input.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * Indicates that user input is required.
     */
    required?: boolean;
    /**
     * Indicates that the input is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that the input is disabled.
     */
    disabled?: boolean;
    /**
     * If `true` the radio button is selected, if set to `false` the radio button is not selected.
     *
     * When defined the radio button state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The callback fired when the radio button is pressed.
     */
    onChange?: (event: React_2.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Whether the selector should use semantic colors.
     */
    semantic?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React_2.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React_2.FocusEvent<any>) => void;
    /**
     * @ignore
     */
    onBlur?: (event: React_2.FocusEvent<any>) => void;
}

/**
 * A Switch is <b>binary</b> and work as a digital on/off button.
 *
 * The Base Switch is a building block of the Switch form element. Don't use unless
 * implementing a custom use case not covered by the Switch form element.
 */
export declare const HvBaseSwitch: (props: HvBaseSwitchProps) => JSX_2.Element;

export declare type HvBaseSwitchClasses = ExtractNames<typeof useClasses_55>;

export declare interface HvBaseSwitchProps extends Omit<SwitchProps, "onChange" | "classes">, HvBaseProps<HTMLButtonElement, "onChange" | "color"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the switch.
     */
    classes?: HvBaseSwitchClasses;
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * The input name.
     */
    name?: string;
    /**
     * The value of the input.
     *
     * Is up to the application's logic when to consider the submission of this value.
     * Generally it should be used only when the switch is neither unchecked nor indeterminate.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * Indicates that user input is required.
     */
    required?: boolean;
    /**
     * Indicates that the input is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that the input is disabled.
     */
    disabled?: boolean;
    /**
     * If `true` the switch is selected, if set to `false` the switch is not selected.
     *
     * When defined the switch state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The callback fired when the switch is pressed.
     */
    onChange?: (event: React_2.ChangeEvent, checked: boolean, value: any) => void;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React_2.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React_2.FocusEvent<any>) => void;
    /**
     * @ignore
     */
    onBlur?: (event: React_2.FocusEvent<any>) => void;
}

export { HvBaseTheme }

/**
 * Customizable layout component that can be used to wrap other components.
 * It can be used to add styles to the wrapped components.
 * It can also be used to create a layout using the flexbox properties.
 */
export declare const HvBox: HvBoxProps;

declare type HvBoxBaseProps<C extends React.ElementType> = PolymorphicComponentRef<C, {
    style?: React.CSSProperties;
    sx?: SxProps;
}>;

export declare type HvBoxProps = <C extends React.ElementType = "div">(props: HvBoxBaseProps<C>) => React.ReactElement | null;

/**
 * A breadcrumb is a graphical control element frequently used as a navigational aid.
 */
export declare const HvBreadCrumb: (props: HvBreadCrumbProps) => JSX_2.Element;

export declare type HvBreadCrumbClasses = ExtractNames<typeof useClasses_70>;

export declare interface HvBreadCrumbPathElement extends Record<string, any> {
    label: string;
    path: string;
}

export declare interface HvBreadCrumbProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    /** List of breadcrumb. */
    listRoute?: HvBreadCrumbPathElement[];
    /** URL to build the breadcrumb. */
    url?: string;
    /** Number of pages visible. */
    maxVisible?: number;
    /** The component used for the link node. Either a string to use a DOM element or a component. */
    component?: React.ElementType;
    /** Function passed to the component. If defined the component prop is used as the link node. */
    onClick?: (event: MouseEvent_2<HTMLElement>, data: any) => void;
    /** Props passed down to the DropDownMenu sub-menu component. */
    dropDownMenuProps?: Partial<HvDropDownMenuProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvBreadCrumbClasses;
}

export { HvBreakpoints }

/**
 * Bulk Actions allow users to perform an action on a single or multiple items.
 * Also known as "batch production" of multiple items at once, one stage at a time.
 */
export declare const HvBulkActions: (props: HvBulkActionsProps) => JSX_2.Element;

export declare type HvBulkActionsClasses = ExtractNames<typeof useClasses_78>;

export declare type HvBulkActionsPropGetter<D extends object> = PropGetter<D, HvTAbleBulkActionsProps>;

export declare interface HvBulkActionsProps extends HvBaseProps {
    /**
     * Custom label for select all checkbox
     */
    selectAllLabel?: React.ReactNode;
    /**
     * Custom label for select all checkbox conjunction
     */
    selectAllConjunctionLabel?: string;
    /**
     * Custom label for select all pages button
     */
    selectAllPagesLabel?: React.ReactNode;
    /**
     * Whether select all pages element should be visible
     */
    showSelectAllPages?: boolean;
    /**
     * The total number of elements
     */
    numTotal?: number;
    /**
     * The number of elements currently selected
     */
    numSelected?: number;
    /**
     * Function called when the "select all" Checkbox is toggled.
     */
    onSelectAll?: HvCheckBoxProps["onChange"];
    /**
     * Function called when the "select all pages" button is clicked toggled.
     */
    onSelectAllPages?: HvButtonProps["onClick"];
    /**
     * Whether the bulk actions should use the semantic styles when there are selected elements.
     */
    semantic?: boolean;
    /**
     * The renderable content inside the right actions slot,
     * or an Array of actions `{ id, label, icon, disabled, ... }`
     */
    actions?: React.ReactNode | HvActionGeneric[];
    /**
     *  Whether actions should be all disabled
     */
    actionsDisabled?: boolean;
    /**
     *  The callback function ran when an action is triggered, receiving `action` as param
     */
    actionsCallback?: HvActionsGenericProps["actionsCallback"];
    /**
     *  The number of maximum visible actions before they're collapsed into a `DropDownMenu`.
     */
    maxVisibleActions?: number;
    /**
     * Properties to be passed onto the checkbox component, the values of the object are equivalent to the
     * HvCheckbox API.
     */
    checkboxProps?: HvCheckBoxProps;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvBulkActionsClasses;
}

/**
 * Button component is used to trigger an action or event.
 */
export declare const HvButton: <C extends React_2.ElementType = "button">(props: HvButtonProps<C>) => React_2.ReactElement | null;

export declare type HvButtonClasses = ExtractNames<typeof useClasses_19>;

export declare type HvButtonProps<C extends React_2.ElementType = "button"> = PolymorphicComponentRef<C, {
    /** Use the variant prop to change the visual style of the Button. */
    variant?: HvButtonVariant;
    /** Whether the Button is an icon-only button. */
    icon?: boolean;
    /** Whether the Button is disabled or not. */
    disabled?: boolean;
    /** Class names to be applied. */
    className?: string;
    /** Element placed before the children. */
    startIcon?: ReactElement;
    /** Element placed after the children. */
    endIcon?: ReactElement;
    /** Button size. */
    size?: HvButtonSize;
    /** Button border radius. */
    radius?: HvButtonRadius;
    /** Defines the default colors of the button are forced into the icon. */
    overrideIconColors?: boolean;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvButtonClasses;
    /** Whether the Button is selected or not. */
    selected?: boolean;
}>;

export declare type HvButtonRadius = (typeof buttonRadius)[number];

export declare type HvButtonSize = (typeof buttonSize)[number];

export declare type HvButtonVariant = (typeof buttonVariant)[number];

export declare const HvCalendar: (props: HvCalendarProps) => JSX_2.Element;

export declare type HvCalendarClasses = ExtractNames<typeof useClasses_93>;

export declare const HvCalendarHeader: {
    ({ id, value, locale, classes: classesProp, onChange, showEndDate, showDayOfWeek, onFocus, invalidDateLabel, ...others }: HvCalendarHeaderProps): JSX_2.Element;
    formElementType: string;
};

export declare type HvCalendarHeaderClasses = ExtractNames<typeof useClasses_94>;

export declare interface HvCalendarHeaderProps {
    /**
     * A Jss Object used to override or extend the component styles.
     */
    classes?: HvCalendarHeaderClasses;
    /**
     * Identifier.
     */
    id?: string;
    /**
     * The text to be shown on the main part of the header.
     */
    value?: string | Date | DateRangeProp;
    /**
     * Locale to be used by the calendar.
     */
    locale?: string;
    /**
     * Callback to define the input date.
     */
    onChange?: (event: React.ChangeEvent<HTMLTextAreaElement | HTMLInputElement> | undefined, value: Date | DateRangeProp) => void;
    /**
     * Callback to handle input onFocus.
     */
    onFocus?: (event: React.FocusEventHandler<any>, formattedDate: string | null) => void;
    /**
     * Indicates if header should display end date in a date range.
     */
    showEndDate?: boolean;
    /**
     * Indicates if header should display the day of week.
     */
    showDayOfWeek?: boolean;
    /**
     * Label shown when date is invalid.
     */
    invalidDateLabel?: string;
}

export declare interface HvCalendarProps {
    /**
     * Styles applied from the theme.
     */
    classes?: HvCalendarClasses;
    /**
     * Identifier.
     */
    id?: string;
    /**
     * The calendar locale. If undefined, it defaults to en-US
     *
     */
    locale?: string;
    /**
     * Date that the calendar would show.
     * if using the object format the calendar enter in range mode showing two calendars
     */
    value?: DateRangeProp | Date;
    /**
     * Controls the visible month of the Calendar
     */
    visibleMonth?: number;
    /**
     * Controls the visible year of the Calendar
     */
    visibleYear?: number;
    /**
     * Controls the visible month of the Calendar on the right side of the datepicker
     */
    rightVisibleMonth?: number;
    /**
     * Controls the visible year of the Calendar on the right side of the datepicker
     */
    rightVisibleYear?: number;
    /**
     * Callback function to be triggered when the selected date has changed.
     */
    onChange?: (event: React_2.ChangeEvent<HTMLTextAreaElement | HTMLInputElement> | undefined, value: Date | DateRangeProp) => void;
    /**
     * Callback function to be triggered when the selected date input has changed.
     */
    onInputChange?: (event: React_2.ChangeEvent<HTMLTextAreaElement | HTMLInputElement | HTMLButtonElement> | undefined, value: Date | DateRangeProp, position: "left" | "right") => void;
    /**
     * Callback function to be triggered when the user clicks on the month or year selector.
     * it receives the action that was pressed:
     * previous_month, next_month, previous_year, next_year,month
     */
    onVisibleDateChange?: (event: React_2.ChangeEvent<HTMLTextAreaElement | HTMLInputElement> | undefined, action: VisibilitySelectorActions, value?: Date | DateRangeProp | number, position?: "left" | "right") => void;
    /**
     * The maximum selectable date after this all values are disabled.
     */
    maximumDate?: Date;
    /**
     * The minimum selectable date before this all values are disabled.
     */
    minimumDate?: Date;
    /**
     * An element placed before the Calendar
     */
    startAdornment?: React_2.ReactNode;
    /**
     * Indicates if header should display the day of week.
     */
    showDayOfWeek?: boolean;
    /**
     * Label shown when date is invalid.
     */
    invalidDateLabel?: string;
}

/**
 * A card is a container for a few short and related pieces of content.
 * It roughly resembles a playing card in size and shape and is intended as a
 * linked short representation of a conceptual unit. For that reason,
 * this pattern must be used as an entry-point for further information.
 */
export declare const HvCard: (props: HvCardProps) => JSX_2.Element;

export declare type HvCardClasses = ExtractNames<typeof useClasses_20>;

export declare const HvCardContent: ({ id, classes: classesProp, className, children, onClick, ...others }: HvCardContentProps) => JSX_2.Element;

export declare type HvCardContentClasses = ExtractNames<typeof useClasses_22>;

export declare interface HvCardContentProps extends Omit<CardContentProps, "classes">, HvBaseProps {
    /** Id to be applied to the root node. */
    id?: string;
    /** The function that will be executed when this section is clicked. */
    onClick?: (event: React.SyntheticEvent) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardContentClasses;
}

export declare const HvCardHeader: ({ classes: classesProp, className, title, subheader, icon, onClick, ...others }: HvCardHeaderProps) => JSX_2.Element;

export declare type HvCardHeaderClasses = ExtractNames<typeof useClasses_21>;

export declare interface HvCardHeaderProps extends Omit<CardHeaderProps, "classes">, HvBaseProps<HTMLDivElement, "title"> {
    /** The renderable content inside the title slot of the header. */
    title: React.ReactNode;
    /** The renderable content inside the subheader slot of the header. */
    subheader?: React.ReactNode;
    /** The renderable content inside the icon slot of the header. */
    icon?: React.ReactNode;
    /** The function that will be executed when this section is clicked. */
    onClick?: React.MouseEventHandler<HTMLDivElement> | undefined;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardHeaderClasses;
}

export declare const HvCardMedia: ({ id, classes: classesProp, className, children, title, onClick, ...others }: HvCardMediaProps) => JSX_2.Element;

export declare type HvCardMediaClasses = ExtractNames<typeof useClasses_23>;

export declare interface HvCardMediaProps extends Omit<CardMediaProps, "classes">, ImgHTMLAttributes<HTMLDivElement>, HvBaseProps<HTMLDivElement, "onClick" | "title"> {
    /** Id to be applied to the root node. */
    id?: string;
    /** The title of the media. */
    title?: string;
    /** The function that will be executed when this section is clicked. */
    onClick?: React.MouseEventHandler<HTMLDivElement> | undefined;
    /** The component used for the root node. Either a string to use a HTML element or a component. */
    component?: React.ElementType;
    /** The image to display. */
    image?: string;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardMediaClasses;
}

export declare interface HvCardProps extends HvBaseProps {
    /** The renderable content inside the icon slot of the header. */
    icon?: React.ReactNode;
    /** Whether the card is selectable. */
    selectable?: boolean;
    /** Whether the card is currently selected. */
    selected?: boolean;
    /** The background color of the card. */
    bgcolor?: "sema0" | HvSemanticColorKeys | HvAtmosphereColorKeys | "transparent";
    /**
     *  The border color at the top of the card. Must be one of palette semantic or atmosphere colors.
     *  To set another color, the borderTop should be override.
     */
    statusColor?: "sema0" | HvSemanticColorKeys | HvAtmosphereColorKeys;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCardClasses;
}

/**
 * A Carousel is commonly used to browse images, it can also be used to browse any kind of content like text, video, or charts.
 * It allows you to focus on a particular content while having a notion of how many you have to explore.
 */
export declare const HvCarousel: (props: HvCarouselProps) => JSX_2.Element;

export declare type HvCarouselClasses = ExtractNames<typeof useClasses_115>;

export declare const HvCarouselControls: (props: HvCarouselControlsProps) => JSX_2.Element;

declare interface HvCarouselControlsProps extends HvBaseProps<HTMLDivElement>, Pick<HvPaginationProps, "page" | "pages" | "canPrevious" | "canNext"> {
    showDots?: boolean;
    classes?: ExtractNames<typeof useClasses_115>;
    actions?: ReactNode;
    onPreviousClick?: MouseEventHandler<HTMLButtonElement>;
    onNextClick?: MouseEventHandler<HTMLButtonElement>;
}

export declare interface HvCarouselProps extends HvBaseProps<HTMLDivElement, "title" | "onChange"> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvCarouselClasses;
    /** Height of the Slider container. If `undefined`, images will keep a 16/9 aspect-ratio */
    height?: CSSProperties["height"];
    /** Width of the thumbnail. Height will try to maintain a 16/9 aspect-ratio */
    thumbnailWidth?: CSSProperties["width"];
    /** Title of the carousel */
    title?: React_2.ReactNode;
    /** Content slides to be displayed. @see `<HvCarouselSlide />` */
    children?: React_2.ReactNode;
    /** Custom content to render in the actions area */
    actions?: React_2.ReactNode;
    /** Whether Carousel is in "xs mode" - to use in embedded contexts */
    xs?: boolean;
    /** Whether to show dots instead of arrow pagination. Defaults to true under 5 elements */
    showDots?: boolean;
    /** Whether to show the counter on the top-right corner of the active slide */
    showCounter?: boolean;
    /** Whether to show the back/forwards buttons over the active slide */
    showSlideControls?: boolean;
    /** Whether to enable the fullscreen toggle button */
    showFullscreen?: boolean;
    /** Whether to hide the thumbnails. Hidden by default in "xs" mode */
    hideThumbnails?: boolean;
    /** Controls position. */
    controlsPosition?: "top" | "bottom";
    /** Thumbnails position. */
    thumbnailsPosition?: "top" | "bottom";
    /** Carousel configuration options. @see https://www.embla-carousel.com/api/options/ */
    carouselOptions?: EmblaOptionsType;
    /** Function that renders the thumbnail.  */
    renderThumbnail?: (index: number) => React_2.ReactNode;
    /** The callback fired when the active slide changes. */
    onChange?: (index: number) => void;
}

/**
 * A container to use as `children` of `HvCarousel`.
 * Pass `img` props directly to it, or `children` for any custom content
 */
export declare const HvCarouselSlide: ({ classes: classesProp, className, children, size: flexBasis, src, alt, ...props }: HvCarouselSlideProps) => JSX_2.Element;

export declare type HvCarouselSlideClasses = ExtractNames<typeof useClasses_116>;

export declare interface HvCarouselSlideProps extends ImgHTMLAttributes<HTMLImageElement> {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvCarouselSlideClasses;
    /** The width of the Slide. Defaults to `100%` */
    size?: string;
    /** Content of a slide to be displayed */
    children?: React.ReactNode;
}

export declare const HvCarouselThumbnails: ForwardRefExoticComponent<HvCarouselThumbnailsProps & RefAttributes<HTMLDivElement>>;

declare interface HvCarouselThumbnailsProps extends HvBaseProps<HTMLDivElement, "children">, Pick<HvPaginationProps, "page" | "pages" | "canPrevious" | "canNext"> {
    width?: CSSProperties["width"];
    classes?: ExtractNames<typeof useClasses_115>;
    onThumbnailClick?: (event: MouseEvent_2<HTMLButtonElement>, index: number) => void;
    thumbnailProps?: Partial<HvButtonProps>;
    showDots?: boolean;
    renderThumbnail?: (index: number) => React.ReactNode;
}

export { HvCategoricalColor }

export declare type HvCategoricalColorKeys = HvCategoricalColor;

export declare interface HvCellInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, V = any> extends Omit<Cell<D, V>, "column" | "row" | "getCellProps">, Partial<UseGroupByCellProps<D>> {
    column: HvColumnInstance<D, H>;
    row: HvRowInstance<D, H>;
    getCellProps: (propGetter?: HvCellPropGetter<D, H>) => HvUseTableCellProps;
}

declare type HvCellPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableCellProps, {
    cell: HvCellInstance<D, H>;
}>;

export declare interface HvCellProps<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, V = any> extends HvTableInstance<D, H> {
    column: HvColumnInstance<D, H>;
    row: HvRowInstance<D, H>;
    cell: HvCellInstance<D, H, V>;
    value: CellValue<V>;
}

/**
 * Displays the capacity and current usage of a text input box (character count by default).
 *
 * Use the character counter when there is a character or word limit.
 * By itself it doesn't block the user from going above the limit.
 */
export declare const HvCharCounter: (props: HvCharCounterProps) => JSX_2.Element;

export declare type HvCharCounterClasses = ExtractNames<typeof useClasses_5>;

export declare interface HvCharCounterProps extends HvBaseProps {
    /** The string that separates the current char quantity from the max quantity. */
    separator?: string;
    /** The maximum allowed length of the characters. */
    maxCharQuantity: number;
    /** The current char quantity to be rendered. */
    currentCharQuantity?: number;
    /** If `true` the counter is disabled. */
    disabled?: boolean;
    /** If `true` the info message won't have margins. */
    disableGutter?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvCharCounterClasses;
}

/**
 * A Checkbox is a mechanism that allows the user to select one or more options.
 *
 * Usually used in a Checkbox Group to present the user with a range of options from
 * which the user <b>may select any number of options</b> to complete their task.
 *
 * It can also be used individually to represent the toggle of a single option, when
 * the Toggle Switch and Toggle Button aren't more appropriate.
 */
export declare const HvCheckBox: (props: HvCheckBoxProps) => JSX_2.Element;

export declare type HvCheckBoxClasses = ExtractNames<typeof useClasses_56>;

/**
 * A checkbox group is a type of selection list that allows the user to select multiple options through the use of checkboxes.
 */
export declare const HvCheckBoxGroup: (props: HvCheckBoxGroupProps) => JSX_2.Element;

export declare type HvCheckBoxGroupClasses = ExtractNames<typeof useClasses_62>;

export declare interface HvCheckBoxGroupProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * The form element name.
     *
     * It is propagated to the children checkboxes, unless they already have one.
     */
    name?: string;
    /**
     * The value of the form element. An array of values represented in the child checkboxes.
     *
     * When defined the checkbox group state becomes controlled.
     */
    value?: any[];
    /**
     * When uncontrolled, defines the initial value.
     */
    defaultValue?: any[];
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
    /**
     * Indicates that the form element is disabled.
     * If `true` the state is propagated to the children checkboxes.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is not editable.
     * If `true` the state is propagated to the children checkboxes.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: React.ReactNode;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, value: any[]) => void;
    /**
     * Indicates whether the checkbox group's orientation is horizontal or vertical.
     *
     * Defaults to vertical.
     */
    orientation?: "vertical" | "horizontal";
    /**
     * Indicates if an additional select all checkbox should be shown.
     */
    showSelectAll?: boolean;
    /**
     * The label of the select all checkbox. Defaults to "All".
     */
    selectAllLabel?: string;
    /**
     * Custom label for select all checkbox conjunction
     */
    selectAllConjunctionLabel?: string;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvCheckBoxGroupClasses;
}

export declare interface HvCheckBoxProps extends Omit<HvBaseCheckBoxProps, "classes"> {
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React.ReactNode;
    /**
     * Properties passed on to the label element.
     */
    labelProps?: HvLabelProps;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: React.ReactNode;
    /**
     * A Jss Object used to override or extend the styles applied to the checkbox.
     */
    classes?: HvCheckBoxClasses;
}

export declare type HvClickOutsideEvent = MouseEvent | KeyboardEvent | TouchEvent;

export { HvColor }

export { HvColorAny }

/**
 * A color picker component which allows the user to select a color from a list of pre-defined colors or freely select one color via the Hue and Saturation.
 * It receives a color string in HEX format and outputs an HEX formatted color.
 */
export declare const HvColorPicker: (props: HvColorPickerProps) => JSX_2.Element;

export declare type HvColorPickerClasses = ExtractNames<typeof useClasses_114>;

export declare interface HvColorPickerProps {
    "aria-label"?: string;
    "aria-labelledby"?: string;
    "aria-describedby"?: string;
    /** Class names to be applied. */
    className?: string;
    /** Id to be applied to the form element root node. */
    id?: string;
    /** The form element name. */
    name?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /** The value color, in HEX format. */
    value?: string;
    /** The default value color, in HEX format. */
    defaultValue?: string;
    /** If `true` the dropdown is disabled unable to be interacted, if `false` it is enabled. */
    disabled?: boolean;
    /** If `true` the dropdown starts opened if `false` it starts closed. */
    expanded?: boolean;
    /** When uncontrolled, defines the initial expanded state. */
    defaultExpanded?: boolean;
    /** A function to be executed whenever the color changes. */
    onChange?: (color: string) => void;
    /** A function to be executed whenever the color change is complete. */
    onChangeComplete?: (color: string) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvColorPickerClasses;
    /** The placeholder value when nothing is selected. */
    placeholder?: string;
    /** Recommended colors. The colors are HEX values. */
    recommendedColors?: string[];
    /** Recommended colors position. */
    recommendedColorsPosition?: "top" | "bottom";
    /** If `true`, the labels are shown. If `false`, they are not shown. */
    showLabels?: boolean;
    /** An object containing all the labels. */
    labels?: {
        recommendedColorsLabel?: string;
        customColorsLabel?: string;
    };
    /** Icon type for the input's end adornment. */
    dropdownIcon?: "arrow" | "colorPicker";
    /** If `true`, the input only shows an icon. If `false`, the input shows text and icons. */
    iconOnly?: boolean;
    /** If `true`, the saved colors area is shown. If `false`, it is not shown. */
    showSavedColors?: boolean;
    /** If `true`, the custom colors area is shown. If `false`, it is not shown. */
    showCustomColors?: boolean;
    /** The saved colors. The colors are HEX values. */
    savedColorsValue?: string[];
    /** The default saved colors. The colors are HEX values. */
    defaultSavedColorsValue?: string[];
    /** Callback fired when a new saved color is added. */
    onSavedColorAdded?: (color?: string) => void;
    /** Callback fired when a new saved color is removed. */
    onSavedColorRemoved?: (color?: string) => void;
    /** Aria label to apply to delete saved color button. */
    deleteSavedColorButtonArialLabel?: string;
    /** Aria label to apply to add saved color button. */
    addSavedColorButtonAriaLabel?: string;
}

declare type HvColumnGroup<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableColumnOptions<D, H> & HvColumnGroupInterface<D, H> & ({
    Header: H;
} | ({
    id: IdType<D>;
} & {
    Header: H;
})) & {
    accessor?: Accessor<D>;
};

declare interface HvColumnGroupInterface<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> {
    columns: Array<HvTableColumnConfig<D, H>>;
}

export declare interface HvColumnInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<ColumnInstance<D>, "Cell" | "columns" | "parent" | "placeholderOf" | "id" | "Header" | "getHeaderProps" | "getFooterProps" | "Footer">, HvTableColumnOptions<D, H>, Partial<UseFiltersColumnProps<D>>, Partial<UseGroupByColumnProps<D>>, Partial<UseResizeColumnsColumnProps<D>>, Partial<UseSortByColumnProps<D>> {
    Cell?: Renderer<HvCellProps<D, H>>;
    columns: Array<HvColumnInstance<D, H>>;
    parent: HvColumnInstance<D, H>;
    placeholderOf?: HvColumnInstance<D, H>;
    getHeaderProps: (propGetter?: HvHeaderPropGetter<D, H>) => HvUseTableHeaderProps;
    getFooterProps: (propGetter?: HvFooterPropGetter<D, H>) => HvUseTableFooterProps;
}

declare interface HvColumnInterfaceBasedOnValue<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, V = any> {
    Cell?: Renderer<HvCellProps<D, H, V>>;
}

declare type HvColumnWithLooseAccessor<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableColumnOptions<D, H> & HvColumnInterfaceBasedOnValue<D, H> & ({
    Header: H;
} | {
    id: IdType<D>;
} | {
    accessor: keyof D extends never ? IdType<D> : never;
}) & {
    accessor?: keyof D extends never ? IdType<D> | Accessor<D> : Accessor<D>;
};

declare type HvColumnWithStrictAccessor<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableColumnOptions<D, H> & ValueOf<{
    [K in keyof D]: {
        accessor: K;
    } & HvColumnInterfaceBasedOnValue<D, H, D[K]>;
}>;

/** The container enables you to center your content horizontally and bound it to a specific breakpoint. */
export declare const HvContainer: ForwardRefExoticComponent<Omit<HvContainerProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvContainerClasses = ExtractNames<typeof useClasses_24>;

export declare interface HvContainerProps extends Omit<ContainerProps, "classes">, HvBaseProps {
    /**
     * The component used for the root node.
     * Either a string to use a DOM element or a component.
     */
    component?: React.ElementType;
    /**
     * Determine the max-width of the container.
     * The container width grows with the size of the screen.
     * Set to `false` to disable `maxWidth`.
     */
    maxWidth?: "xs" | "sm" | "md" | "lg" | "xl" | false;
    /** If `true`, the left and right padding is removed. */
    disableGutters?: boolean;
    /**
     * Set the max-width to match the min-width of the current breakpoint.
     * This is useful if you'd prefer to design for a fixed set of sizes
     * instead of trying to accommodate a fully fluid viewport.
     * It's fluid by default.
     */
    fixed?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvContainerClasses;
}

export declare const HvControls: (props: HvControlsProps) => JSX_2.Element;

export declare type HvControlsClasses = ExtractNames<typeof useClasses_90>;

export declare interface HvControlsProps extends HvBaseProps {
    /**
     * An instance of useHvTable or useTable used to manage the data
     * if this is not provided data sorting and search must be handled externally
     */
    callbacks?: {
        setSortBy?: HvTableInstance["setSortBy"];
        setGlobalFilter?: HvTableInstance["setGlobalFilter"];
    };
    /**
     * Views configuration required for the view buttons
     */
    views?: HvControlsViewConfiguration[];
    /**
     * What view is selected by default
     */
    defaultView?: string;
    /**
     * Sets the selected view to be the one specified
     * if specified the component is in a controlled state and it won't change it state
     * unless specified externally
     */
    selectedView?: string;
    /**
     * Callback called when the view switcher button is pressed
     */
    onViewChange?: (event: MouseEvent_2<HTMLButtonElement>, id: string) => void;
    /**
     * if `true` the button to switch views is not rendered
     */
    hideViewSwitcher?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvControlsClasses;
}

export declare interface HvControlsViewConfiguration extends HvExtraProps {
    id?: string;
    label?: string;
    icon?: React.ReactNode;
}

/**
 * Create theme props
 */
export declare interface HvCreateThemeProps extends HvThemeCustomizationProps {
    /**
     * The name used for the theme.
     *
     * This is a required property to create a theme.
     */
    name: string;
    /**
     * The theme to be used as base.
     *
     * `"ds5"` will be used as default if no value is provided.
     */
    base?: HvBaseTheme;
    /**
     * If `true` the default color modes (dawn and wicked) of the base theme will be inherited while creating the theme.
     * If `false`, the new theme doesn't inherit the default color modes.
     *
     * By default the color modes are inherited.
     */
    inheritColorModes?: boolean;
}

export declare function hvDateColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, dateFormat?: string): HvTableColumnConfig<D, H>;

export declare const HvDateColumnCell: ({ date, dateFormat, }: HvDateColumnCellProp) => JSX.Element;

export declare interface HvDateColumnCellProp {
    /** The date's text representation format. */
    dateFormat?: string;
    /** Date to render. */
    date?: string;
}

/**
 * A date picker, popup calendar or date range picker is a graphical user
 * interface widget which allows the user to select a date from a calendar.
 */
export declare const HvDatePicker: (props: HvDatePickerProps) => JSX_2.Element;

export declare type HvDatePickerClasses = ExtractNames<typeof useClasses_106>;

export declare interface HvDatePickerProps extends Omit<HvFormElementProps, "onChange">, Pick<HvBaseDropdownProps, "disablePortal" | "expanded" | "defaultExpanded" | "onToggle"> {
    /**
     * Identifies the element that provides an error message for the date picker.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (date?: Date, endDate?: Date) => void;
    /**
     * The callback fired when user clicks on cancel.
     */
    onCancel?: () => void;
    /**
     * The callback fired when user clicks on clear.
     */
    onClear?: () => void;
    /**
     * An object containing all the labels for the datepicker.
     */
    labels?: {
        /**
         * Apply button label.
         */
        applyLabel?: string;
        /**
         * Cancel button label.
         */
        cancelLabel?: string;
        /**
         * Clear button label.
         */
        clearLabel?: string;
        /**
         * Invalid Date label.
         */
        invalidDateLabel?: string;
    };
    /**
     * The initial value of the input when in single calendar mode.
     */
    value?: Date;
    /**
     * The initial value for the start date when in range mode.
     */
    startValue?: Date;
    /**
     * The initial value for the end date when in range mode.
     */
    endValue?: Date;
    /**
     * Flag informing if the the component should be in range mode or in single mode.
     */
    rangeMode?: boolean;
    /**
     * The placement where the calendar should be placed according to the input. Options are `left` or `right`.
     * Note this prop only affects the calendar when in `rangeMode`.
     */
    horizontalPlacement?: "left" | "right";
    /**
     * The calendar locale. If undefined, it uses calendar default
     */
    locale?: string;
    /**
     * Controls if actions buttons are visible at the calendar.
     */
    showActions?: boolean;
    /**
     * Controls if clear button is visible at the calendar,
     * only works if showing actions or in range mode.
     */
    showClear?: boolean;
    /**
     * Sets if the calendar container should follow the date picker input out of the screen or stay visible.
     */
    escapeWithReference?: boolean;
    /**
     * An element placed before the Calendar
     */
    startAdornment?: React.ReactNode;
    /**
     * An object containing props to be passed onto the baseDropdown.
     */
    dropdownProps?: Partial<HvBaseDropdownProps>;
    /**
     * Additional props passed to the HvCalendar component.
     */
    calendarProps?: Partial<HvCalendarProps>;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvDatePickerClasses;
}

/** @deprecated use `HvFormStatus` instead */
export declare type HvDatePickerStatus = HvFormStatus;

export declare const HvDialog: (props: HvDialogProps) => JSX_2.Element;

export declare type HvDialogActionClasses = ExtractNames<typeof useClasses_27>;

export declare const HvDialogActions: (props: HvDialogActionsProps) => JSX_2.Element;

export declare interface HvDialogActionsProps extends Omit<DialogActionsProps, "classes">, HvBaseProps {
    /** Set the dialog to fullscreen mode. */
    fullscreen?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogActionClasses;
}

export declare type HvDialogClasses = ExtractNames<typeof useClasses_28>;

export declare const HvDialogContent: (props: HvDialogContentProps) => JSX_2.Element;

export declare type HvDialogContentClasses = ExtractNames<typeof useClasses_26>;

export declare interface HvDialogContentProps extends Omit<DialogContentProps, "classes">, HvBaseProps {
    /** Content should be indented in relationship to the Dialog title. */
    indentContent?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogContentClasses;
}

export declare interface HvDialogProps extends Omit<DialogProps, "fullScreen" | "classes" | "open">, HvBaseProps {
    /** Current state of the Dialog. */
    open?: boolean;
    /** Function executed on close. */
    onClose?: (event: React_2.SyntheticEvent, reason?: "escapeKeyDown" | "backdropClick") => void;
    /** @inheritdoc */
    maxWidth?: DialogProps["maxWidth"];
    /** @inheritdoc */
    fullWidth?: DialogProps["fullWidth"];
    /**
     * Element id that should be focus when the Dialog opens.
     * Auto-focusing elements can cause usability issues, so this should be avoided.
     * @deprecated Use `autoFocus` on the element instead, if auto-focusing is required.
     */
    firstFocusable?: string;
    /** Title for the button close. */
    buttonTitle?: string;
    /** Set the dialog to fullscreen mode. */
    fullscreen?: boolean;
    /** Prevent closing the dialog when clicking on the backdrop. */
    disableBackdropClick?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogClasses;
    /** Variant of the dialog. Adds a status bar to the top of the dialog. If not provided, no status bar is added. */
    variant?: "success" | "error" | "warning";
    /** @ignore */
    ref?: DialogProps["ref"];
    /** @ignore */
    component?: DialogProps["component"];
}

export declare const HvDialogTitle: (props: HvDialogTitleProps) => JSX_2.Element;

export declare type HvDialogTitleClasses = ExtractNames<typeof useClasses_25>;

export declare interface HvDialogTitleProps extends Omit<DialogTitleProps, "variant" | "classes">, HvBaseProps<HTMLSpanElement, "color"> {
    /** Variant of the dialog title. */
    variant?: HvDialogTitleVariant;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDialogTitleClasses;
}

export declare type HvDialogTitleVariant = "success" | "warning" | "error" | "info" | "default";

/**
 * Pagination is the process of dividing a document into discrete pages. It relates to how users interact with structured content on a website or application.
 * This component uses Radio Buttons to represent each page.
 */
export declare const HvDotPagination: (props: HvDotPaginationProps) => JSX_2.Element;

export declare type HvDotPaginationClasses = ExtractNames<typeof useClasses_71>;

export declare interface HvDotPaginationProps extends Omit<HvRadioGroupProps, "classes"> {
    /**
     * Icon to override the default one used for the unselected state.
     *
     * The default icon is `OtherStep`.
     */
    unselectedIcon?: React.ReactElement;
    /**
     * Icon to override the default one used for the selected state.
     *
     * The default icon is `CurrentStep`.
     */
    selectedIcon?: React.ReactElement;
    /**
     *  The number of pages the component has.
     */
    pages?: number;
    /**
     * The currently selected page.
     */
    page?: number;
    /**
     * The callback fired when the page value changes.
     */
    onPageChange?: (event: React.ChangeEvent<HTMLInputElement>, page: number) => void;
    /**
     * The callback fired to get the page aria label.
     */
    getItemAriaLabel?: (page: number) => string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvDotPaginationClasses;
}

/**
 * The Drawer component provides a foundation to create a sliding pane.
 * It only provides the pane with a close button, the rest of the
 * content can be customized.
 */
export declare const HvDrawer: (props: HvDrawerProps) => JSX_2.Element;

export declare type HvDrawerClasses = ExtractNames<typeof useClasses_29>;

export declare interface HvDrawerProps extends DrawerProps, Omit<DrawerProps, "classes">, HvBaseProps<HTMLDivElement> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvDrawerClasses;
    /**
     * Components of the Drawer.
     */
    children?: React.ReactNode;
    /**
     * Current state of the Drawer.
     */
    open?: boolean;
    /**
     * Function executed on close.
     * Extended from Modal from material-ui
     *
     */
    onClose?: (event: React.SyntheticEvent, reason?: "escapeKeyDown" | "backdropClick") => void;
    /**
     * The side the drawer opens from.
     */
    anchor?: "left" | "top" | "right" | "bottom";
    /**
     * Title for the button close.
     */
    buttonTitle?: string;
    /** @ignore */
    ref?: DrawerProps["ref"];
    /** @ignore */
    component?: DrawerProps["component"];
}

/**
 * A dropdown list is a graphical control element, similar to a list box, that allows the user to choose one value from a list.
 */
export declare const HvDropdown: (props: HvDropdownProps) => JSX_2.Element;

export declare type HvDropdownClasses = ExtractNames<typeof useClasses_80>;

export declare function hvDropdownColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, id: string | undefined, placeholder: string, disabledPlaceholder: string, onChange?: (identifier: string, value: HvListValue) => void): HvTableColumnConfig<D, H>;

export declare const HvDropdownColumnCell: ({ values, disabled, onChange, placeholder, dropdownProps, }: HvDropdownColumnCellProp) => JSX.Element;

export declare interface HvDropdownColumnCellProp {
    /** Values to render in the dropdown. */
    values: HvListValue[];
    /** Placeholder text for when the dropdown is empty. */
    placeholder: string;
    /** The whether the dropdown is disabled. */
    disabled: boolean;
    /** Function called when there is change on the dropdown. */
    onChange?: (value: HvListValue) => void;
    /** Extra props to be passed onto the dropdown. */
    dropdownProps?: HvDropdownProps;
}

export declare interface HvDropdownLabelsProps {
    /**
     * Label for overwrite the default header behavior.
     */
    select?: string;
    /**
     * Label used for the All checkbox action.
     */
    selectAll?: string;
    /**
     * Cancel button label.
     */
    cancelLabel?: string;
    /**
     * Apply button label.
     */
    applyLabel?: string;
    /**
     * The label used in the middle of the multiSelection count.
     */
    multiSelectionConjunction?: string;
    /**
     * The label used in search.
     */
    searchPlaceholder?: string;
}

declare type HvDropdownListClasses = ExtractNames<typeof useClasses_81>;

declare interface HvDropdownListProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * A Jss Object used to override or extend the component styles.
     */
    classes?: HvDropdownListClasses;
    /**
     * The list to be rendered.
     */
    values?: HvListValue[];
    /**
     * If true renders a multi select list.
     */
    multiSelect?: boolean;
    /**
     * If true renders the search component.
     */
    showSearch?: boolean;
    /**
     * A function to be executed whenever a item is selected in the list
     * or the Apply button is activated (when `multiSelect` is `true`).
     */
    onChange: (
    /** An array containing the selected values */
    listValues: HvListValue[], 
    /** If `true` the selection if finally committed the dropdown header text should reflect the new selection */
    commitChanges: boolean, 
    /** If `true` the dropdown should toggle it's current state */
    toggle: boolean, 
    /** If `true` the dropdown will call onChange */
    notifyChanges: boolean) => void;
    /**
     * A function to be executed whenever the Cancel button is activated.
     */
    onCancel: (event: MouseEvent_2) => void;
    /**
     * An object containing all the labels for the dropdown.
     */
    labels?: HvDropdownLabelsProps;
    /**
     * If 'true' the dropdown will notify on the first render.
     */
    notifyChangesOnFirstRender?: boolean;
    /**
     * If `true` the dropdown will show tooltips when user mouseenter text in list
     */
    hasTooltips?: boolean;
    /**
     * If `true`, selection can be toggled when single selection.
     */
    singleSelectionToggle?: boolean;
    /**
     * Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used
     */
    height?: number;
    /**
     * Experimental. Max height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class.
     */
    maxHeight?: number;
    /**
     * Experimental. Uses dropdown in a virtualized form, where not all options are rendered initially. Good for use cases with a lot of options.
     */
    virtualized?: boolean;
}

/**
 * A drop-down menu is a graphical control element, similar to a list box, that allows the user to choose a value from a list.
 */
export declare const HvDropDownMenu: (props: HvDropDownMenuProps) => JSX_2.Element;

export declare type HvDropDownMenuClasses = ExtractNames<typeof useClasses_67>;

export declare interface HvDropDownMenuProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    /** Icon. */
    icon?: React.ReactElement;
    /**
     * A list containing the elements to be rendered.
     *
     * - label: The label of the element to be rendered.
     * - selected: The selection state of the element.
     * - disabled: The disabled state of the element.
     * - icon: The icon node to be rendered on the left.
     * - showNavIcon: If true renders the navigation icon on the right.
     */
    dataList: HvListValue[];
    /** Placement of the dropdown. */
    placement?: "left" | "right";
    /** Disable the portal behavior. The children stay within it's parent DOM hierarchy. */
    disablePortal?: boolean;
    /** Function executed on toggle of the dropdown. Should receive the open status. */
    onToggle?: (event: Event, open: boolean) => void;
    /** Function executed in each onClick. Should received the clicked element. */
    onClick?: (event: React.ChangeEvent<HTMLLIElement>, value: HvListValue) => void;
    /** Keep the Dropdown Menu opened after clicking one option */
    keepOpened?: boolean;
    /** Defines if the component is disabled. */
    disabled?: boolean;
    /** If true it should be displayed open. */
    expanded?: boolean;
    /** When uncontrolled, defines the initial expanded state. */
    defaultExpanded?: boolean;
    /** The variant to be used in the header. */
    category?: HvButtonVariant;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvDropDownMenuClasses;
}

export declare interface HvDropdownProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvDropdownClasses;
    /**
     * The form element name.
     */
    name?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: any;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: any;
    /**
     * The placeholder value when nothing is selected.
     */
    placeholder?: string;
    /**
     * Indicates that the form element is disabled.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is in read only mode.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvDropdownStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: any;
    /**
     * Identifies the element that provides an error message for the dropdown.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (selected: HvListValue | HvListValue[] | undefined) => void;
    /**
     * The list to be rendered by the dropdown.
     */
    values?: HvListValue[];
    /**
     * If `true` the dropdown is multiSelect, if `false` the dropdown is single select.
     */
    multiSelect?: boolean;
    /**
     * If `true` the dropdown is rendered with a search bar, if `false` there won't be a search bar.
     */
    showSearch?: boolean;
    /**
     * If `true` the dropdown starts opened if `false` it starts closed.
     */
    expanded?: boolean;
    /**
     * When uncontrolled, defines the initial expanded state.
     */
    defaultExpanded?: boolean;
    /**
     * If 'true' the dropdown will notify on the first render.
     */
    notifyChangesOnFirstRender?: boolean;
    /**
     * An object containing all the labels for the dropdown.
     */
    labels?: HvDropdownLabelsProps;
    /**
     * If `true` the dropdown will show tooltips when user mouseenter text in list
     */
    hasTooltips?: boolean;
    /**
     * Disable the portal behavior.
     * The children stay within it's parent DOM hierarchy.
     */
    disablePortal?: boolean;
    /**
     * If `true` the dropdown width depends size of content if `false` the width depends on the header size.
     * Defaults to `false`.
     */
    variableWidth?: boolean;
    /**
     * If `true`, selection can be toggled when single selection.
     */
    singleSelectionToggle?: boolean;
    /**
     * Placement of the dropdown.
     */
    placement?: "left" | "right";
    /**
     * An object containing props to be wired to the popper component.
     */
    popperProps?: Partial<PopperProps>;
    /**
     * Callback called when the user cancels the changes.
     *
     * Called when the cancel button is used and when the user clicks outside the open container.
     *
     * @param {object} event The event source of the callback.
     */
    onCancel?: (event: Event) => void;
    /**
     * Callback called when dropdown changes the expanded state.
     *
     * @param {object} event The event source of the callback.
     * @param {boolean} open If the dropdown new state is open (`true`) or closed (`false`).
     */
    onToggle?: (event: Event, open: boolean) => void;
    /**
     * Callback called when the user clicks outside the open container.
     *
     * @param {object} event The event source of the callback.
     */
    onClickOutside?: (event: Event) => void;
    /**
     * @ignore
     */
    onFocus?: React.FocusEventHandler<any>;
    /**
     * @ignore
     */
    onBlur?: React.FocusEventHandler<any>;
    /**
     * Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used
     */
    height?: number;
    /**
     * Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used
     */
    maxHeight?: number;
    /**
     * Experimental. Uses dropdown in a virtualized form, where not all options are rendered initially. Good for use cases with a lot of options.
     */
    virtualized?: boolean;
    /**
     * Extra props passed to the dropdown.
     */
    baseDropdownProps?: HvBaseDropdownProps;
    /**
     * Extra props passed to the list.
     */
    listProps?: HvDropdownListProps;
}

export declare type HvDropdownStatus = "standBy" | "valid" | "invalid";

declare interface HvDropZoneLabels {
    /**
     * Extensions of the accepted file types
     */
    acceptedFiles?: string;
    /**
     * Dropzone area label.
     */
    dropzone?: string;
    /**
     * Size file warning label.
     */
    sizeWarning?: string;
    /**
     * Size file warning label.
     */
    drag?: string;
    /**
     * Size file warning label.
     */
    selectFiles?: string;
    /**
     * Theming sheet used to style components
     * */
    dropFiles?: string;
    /**
     * Message to display when file size is greater than allowed
     * */
    fileSizeError?: string;
    /**
     * Message to display when file type is greater than allowed
     * */
    fileTypeError?: string;
}

/**
 * Empty states communicate that there’s no information, data or values to display in a given context.
 */
export declare const HvEmptyState: (props: HvEmptyStateProps) => JSX_2.Element;

export declare type HvEmptyStateClasses = ExtractNames<typeof useClasses_30>;

export declare interface HvEmptyStateProps extends HvBaseProps<HTMLDivElement, "title"> {
    /** Icon to be presented. */
    icon: React_2.ReactNode;
    /** The title to be shown. */
    title?: string | React_2.ReactNode;
    /** The message to be shown. */
    message?: string | React_2.ReactNode;
    /** The action message to be shown. */
    action?: string | React_2.ReactNode;
    /** A Jss Object used to override or extend the styles applied to the empty state component. */
    classes?: HvEmptyStateClasses;
}

export declare function hvExpandColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, expandRowButtonAriaLabel: string, collapseRowButtonAriaLabel: string, getCanRowExpand?: (row: HvRowInstance<D, H>) => boolean, ExpandedIcon?: React.ReactNode, CollapsedIcon?: React.ReactNode): HvTableColumnConfig<D, H>;

/** This type combines the HvExtraProps and DeepPartial types */
export declare type HvExtraDeepPartialProps<T> = Partial<{
    [P in keyof T]: DeepPartial<T[P]> & HvExtraProps;
}> & HvExtraProps;

export { HvExtraDeepProps }

export { HvExtraProps }

export declare const HvFile: ({ id, classes: classesProp, data, onFileRemoved, removeFileButtonLabel, }: HvFileProps) => JSX_2.Element;

export declare type HvFileClasses = ExtractNames<typeof useClasses_66>;

export declare interface HvFileData extends Omit<File, "name" | "size"> {
    /**
     * The file id.
     */
    id?: string;
    /**
     * The file name.
     */
    name?: string;
    /**
     * The upload status.
     */
    status?: "progress" | "success" | "fail";
    /**
     * The file size in bytes.
     */
    size?: number;
    /**
     * Upload progress in bytes.
     */
    progress?: number;
    /**
     * Optional node representing a preview of the uploaded file.
     */
    preview?: React.ReactNode;
    /**
     * Error message when the upload failed.
     */
    errorMessage?: string;
}

export declare type HvFileProps = {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * File information to be displayed.
     */
    data: HvFileData;
    /**
     * Callback fired when file is removed from list.
     */
    onFileRemoved?: HvFileRemovedEvent;
    /**
     * Value of aria-label to apply to remove file button in file list.
     * */
    removeFileButtonLabel?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvFileClasses;
};

export declare type HvFileRemovedEvent = (file: HvFileData) => void;

export declare type HvFilesAddedEvent = (files: HvFileData[]) => void;

/**
 * Lets the user choose one or more files from their device storage. Once chosen,
 * the files can be uploaded to a server or manipulated on the client side.
 *
 * Accepted file types follow the format of the html input accept attribute. Please check https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file for more details.
 */
export declare const HvFileUploader: (props: HvFileUploaderProps) => JSX_2.Element;

export declare interface HvFileUploaderLabels extends HvDropZoneLabels {
    /**
     * Value of aria-label to apply to remove file button in FileList
     * */
    removeFileButtonLabel?: string;
}

/**
 * The `HvFileUploaderPreview` component is available to facilitate the styling
 * of the button (when clickable) and the detection of image unloading.
 */
export declare const HvFileUploaderPreview: ({ className, children, classes: classesProp, disableOverlay, onUnload, onClick, ...others }: HvFileUploaderPreviewProps) => JSX_2.Element;

export declare type HvFileUploaderPreviewClasses = ExtractNames<typeof useClasses_65>;

export declare interface HvFileUploaderPreviewProps extends Omit<HvButtonProps, "children" | "classes"> {
    /**
     * Content that represents the preview of an uploaded file.
     */
    children: React.ReactElement;
    /**
     * Callback executed when the preview is unmounted.
     *
     * Should be used for cleaning up client-side image URLs created by `URL.createObjectURL()`.
     */
    onUnload?: () => void;
    /**
     * If `true`, doesn't show an overlay on top of the preview when hovering.
     *
     * Only applies when `onClick` is set.
     */
    disableOverlay?: boolean;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvFileUploaderPreviewClasses;
}

export declare interface HvFileUploaderProps extends HvBaseProps {
    /**
     * An object containing all the labels.
     */
    labels?: HvFileUploaderLabels;
    /**
     * The files to upload.
     */
    fileList?: HvFileData[];
    /**
     * Whether the Dropzone should accept multiple files at once.
     */
    multiple?: boolean;
    /**
     * If the input is disabled or not
     */
    disabled?: boolean;
    /**
     * Max upload size
     * */
    maxFileSize?: number;
    /**
     * Files extensions accepted for upload.
     */
    acceptedFiles?: string[];
    /**
     * Callback fired when files are added.
     */
    onFilesAdded?: HvFilesAddedEvent;
    /**
     * Callback fired when file is removed from list.
     */
    onFileRemoved?: HvFileRemovedEvent;
    /**
     * Whether the DropZone should hide labels or not.
     */
    hideLabels?: boolean;
    /**
     * Attributes applied to the input element.
     */
    inputProps?: React.InputHTMLAttributes<HTMLInputElement>;
}

/**
 * This component implements one potential use-case of the Filter Group pattern Design System Specifies.
 * Due to the enormous variety of capabilities required for this, we strongly recommend checking the code of the component and extend it yourself,
 * while we do not provide a better approach for building this component with smaller and more composable parts.
 */
export declare const HvFilterGroup: (props: HvFilterGroupProps) => JSX_2.Element;

export declare type HvFilterGroupClasses = ExtractNames<typeof useClasses_104>;

declare type HvFilterGroupContentClasses = ExtractNames<typeof useClasses_105>;

declare interface HvFilterGroupContentProps extends Omit<HvBaseDropdownProps, "onChange"> {
    description?: React.ReactNode;
    status?: HvFormStatus;
    onChange?: (event: React.MouseEvent<HTMLButtonElement>, value?: HvFilterGroupValue) => void;
    onCancel?: (event: React.MouseEvent<HTMLButtonElement> | Event) => void;
    onClear?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    labels?: HvFilterGroupLabels;
    horizontalPlacement?: HvFilterGroupHorizontalPlacement;
    disablePortal?: boolean;
    escapeWithReference?: boolean;
    height?: string | number;
    leftEmptyElement?: React.ReactNode;
    rightEmptyElement?: React.ReactNode;
    disabled?: boolean;
    classes?: HvFilterGroupContentClasses;
}

export declare type HvFilterGroupFilters = {
    id: string;
    name: string;
    data: {
        id: string | number;
        name: string;
    }[];
}[];

export declare type HvFilterGroupHorizontalPlacement = "left" | "right";

export declare interface HvFilterGroupLabels {
    /** Apply button label. */
    applyLabel?: string;
    /** Cancel button label. */
    cancelLabel?: string;
    /** Cancel button label. */
    clearLabel?: string;
    /** Placeholder label. */
    placeholder?: string;
    /** SearchBox placeholder label. */
    searchBoxPlaceholder?: string;
    /** Select All placeholder label. */
    selectAll?: string;
    /** Multi selection conjunction placeholder label. */
    multiSelectionConjunction?: string;
}

export declare interface HvFilterGroupProps extends Omit<HvFormElementProps, "classes" | "onChange" | "defaultValue" | "statusMessage"> {
    /** The initial value of the input when in single calendar mode. */
    filters: HvFilterGroupFilters;
    /** The form element name. */
    name?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**  Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** Indicates that the form element is disabled. */
    disabled?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**  The error message to show when `status` is "invalid". Defaults to "Required". */
    statusMessage?: React.ReactNode;
    /** The callback fired when the cancel button is clicked. */
    onCancel?: (event: React.MouseEvent<HTMLButtonElement> | Event) => void;
    /** The callback fired when the clear filters button is clicked. */
    onClear?: (event: React.MouseEvent<HTMLButtonElement>) => void;
    /** The callback fired when the value changes. */
    onChange?: (event: React.MouseEvent<HTMLButtonElement>, value?: HvFilterGroupValue) => void;
    /** An Object containing the various text associated with the input. */
    labels?: HvFilterGroupLabels;
    /** The placeholder value when nothing is selected. */
    placeholder?: string;
    /** The default value of the filter group. If defined the clear action will reset to it. */
    defaultValue?: HvFilterGroupValue;
    /** The value of the filter group. */
    value?: HvFilterGroupValue;
    /** The placement where the filter group should be placed according to the input. Options are `left` or `right`. */
    horizontalPlacement?: HvFilterGroupHorizontalPlacement;
    /** Disable the portal behavior. The children stay within it's parent DOM hierarchy. */
    disablePortal?: boolean;
    /** Sets if the filter container should be out of the screen or stay visible. */
    escapeWithReference?: boolean;
    /** The height of the filter panel, between 295 and 425. Defaults to 350 */
    height?: number | string;
    /** The filter content props */
    filterContentProps?: Partial<HvFilterGroupContentProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFilterGroupClasses;
}

export declare type HvFilterGroupValue = (string | number)[][];

export declare const HvFocus: ({ classes: classesProp, children, configuration, disabledClass, selected, disabled, rootRef, focusOnClick, focusDisabled, strategy, useFalseFocus, filterClass, navigationJump, }: HvFocusProps) => JSX_2.Element;

export declare type HvFocusClasses = ExtractNames<typeof useClasses_2>;

export declare interface HvFocusProps extends HvBaseProps<HTMLElement, "children"> {
    children: React_2.ReactElement;
    /** Extra configuration for the child element. */
    configuration?: {
        tabIndex?: number;
    };
    /** Indicates that the disabled class should be applied. */
    disabledClass?: boolean;
    /** Whether the focus is selected. */
    selected?: boolean;
    /** Whether the focus is disabled. */
    disabled?: boolean;
    /** The reference to the root element to hold all Focus' context. */
    rootRef?: RefObject<HTMLElement>;
    /** Show focus when click element. v */
    focusOnClick?: boolean;
    /** Show focus when click element. v */
    focusDisabled?: boolean;
    /** Focus and navigation strategy to be used. v */
    strategy?: HvFocusStrategies;
    /** Uses an absolute positioned div as a focus. v */
    useFalseFocus?: boolean;
    /** Narrows the results of the focus to only theses class v */
    filterClass?: string;
    /** How much the navigation will skip when using the arrows. v */
    navigationJump?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFocusClasses;
}

export declare type HvFocusStrategies = "listbox" | "menu" | "card" | "grid";

/**
 * A Footer is a way of providing extra information at the end of a page.
 */
export declare const HvFooter: (props: HvFooterProps) => JSX_2.Element;

export declare type HvFooterClasses = ExtractNames<typeof useClasses_31>;

declare type HvFooterPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableFooterProps, {
    column: HvHeaderGroup<D, H>;
}>;

export declare interface HvFooterProps extends HvBaseProps {
    /** Footer name. */
    name?: React.ReactNode;
    /** Footer copyright. */
    copyright?: React.ReactNode;
    /** Footer links. */
    links?: React.ReactNode;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFooterClasses;
}

declare type HvFooterProps_2<D extends object = Record<string, unknown>> = HvTableInstance<D> & {
    column: HvColumnInstance<D>;
};

export declare const HvFormElement: {
    (props: HvFormElementProps): JSX_2.Element;
    formElementType: string;
};

export declare type HvFormElementClasses = ExtractNames<typeof useClasses_7>;

export declare const HvFormElementContext: React_2.Context<{
    elementId?: string | undefined;
    elementDisabled?: boolean | undefined;
    elementRequired?: boolean | undefined;
    elementStatus?: string | undefined;
}>;

export declare const HvFormElementContextConsumer: React_2.Consumer<{
    elementId?: string | undefined;
    elementDisabled?: boolean | undefined;
    elementRequired?: boolean | undefined;
    elementStatus?: string | undefined;
}>;

export declare const HvFormElementContextProvider: React_2.Provider<{
    elementId?: string | undefined;
    elementDisabled?: boolean | undefined;
    elementRequired?: boolean | undefined;
    elementStatus?: string | undefined;
}>;

export declare const HvFormElementDescriptorsContext: React_2.Context<{
    input?: any;
    label?: any;
}>;

export declare const HvFormElementDescriptorsContextConsumer: React_2.Consumer<{
    input?: any;
    label?: any;
}>;

export declare const HvFormElementDescriptorsContextProvider: React_2.Provider<{
    input?: any;
    label?: any;
}>;

export declare interface HvFormElementProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * Name of the form element.
     *
     * Part of a name/value pair, should be the name property of the underling native input.
     */
    name?: string;
    /**
     * Current value of the form element.
     *
     * Part of a name/value pair, should be the value property of the underling native input.
     */
    value?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React.ReactNode;
    /** Whether the form element is disabled. */
    disabled?: boolean;
    /** Indicates that the form element is not editable. */
    readOnly?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /** The error message to show when `status` is "invalid". */
    statusMessage?: string;
    /** The callback fired when the value changes. */
    onChange?: (event: React.FormEvent<HTMLDivElement>) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvFormElementClasses;
}

export declare const HvFormElementValueContext: React_2.Context<undefined>;

export declare const HvFormElementValueContextConsumer: React_2.Consumer<undefined>;

export declare const HvFormElementValueContextProvider: React_2.Provider<undefined>;

export declare type HvFormStatus = "standBy" | "valid" | "invalid" | "empty";

/**
 * Global Actions are actions that affect the entire page they live in.
 * They should persist while scrolling down the screen.
 */
export declare const HvGlobalActions: (props: HvGlobalActionsProps) => JSX_2.Element;

export declare type HvGlobalActionsClasses = ExtractNames<typeof useClasses_79>;

export declare type HvGlobalActionsHeadingLevel = 1 | 2 | 3 | 4 | 5 | 6;

export declare type HvGlobalActionsPosition = "sticky" | "fixed" | "relative";

export declare interface HvGlobalActionsProps extends HvBaseProps<HTMLDivElement, "title"> {
    /** Text to display in the component. */
    title?: React.ReactNode;
    /** Denotes if this is a global or section component. */
    variant?: HvGlobalActionsVariant;
    /** User can pass in a fully customized button or false for when the back button should not be rendered. */
    backButton?: React.ReactNode;
    /** Heading Level to apply to Title Area. */
    headingLevel?: HvGlobalActionsHeadingLevel;
    /**
     * Position of the Global Actions.
     * Defaults to `sticky` when it is a global title and `relative` when it's a section title.
     */
    position?: HvGlobalActionsPosition;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvGlobalActionsClasses;
}

export declare type HvGlobalActionsVariant = "global" | "section";

/**
 * The grid creates visual consistency between layouts while allowing flexibility
 * across a wide variety of designs. This component is based on a 12-column grid layout.
 *
 * It's based on the [Material UI Grid](https://mui.com/material-ui/react-grid/).
 *
 * The definitions were set following the Design System directives:
 *
 * | Breakpoint | Width (in px) | Gutters (in px) | Number of columns |
 * | ---------- | ------------- | --------------- | ----------------- |
 * | xs         | [0-600[       | 16              | 4                 |
 * | sm         | [600-960[     | 16              | 8                 |
 * | md         | [960-1270[     | 32              | 12                |
 * | lg         | [1270-1920[    | 32              | 12                |
 * | xl         | [1920-...[    | 32              | 12                |
 *
 * However, the number of columns is set to 12 for all breakpoints, as it serves most
 * of the use cases and simplifies the implementation.
 * To opt-in to the Design System directives, you can set the `columns` prop to `auto`.
 *
 * Also, the Design System specifications are omissive about the horizontal gutters.
 * The HvGrid sets them to the same value as the vertical gutters, depending on the breakpoint.
 * It can be overridden by setting the `rowSpacing` prop.
 */
export declare const HvGrid: ForwardRefExoticComponent<Omit<HvGridProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvGridClasses = ExtractNames<typeof useClasses_32>;

export declare type HvGridDirection = "row" | "row-reverse" | "column" | "column-reverse";

export declare interface HvGridProps extends Omit<GridProps, "classes" | "columns">, HvBaseProps<HTMLDivElement, "color"> {
    /**
     * If `true`, the component will have the flex *container* behavior.
     * You should be wrapping *items* with a *container*.
     */
    container?: boolean;
    /**
     * If `true`, the component will have the flex *item* behavior.
     * You should be wrapping *items* with a *container*.
     */
    item?: boolean;
    /**
     * Defines the space between the type item component. It can only be used on a type container component.
     * Based in the 8x factor defined in the theme, it allows the definition of this factor based on the factor
     * (number between 0 and 10), breakpoint or auto.
     */
    spacing?: HvGridSpacing | number;
    /**
     * Defines the vertical space between the type item component. It can only be used on a type container component.
     * Based in the 8x factor defined in the theme, it allows the definition of this factor based on the factor
     * (number between 0 and 10), breakpoint or auto.
     * It overrides the value of the spacing prop.
     */
    rowSpacing?: HvGridSpacing | number;
    /**
     * Defines the horizontal space between the type item component. It can only be used on a type container component.
     * Based in the 8x factor defined in the theme, it allows the definition of this factor based on the factor
     * (number between 0 and 10), breakpoint or auto.
     * It overrides the value of the spacing prop.
     */
    columnSpacing?: HvGridSpacing | number;
    /**
     * The number of columns.
     * Defaults to a 12-column grid.
     * The value "auto" implements the Design System directives in terms of variable number of columns.
     * @default 12
     */
    columns?: "auto" | GridProps["columns"];
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     */
    direction?: HvGridDirection;
    /**
     * Defines the `justify-content` style property.
     * It is applied for all screen sizes.
     */
    justify?: "flex-start" | "center" | "flex-end" | "space-between" | "space-around" | "space-evenly";
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for all the screen sizes with the lowest priority.
     */
    xs?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `sm` breakpoint and wider screens if not overridden.
     */
    sm?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `md` breakpoint and wider screens if not overridden.
     */
    md?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `lg` breakpoint and wider screens if not overridden.
     */
    lg?: number | boolean;
    /**
     * Defines the number of grids the component is going to use.
     * It's applied for the `xl` breakpoint and wider screens.
     */
    xl?: number | boolean;
    /**
     * Defines the `flex-wrap` style property.
     * It's applied for all screen sizes.
     */
    wrap?: "nowrap" | "wrap" | "wrap-reverse";
    /**
     * If `true`, it sets `min-width: 0` on the item.
     * Refer to the limitations section of the documentation to better understand the use case.
     */
    zeroMinWidth?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvGridClasses;
}

export declare type HvGridSpacing = "xs" | "sm" | "md" | "lg" | "xl" | "auto" | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10;

/**
 * Header component is used to render a header bar with logo and brand name, navigation and actions.
 */
export declare const HvHeader: (props: HvHeaderProps) => JSX_2.Element;

export declare const HvHeaderActions: (props: HvHeaderActionsProps) => JSX_2.Element;

export declare type HvHeaderActionsClasses = ExtractNames<typeof useClasses_34>;

export declare interface HvHeaderActionsProps extends HvBaseProps {
    classes?: HvHeaderActionsClasses;
}

/**
 * Header component is used to render a header bar with logo and brand name, navigation and actions.
 */
export declare const HvHeaderBrand: (props: HvHeaderBrandProps) => JSX_2.Element;

export declare type HvHeaderBrandClasses = ExtractNames<typeof useClasses_35>;

export declare interface HvHeaderBrandProps extends HvBaseProps {
    logo?: React.ReactNode;
    name?: string;
    classes?: HvHeaderBrandClasses;
}

export declare type HvHeaderClasses = ExtractNames<typeof useClasses_33>;

declare interface HvHeaderGroup<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends HvColumnInstance<D, H>, Omit<UseTableHeaderGroupProps<D>, "headers"> {
    headers: Array<HvHeaderGroup<D, H>>;
}

export declare const HvHeaderMenuBar: ({ data, onClick, type, levels, currentLevel, ...others }: HvHeaderMenuBarProps) => JSX_2.Element;

declare interface HvHeaderMenuBarProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    data: HvHeaderNavigationItemProp[];
    type: string;
    onClick?: (event: MouseEvent_2, selection: HvHeaderNavigationItemProp) => void;
    levels: number;
    currentLevel: number;
}

export declare const HvHeaderMenuItem: ({ id, item, type, onClick, levels, currentLevel, classes: classesProp, className, }: HvHeaderMenuItemProps) => JSX_2.Element;

declare type HvHeaderMenuItemClasses = ExtractNames<typeof useClasses_36>;

declare interface HvHeaderMenuItemProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    item: HvHeaderNavigationItemProp;
    type?: string;
    onClick?: (event: MouseEvent_2, selection: HvHeaderNavigationItemProp) => void;
    levels: number;
    currentLevel: number;
    classes?: HvHeaderMenuItemClasses;
}

export declare const HvHeaderNavigation: (props: HvHeaderNavigationProps) => JSX_2.Element;

export declare type HvHeaderNavigationClasses = ExtractNames<typeof useClasses_37>;

export declare interface HvHeaderNavigationItemProp {
    id: string;
    label: string;
    path?: string;
    href?: string;
    target?: string;
    data?: HvHeaderNavigationItemProp[];
}

export declare interface HvHeaderNavigationProps extends HvBaseProps<HTMLDivElement, "onClick"> {
    data: HvHeaderNavigationItemProp[];
    selected?: string;
    onClick?: (event: MouseEvent_2, selection: HvHeaderNavigationItemProp) => void;
    classes?: HvHeaderNavigationClasses;
    /**
     * The number of levels to show: the first level (1) or the first and second level (2).
     *
     * Defaults to `2`.
     * */
    levels?: 1 | 2;
}

export declare type HvHeaderPosition = "fixed" | "absolute" | "sticky" | "static" | "relative";

declare type HvHeaderPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableHeaderProps, {
    column: HvHeaderGroup<D, H>;
}>;

export declare interface HvHeaderProps extends HvBaseProps {
    /** The position of the header bar */
    position?: HvHeaderPosition;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvHeaderClasses;
}

declare type HvHeaderProps_2<D extends object = Record<string, unknown>> = HvTableInstance<D> & {
    column: HvColumnInstance<D>;
};

export declare interface HvHooks<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<Hooks<D>, "useOptions">, Partial<UseExpandedHooks<D>>, Partial<UseGroupByHooks<D>>, Partial<UseSortByHooks<D>>, Partial<UseHvRowSelectionHooks<D>>, Partial<UseHvTableStickyHooks<D>>, Partial<UseHvPaginationHooks<D>>, Partial<UseHvBulkActionsHooks<D>> {
    useOptions: Array<(options: HvTableOptions<D, H>, args: HvTableOptions<D, H>) => HvTableOptions<D, H>>;
    stateReducers: Array<(newState: HvTableState<D>, action: ActionType, previousState?: HvTableState<D>, instance?: HvTableState<D>) => ReducerTableState<D> | undefined>;
    columns: Array<(columns: Array<HvTableColumnConfig<D, H>>, meta: HvMeta<D, H>) => Array<HvTableColumnConfig<D, H>>>;
    allColumns: Array<(allColumns: Array<HvColumnInstance<D, H>>, meta: HvMeta<D, H>) => Array<HvTableColumnConfig<D, H>>>;
    visibleColumns: Array<(allColumns: Array<HvColumnInstance<D, H>>, meta: HvMeta<D, H>) => Array<HvTableColumnConfig<D, H>>>;
    headerGroups: Array<(allColumns: Array<HvHeaderGroup<D, H>>, meta: HvMeta<D, H>) => Array<HvHeaderGroup<D, H>>>;
    useInstanceBeforeDimensions: Array<(instance: HvTableInstance<D, H>) => void>;
    useInstance: Array<(instance: HvTableInstance<D, H>) => void>;
    useControlledState: Array<(state: HvTableState<D>, meta: HvMeta<D, H>) => HvTableState<D>>;
    getTableProps: Array<HvTablePropGetter<D, H>>;
    getHeaderProps: Array<HvHeaderPropGetter<D>>;
    getFooterProps: Array<HvFooterPropGetter<D>>;
    getRowProps: Array<HvRowPropGetter<D>>;
    getCellProps: Array<HvCellPropGetter<D>>;
    useFinalInstance: Array<(instance: HvTableInstance<D, H>) => void>;
}

export declare type HvHorizontalScrollListItemClasses = ExtractNames<typeof useClasses_109>;

/**
 * Provides the user with additional descriptive text for the form element.
 */
export declare const HvInfoMessage: (props: HvInfoMessageProps) => JSX_2.Element;

export declare type HvInfoMessageClasses = ExtractNames<typeof useClasses_9>;

export declare interface HvInfoMessageProps extends HvTypographyProps<"label"> {
    /** If `true` the label is disabled. */
    disabled?: boolean;
    /** If `true` the info message won't have margins. */
    disableGutter?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvInfoMessageClasses;
}

/**
 * An Inline Editor allows the user to edit a record without making a major switch
 * between viewing and editing, making it an efficient method of updating a record.
 */
export declare const HvInlineEditor: (props: HvInlineEditorProps) => JSX_2.Element;

export declare type HvInlineEditorClasses = ExtractNames<typeof useClasses_111>;

export declare interface HvInlineEditorProps extends HvBaseProps<HTMLDivElement, "onBlur" | "onChange"> {
    /** The value of the form element. */
    value?: string;
    /** Whether the Edit icon should always be visible */
    showIcon?: boolean;
    /** Component to use as the input. The component "inherit" from `HvBaseInput` (such as `HvInput` or `HvTextArea`) */
    component?: React_2.ElementType;
    /** Variant of the HvTypography to display */
    variant?: HvTypographyVariants;
    /** Called when the input is blurred. */
    onBlur?: (event: React_2.FocusEvent<HTMLTextAreaElement | HTMLInputElement>, value: string) => void;
    /** Called when the input value changes. */
    onChange?: (event: React_2.SyntheticEvent, value: string) => void;
    /** Props passed to the HvButton component */
    buttonProps?: HvButtonProps;
    /** Props passed to the HvTypography text component */
    typographyProps?: HvTypographyProps;
    /** A Jss Object used to override or extend the styles applied to the empty state component. */
    classes?: HvInlineEditorClasses;
}

/**
 * A text input box is a graphical control element intended to enable the user to input text information to be used by the software.
 */
export declare const HvInput: React_2.ForwardRefExoticComponent<HvInputProps & React_2.RefAttributes<InputElement>>;

export declare type HvInputClasses = ExtractNames<typeof useClasses_57>;

export declare interface HvInputLabels {
    /** The label of the clear button. */
    clearButtonLabel?: string;
    /** The label of the reveal password button. */
    revealPasswordButtonLabel?: string;
    /** The tooltip of the reveal password button when the password is hidden. */
    revealPasswordButtonClickToShowTooltip?: string;
    /** The tooltip of the reveal password button when the password is revealed. */
    revealPasswordButtonClickToHideTooltip?: string;
    /** The label of the search button. */
    searchButtonLabel?: string;
}

export declare interface HvInputProps extends HvBaseProps<HTMLElement, "onChange" | "onBlur" | "onFocus" | "onKeyDown" | "color"> {
    /** The form element name. */
    name?: string;
    /** The value of the form element. */
    value?: string;
    /** When uncontrolled, defines the initial input value. */
    defaultValue?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React_2.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React_2.ReactNode;
    /** Indicates that the form element is disabled. */
    disabled?: boolean;
    /** Indicates that the form element is not editable. */
    readOnly?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to `checked`, depending of the values of both `required` and `checked`.
     */
    status?: HvFormStatus;
    /** The error message to show when `status` is "invalid". */
    statusMessage?: string;
    /**
     * The function that will be executed onChange, allows modification of the input,
     * it receives the value. If a new value should be presented it must returned it.
     */
    onChange?: HvBaseInputProps["onChange"];
    /**
     * Callback called when the user submits the value by pressing Enter/Return.
     *
     * Also called when the search button is clicked (when type is "search").
     */
    onEnter?: (event: React_2.KeyboardEvent<InputElement> | React_2.MouseEvent, value: string) => void;
    /**
     * The function that will be executed onBlur, allows checking the validation state,
     * it receives the value and the validation state.
     */
    onBlur?: (event: React_2.FocusEvent<InputElement>, value: string, validationState: HvInputValidity) => void;
    /**
     * The function that will be executed onBlur, allows checking the value state,
     * it receives the value.
     */
    onFocus?: (event: React_2.FocusEvent<InputElement>, value: string) => void;
    /**
     * The function that will be executed onKeyDown, allows checking the value state,
     * it receives the event and value.
     */
    onKeyDown?: (event: React_2.KeyboardEvent<InputElement> | React_2.MouseEvent, value: string) => void;
    /** The input type. */
    type?: HTMLInputTypeAttribute;
    /** The placeholder value of the input. */
    placeholder?: string;
    /** Internal labels?. */
    labels?: HvInputLabels & HvExtraProps;
    /** An Object containing the various texts associated with the input. */
    validationMessages?: HvValidationMessages;
    /** Attributes applied to the input element. */
    inputProps?: InputBaseComponentProps;
    /**
     * Allows passing a ref to the underlying input
     * @deprecated Use `ref` directly instead
     * */
    inputRef?: HvBaseInputProps["inputRef"];
    /** The function that will be executed to received an array of objects that has a label and id to create list of suggestion */
    suggestionListCallback?: (value: string) => HvInputSuggestion[] | null;
    /**
     * The custom validation function, it receives the value and must return
     * either `true` for valid or `false` for invalid, default validations would only
     * occur if this function is null or undefined
     */
    validation?: (value: string) => boolean;
    /** If `true` it should autofocus. */
    autoFocus?: boolean;
    /** If `true` the clear button is disabled. */
    disableClear?: boolean;
    /** If `true` the reveal password button is disabled. Valid only when type is "password". */
    disableRevealPassword?: boolean;
    /** If `true` the search button is disabled. Valid only when type is "search". */
    disableSearchButton?: boolean;
    /**
     * If `true` the validation icon adornment is visible. Defaults to `false`.
     *
     * Currently, DS specifications define only a positive feedback icon;
     * errors are signaled through the border style and by displaying the error message.
     */
    showValidationIcon?: boolean;
    /** A custom icon to be added into the input. */
    endAdornment?: React_2.ReactNode;
    /** The maximum allowed length of the characters, if this value is null no check will be performed. */
    maxCharQuantity?: number;
    /** The minimum allowed length of the characters, if this value is null no check will be perform. */
    minCharQuantity?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvInputClasses;
}

export declare interface HvInputSuggestion {
    id: string;
    label: string;
    value?: string;
}

declare type HvInputValidity = {
    valid?: boolean;
    badInput?: boolean;
    customError?: boolean;
    patternMismatch?: boolean;
    rangeOverflow?: boolean;
    rangeUnderflow?: boolean;
    stepMismatch?: boolean;
    tooLong?: boolean;
    tooShort?: boolean;
    typeMismatch?: boolean;
    valueMissing?: boolean;
};

export declare interface HvKnobProperty {
    color?: string;
    defaultValue?: number;
    hidden?: boolean;
    fixed?: boolean;
    hoverColor?: string;
    trackColor?: string;
    dragColor?: string;
}

/**
 * Key Performance Indicator is a type of performance measurement. It monitors a business indicator
 * and its success/failure against a given target. KPIs are the first item read on a dashboard.
 * Communicates simple, immediate and vital information for operational decision making.
 */
export declare const HvKpi: (props: HvKpiProps) => JSX_2.Element;

export declare type HvKpiClasses = ExtractNames<typeof useClasses_38>;

export declare interface HvKpiLabelProps {
    /**
     * The text at the top of the kpi.
     */
    title?: string;
    /**
     * The text in the middle of the kpi.
     */
    indicator?: string;
    /**
     * The text to the right of the indicator.
     */
    unit?: string;
    /**
     * The text to the right of the visual comparison.
     */
    comparisonIndicatorInfo?: string;
}

export declare interface HvKpiProps extends HvBaseProps<HTMLDivElement, "children"> {
    /**
     * An Element that will be rendered to the left of the kpi indicator text.
     */
    trendIndicator?: React.ReactNode;
    /**
     * An Element that will be rendered to the left of the kpi indicator text.
     */
    visualIndicator?: React.ReactNode;
    /**
     * An Element that will be rendered below the kpi indicator text.
     */
    visualComparison?: React.ReactNode;
    /**
     * The object that contains the different labels inside the kpi.
     */
    labels?: HvKpiLabelProps;
    /**
     *  The typography variant used in the main text indicator of the KPI
     */
    indicatorTextVariant?: "display" | "title1" | "title2";
    /**
     *  The typography variant used in the main text indicator of the KPI
     */
    indicatorUnitTextVariant?: "title2" | "body";
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvKpiClasses;
}

/**
 * Provides the user with a recognizable name for a given form element.
 */
export declare const HvLabel: (props: HvLabelProps) => JSX_2.Element;

export declare type HvLabelClasses = ExtractNames<typeof useClasses_8>;

export declare interface HvLabelProps extends HvTypographyProps<"label"> {
    /** Id to be applied to the root node */
    id?: string;
    /** The text to be shown by the label. */
    label?: React.ReactNode;
    /** The id of the form element the label is bound to. */
    htmlFor?: string;
    /** If `true` the label is displayed with a disabled style. */
    disabled?: boolean;
    /** If `true`, the label will indicate that the form element is required (an `*` after the label text). */
    required?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLabelClasses;
}

export declare const HvLeftControl: ({ id, classes: classesProp, className, children, placeholder, onSearch, hideSearch, searchProps, ...others }: HvLeftControlProps) => JSX_2.Element;

export declare type HvLeftControlClasses = ExtractNames<typeof useClasses_91>;

export declare interface HvLeftControlProps extends HvBaseProps {
    /** if `true` the hide sort by dropdown is not rendered */
    hideSearch?: boolean;
    /** placeholder of the input */
    placeholder?: string;
    /** Callback called when a search action occurs */
    onSearch?: (event: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>, value: string) => void;
    /** Extra props passed to input */
    searchProps?: HvInputProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLeftControlClasses;
}

export declare const HvLink: (props: HvLinkProps) => JSX_2.Element;

export declare type HvLinkClasses = ExtractNames<typeof useClasses_39>;

export declare interface HvLinkProps extends HvBaseProps<HTMLAnchorElement, "onClick"> {
    onClick?: (event: MouseEventHandler<HTMLAnchorElement>, data: any) => void | undefined;
    route?: string;
    data?: any;
    children: any;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLinkClasses;
}

/**
 * Component used to show a set of related data to the user.
 */
export declare const HvList: (props: HvListProps) => JSX_2.Element | null;

export declare type HvListClasses = ExtractNames<typeof useClasses_63>;

/**
 * A <b>list</b> is any enumeration of a set of items.
 * The simple list is for continuous <b>vertical indexes of text or icons+text</b>. The content of these lists must be simple: ideally simples fields.
 * This pattern is ideal for <b>selections</b>. It should be used inside a HvPanel.
 */
export declare const HvListContainer: React_2.ForwardRefExoticComponent<HvListContainerProps & React_2.RefAttributes<unknown>>;

export declare type HvListContainerClasses = ExtractNames<typeof useClasses_3>;

export declare interface HvListContainerProps extends HvBaseProps<HTMLUListElement> {
    /**
     * If the list items should be focusable and react to mouse over events.
     * Defaults to true if the list is selectable, false otherwise.
     */
    interactive?: boolean;
    /** If `true` compact the vertical spacing between list items. */
    condensed?: boolean;
    /** If `true`, the list items' left and right padding is removed. */
    disableGutters?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvListContainerClasses;
}

/**
 * ListItem description/documentation paragraph
 */
export declare const HvListItem: (props: HvListItemProps) => JSX_2.Element;

export declare type HvListItemClasses = ExtractNames<typeof useClasses_4>;

export declare interface HvListItemProps extends HvBaseProps<HTMLLIElement> {
    /**
     * Overrides the implicit list item role.
     */
    role?: string;
    /** Indicates if the list item is selected. */
    selected?: boolean;
    /** If true, the list item will be disabled. */
    disabled?: boolean;
    /**
     * If the list item is focusable and reacts to mouse over events.
     * Defaults to true if the container list is interactive, false otherwise.
     */
    interactive?: boolean;
    /**
     * If `true` compacts the vertical spacing intended to separate the list items.
     * Defaults to the value set in container list.
     */
    condensed?: boolean;
    /**
     * If `true`, the left and right padding is removed.
     * Defaults to the value set in container list.
     */
    disableGutters?: boolean;
    /**
     * Element placed before the children.
     * Also removes the left padding (gutter).
     *
     * Some modifications are applied, assuming that it is either an icon (changing the color when the item is disabled)
     * or a selector (preventing the double focus ring, propagating the checked and disabled states and wiring the onChange event).
     * If unwanted, the element should be placed directly as a child.
     */
    startAdornment?: React_2.ReactNode;
    /**
     * Element placed after the children and aligned next to the margin.
     * Also removes the right padding (gutter).
     *
     * Some modifications are applied, assuming that it is an icon (changing the color when the item is disabled).
     * If unwanted, the element should be placed directly as a child.
     */
    endAdornment?: React_2.ReactNode;
    /** The value to be set on the 'li' element */
    value?: any;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvListItemClasses;
}

export declare interface HvListLabels {
    /** The label used for the All checkbox action. */
    selectAll?: string;
    /** The label used in the middle of the multi-selection count. */
    selectionConjunction?: string;
}

export declare interface HvListProps extends HvBaseProps<HTMLUListElement, "onChange" | "onClick"> {
    /**
     * A list containing the elements to be rendered.
     *
     * - id: The id of the item.
     * - label: The label of the element to be rendered.
     * - selected: The selection state of the element.
     * - disabled: The disabled state of the element.
     * - isHidden: Is item visible.
     * - icon: The icon.
     * - showNavIcon: If true renders the navigation icon on the right.
     * - path: The path to navigate to.
     */
    values: HvListValue[];
    /** If true renders a multi select list. */
    multiSelect?: boolean;
    /**
     * If true renders select all option for multi selection lists with selectors.
     * note: It will only be rendered if multiSelect and useSelector props are set to true.
     */
    showSelectAll?: boolean;
    /** An object containing all the labels for the dropdown. */
    labels?: HvListLabels;
    /** If true renders list items with radio or checkbox selectors. */
    useSelector?: boolean;
    /** Call back fired when list item is selected. Returns selection state. */
    onChange?: (value: HvListValue[]) => void;
    /** Call back fired when list item is selected. Returns selected item. */
    onClick?: (event: React.ChangeEvent<HTMLLIElement>, value: HvListValue) => void;
    /** If `true` the list items will show the selection state. */
    selectable?: boolean;
    /** If `true`, selection can be toggled when single selection. */
    singleSelectionToggle?: boolean;
    /** If `true` the list will be rendered without vertical spacing. */
    condensed?: boolean;
    /** If `true` the dropdown will show tooltips when user mouseenter text in list */
    hasTooltips?: boolean;
    /** Experimental. Height of the dropdown, in case you want to control it from a prop. Styles can also be used through dropdownListContainer class. Required in case virtualized is used */
    height?: number;
    /** Experimental. Uses dropdown in a virtualized form, where not all options are rendered initially. Good for use cases with a lot of options. */
    virtualized?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvListClasses;
}

export declare interface HvListValue extends HvExtraProps {
    id?: string | number;
    label: React.ReactNode;
    searchValue?: string;
    selected?: boolean;
    disabled?: boolean;
    isHidden?: boolean;
    icon?: React.ReactNode | ((params: {
        isDisabled?: boolean;
        isSelected?: boolean;
    }) => React.ReactNode);
    showNavIcon?: boolean;
    path?: string;
    params?: object;
    tabIndex?: number;
}

/**
 * Loading provides feedback about a process that is taking place in the application.
 */
export declare const HvLoading: (props: HvLoadingProps) => JSX_2.Element;

export declare type HvLoadingClasses = ExtractNames<typeof useClasses_40>;

export declare interface HvLoadingProps extends HvBaseProps {
    /** Indicates if the component should be render in a small size. */
    small?: boolean;
    /** The label to be displayed.  */
    label?: string | React.ReactNode;
    /** Whether the loading animation is hidden. */
    hidden?: boolean;
    /** Color applied to the bars. */
    color?: HvColorAny;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvLoadingClasses;
}

/**
 * Container layout for the login form.
 */
export declare const HvLogin: (props: HvLoginProps) => JSX_2.Element;

export declare type HvLoginClasses = ExtractNames<typeof useClasses_89>;

export declare interface HvLoginProps extends HvBaseProps {
    /**
     *  The path for the background image.
     */
    background?: string;
    /**
     * Class names to be applied.
     */
    classes?: HvLoginClasses;
}

export declare interface HvMarkProperty {
    position?: number;
    label?: string;
}

export declare type HvMeta<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, Extension = never, M = HvMetaBase<D, H>> = [Extension] extends [never] ? M : M & Extension;

declare interface HvMetaBase<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> {
    instance: HvTableInstance<D, H>;
    userProps: any;
}

export declare const HvMultiButton: (props: HvMultiButtonProps) => JSX_2.Element;

export declare type HvMultiButtonClasses = ExtractNames<typeof useClasses_41>;

export declare interface HvMultiButtonProps extends HvBaseProps {
    /** If all the buttons are disabled. */
    disabled?: boolean;
    /** If the MultiButton is to be displayed vertically. */
    vertical?: boolean;
    /** Category of button to use */
    variant?: HvButtonVariant;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvMultiButtonClasses;
}

export declare const hvNodeFallback: (value: any) => any;

export declare interface HvNotistackSnackMessageProps extends OptionsObject {
    /** Id to be applied to the root node. */
    id?: string;
    /** Classname to apply on the root node */
    className?: string;
    /** Your component tree. */
    message?: ReactNode;
    /** Variant of the snackbar. */
    variant?: HvSnackbarVariant;
    /** Extra values to pass to the snackbar. */
    snackbarContentProps?: HvSnackbarContentProps;
}

export declare function hvNumberColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>): HvTableColumnConfig<D, H>;

export declare const hvNumberFallback: (value: any) => number | "—";

/**
 * This component generates a tooltip whenever the text is overflowed.
 */
export declare const HvOverflowTooltip: (props: HvOverflowTooltipProps) => JSX_2.Element;

export declare type HvOverflowTooltipClasses = ExtractNames<typeof useClasses_50>;

export declare interface HvOverflowTooltipProps extends HvBaseProps {
    /** The node that will be rendered inside the tooltip. */
    data: React.ReactNode;
    /** If true, the tooltip is shown. */
    open?: boolean;
    /** If `true` the overflow tooltip will always use the paragraph overflow style. */
    paragraphOverflow?: boolean;
    /** Tooltip placement. */
    placement?: "bottom-end" | "bottom-start" | "bottom" | "left-end" | "left-start" | "left" | "right-end" | "right-start" | "right" | "top-end" | "top-start" | "top";
    /** Extra properties to add to the tooltip. */
    tooltipsProps?: Partial<HvTooltipProps>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvOverflowTooltipClasses;
}

/**
 * Pagination is the process of dividing a document into discrete pages. It relates to how users interact
 * with structured content on a website or application.
 */
export declare const HvPagination: (props: HvPaginationProps) => JSX_2.Element;

export declare type HvPaginationClasses = ExtractNames<typeof useClasses_68>;

export declare interface HvPaginationLabels {
    /** The show label. */
    pageSizePrev?: string;
    /** Indicate the units of the page size selection. */
    pageSizeEntryName?: string;
    /** Used for the aria-label of the selection of number of unit.s */
    pageSizeSelectorDescription?: string;
    /** Separator of current page and total pages. */
    pagesSeparator?: string;
    /** Title of button `firstPage`. */
    paginationFirstPageTitle?: string;
    /** Title of button `previousPage`. */
    paginationPreviousPageTitle?: string;
    /** Title of button `nextPage`. */
    paginationNextPageTitle?: string;
    /** Title of button `lastPage`. */
    paginationLastPageTitle?: string;
    /** Aria-label passed to the page input. */
    paginationInputLabel?: string;
    /** Aria-label of the first page button */
    firstPage?: string;
    /** Aria-label of the previous page button */
    previousPage?: string;
    /** Aria-label of the next page button */
    nextPage?: string;
    /** Aria-label of the last page button */
    lastPage?: string;
}

export declare type HvPaginationPropGetter<D extends object> = PropGetter<D, HvTablePaginationProps>;

export declare interface HvPaginationProps extends HvBaseProps {
    /** The number of pages the component has. */
    pages?: number;
    /** The currently selected page (0-indexed). */
    page?: number;
    /** Controls whether the left page size mechanism should be visible. */
    showPageSizeOptions?: boolean;
    /** The array of possible page sizes for the dropdown. */
    pageSizeOptions?: number[];
    /** The currently selected page size. */
    pageSize?: number;
    /** Controls whether the central page changing mechanism should be visible. */
    showPageJump?: boolean;
    /** Controls whether the previous/first page buttons are enabled. */
    canPrevious?: boolean;
    /** Controls whether the next/last page buttons are enabled. */
    canNext?: boolean;
    /** Function called when the page changes. */
    onPageChange?: (page: number) => void;
    /** Function called when the page size changes. */
    onPageSizeChange?: (pageSize: number) => void;
    /** An object containing all the labels for the component. */
    labels?: HvPaginationLabels;
    /** Other props to show page component. */
    showPageProps?: HTMLAttributes<HTMLDivElement>;
    /** Other props to pagination component. */
    navigationProps?: HTMLAttributes<HTMLDivElement>;
    /** Extra properties passed to the input component representing the current pages. */
    currentPageInputProps?: HvInputProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvPaginationClasses;
}

/**
 * A panel is a container used in a variety of patterns (e.g. dropdown, filter group, details section).
 * It can be horizontal or vertical and its size is defined by its content and how it relates to surrounding patterns.
 * Regardless of its content, a panel look and feel should be consistent.
 */
export declare const HvPanel: (props: HvPanelProps) => JSX_2.Element;

export declare type HvPanelClasses = ExtractNames<typeof useClasses_42>;

export declare interface HvPanelProps extends HvBaseProps {
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvPanelClasses;
}

export declare type HvPolarizedColorKeys = "positive" | "positive_120" | "positive_80" | "warning" | "warning_120" | "warning_140" | "negative" | "cat21" | "cat22" | "cat23" | "cat24" | "cat25" | "cat26" | "cat27" | "cat28" | "catastrophic";

export declare const HvProgressBar: (props: HvProgressBarProps) => JSX_2.Element;

export declare type HvProgressBarClasses = ExtractNames<typeof useClasses_43>;

/**
 * ProgressBar provides feedback about a process that is taking place in the application.
 */
export declare interface HvProgressBarProps extends HvBaseProps {
    /** The value of the progress bar. */
    value: number;
    /**
     * The status of the progress bar.
     *
     * inProgress is black, error is red and completed is green.
     *
     * When uncontrolled and unspecified it will default to "inProgress".
     */
    status?: HvProgressBarStatus;
    /** Aria Properties passed on to the progress bar. */
    labelProps?: HvTypographyProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvProgressBarClasses;
    /**
     * True if the text label should not be displayed.
     */
    hideLabel?: boolean;
}

export declare type HvProgressBarStatus = "inProgress" | "completed" | "error";

export declare function hvProgressColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, getPartial?: (row: HvRowInstance<D, H>) => number, getTotal?: (row: HvRowInstance<D, H>) => number, color?: "primary" | "secondary"): HvTableColumnConfig<D, H>;

export declare const HvProgressColumnCell: ({ partial, total, color, "aria-labelledby": ariaLabelledBy, }: HvProgressColumnCellProp) => JSX.Element;

export declare interface HvProgressColumnCellProp {
    /** Current value of the bar. */
    partial: number;
    /** Maximum value of the bar. */
    total: number;
    /** The color of the bar. */
    color?: "primary" | "secondary";
    "aria-labelledby"?: string;
}

export declare type HvPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, Props extends object = Record<string, unknown>, T extends object = never, P = Partial<Props>> = ((props: P, meta: HvMeta<D, H, T>) => P | P[]) | P | P[];

/**
 * Enables theming capabilities and makes cross-component theme properties available down the tree.
 */
export declare const HvProvider: ({ children, rootElementId, cssBaseline, cssTheme, themes, theme, colorMode, classNameKey, }: HvProviderProps) => JSX_2.Element;

export declare interface HvProviderProps {
    /**
     * Your component tree.
     */
    children?: React_2.ReactNode;
    /**
     * Id of your root element.
     */
    rootElementId?: string;
    /**
     * By default the baseline styles are applied globally, `global`, to the application for the UI Kit components to work properly.
     * If you need to scope the baseline styles to avoid styling conflicts, you can set this property to `scoped`.
     * To scope the baseline to your root, you need to add the `rootElementId` property.
     * If the `rootElementId` property is not set, the baseline will be scoped to a new container, `hv-uikit-scoped-root*`, created around your content.
     * If you are providing your own baseline styles, you can set this property to `none` to disable the baseline styles.
     */
    cssBaseline?: "global" | "scoped" | "none";
    /**
     * By default the theme styles are applied globally, `global`, to the application.
     * If you need to scope the theme styles to avoid styling conflicts, you can set this property to `scoped`.
     * To scope the theme to your root, you need to add the `rootElementId` property.
     * If the `rootElementId` property is not set, the theme will be scoped to a new container, `hv-uikit-scoped-root*`, created around your content.
     */
    cssTheme?: "global" | "scoped";
    /**
     * The string used to prefix the class names and uniquely identify them. The key can only contain lower case alphabetical characters.
     * This is useful to avoid class name collisions.
     *
     * If no value is provided, the default is `hv`.
     */
    classNameKey?: string;
    /**
     * List of themes to be used by UI Kit.
     * You can provide your own themes created with the `createTheme` utility and/or the default themes `ds3` and `ds5` provided by UI Kit.
     *
     * If no value is provided, the `ds5` theme will be used.
     */
    themes?: (HvTheme | HvThemeStructure)[];
    /**
     * The active theme. It must be one of the themes passed to `themes`.
     *
     * If no value is provided, the first theme from the `themes` list is used. If no `themes` list is provided, the `ds5` theme will be used.
     */
    theme?: string;
    /**
     * The active color mode. It must be one of the color modes of the active theme.
     *
     * If no value is provided, the first color mode defined in the active theme is used.
     * For the default themes `ds3` and `ds5`, the `dawn` color mode is the one used.
     */
    colorMode?: string;
}

/**
 * **HvQueryBuilder** component allows you to create conditions and group them using logical operators.
 * It outputs a structured set of rules which can be easily parsed to create SQL/NoSQL/whatever queries.
 */
export declare const HvQueryBuilder: (props: HvQueryBuilderProps) => JSX_2.Element;

export declare type HvQueryBuilderClasses = ExtractNames<typeof useClasses_113>;

export declare interface HvQueryBuilderProps {
    attributes?: Record<string, Attribute>;
    /**
     * The query rules operators by attribute type and combinator.
     */
    operators?: Record<string, QueryOperator[]>;
    /**
     * The query combinators operands.
     */
    combinators?: QueryCombinator[];
    /**
     * The initial query representation.
     */
    query?: Query;
    /**
     * Callback fired when query changes.
     * @param {Query} value - the query representation.
     */
    onChange?: (value: Query) => void;
    /**
     * Max depth of nested query groups.
     */
    maxDepth?: number;
    /**
     * An object containing all the labels.
     */
    labels?: QueryBuilderLabels;
    /**
     * A flag indicating if the Query Builder is in read only mode.
     */
    readOnly?: boolean;
    /**
     * Override or extend the styles applied to the component.
     * See CSS API tab for more details.
     */
    classes?: HvQueryBuilderClasses;
}

/**
 * A Radio Button is a mechanism that allows user to select just an option from a group of options.
 *
 * It should used in a Radio Button Group to present the user with a range of options from
 * which the user <b>may select just one option</b> to complete their task.
 *
 * Individual use of radio buttons, at least uncontrolled, is unadvised as React state management doesn't
 * respond to the browser's native management of radio inputs checked state.
 */
export declare const HvRadio: (props: HvRadioProps) => JSX_2.Element;

export declare type HvRadioClasses = ExtractNames<typeof useClasses_59>;

/**
 * A group of radio buttons.
 *
 * A radio group is a type of selection list that can only have a single entry checked at any one time.
 */
export declare const HvRadioGroup: (props: HvRadioGroupProps) => JSX_2.Element;

export declare type HvRadioGroupClasses = ExtractNames<typeof useClasses_64>;

export declare interface HvRadioGroupProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * The form element name.
     *
     * It is propagated to the children radio buttons, unless they already have one (which they shouldn't).
     */
    name?: string;
    /**
     * The value of the form element, represented in one of the child radio buttons values.
     *
     * When defined the radio button group state becomes controlled.
     */
    value?: any;
    /**
     * When uncontrolled, defines the initial value.
     */
    defaultValue?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
    /**
     * Indicates that the form element is disabled.
     * If `true` the state is propagated to the children radio buttons.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is not editable.
     * If `true` the state is propagated to the children radio buttons.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     * If `true` the state is propagated to the children radio buttons' input element.
     */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: React.ReactNode;
    /**
     * The callback fired when the value changes.
     */
    onChange?: (event: React.ChangeEvent<HTMLInputElement>, value: any) => void;
    /**
     * Indicates whether the radio buttons group's orientation is horizontal or vertical.
     *
     * Defaults to vertical.
     */
    orientation?: "vertical" | "horizontal";
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvRadioGroupClasses;
}

export declare interface HvRadioProps extends Omit<RadioProps_2, "onChange" | "classes">, HvBaseProps<HTMLButtonElement, "onChange" | "color"> {
    /**
     * A Jss Object used to override or extend the styles applied to the radio button.
     */
    classes?: HvRadioClasses;
    /**
     * The form element name.
     */
    name?: string;
    /**
     * The value of the form element.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided.
     */
    label?: React_2.ReactNode;
    /**
     * Properties passed on to the label element.
     */
    labelProps?: HvLabelProps;
    /**
     * Indicates that user input is required on the form element.
     *
     * If a single radio button in a group has the required attribute, a radio button in
     * that group must be check, though it doesn't have to be the one with the attribute is applied.
     *
     * For that reason, the component doesn't make any uncontrolled changes to its validation status.
     * That should ideally be managed in the context of a radio button group.
     */
    required?: boolean;
    /**
     * Indicates that the form element is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that the form element is disabled.
     */
    disabled?: boolean;
    /**
     * If `true` the radio button is selected, if set to `false` the radio button is not selected.
     *
     * When defined the radio button state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     */
    status?: HvRadioStatus;
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: string;
    /**
     * Identifies the element that provides an error message for the radio button.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the radio button is pressed.
     */
    onChange?: (event: React_2.ChangeEvent<HTMLInputElement>, checked: boolean, value: any) => void;
    /**
     * Whether the selector should use semantic colors.
     */
    semantic?: boolean;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React_2.InputHTMLAttributes<HTMLInputElement>;
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible?: (event: React_2.FocusEvent<any>) => void;
    /** @ignore */
    ref?: RadioProps_2["ref"];
    /** @ignore */
    component?: RadioProps_2["component"];
}

export declare type HvRadioStatus = "standBy" | "valid" | "invalid";

export declare const HvRightControl: ({ id, classes: classesProp, className, children, values, onSort, hideSortBy, sortProps, ...others }: HvRightControlProps) => JSX_2.Element;

export declare type HvRightControlClasses = ExtractNames<typeof useClasses_92>;

export declare interface HvRightControlProps extends HvBaseProps {
    /** if `true` the hide sort by dropdown is not rendered */
    hideSortBy?: boolean;
    /** options for the dropdown to sort */
    values?: HvRightListControls[];
    /** Callback called when a sort action occurs */
    onSort?: (selected: HvRightListControls | undefined) => void;
    /** Extra props passed to dropdown */
    sortProps?: HvDropdownProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvRightControlClasses;
}

export declare interface HvRightListControls extends HvListValue {
    accessor: string;
    desc: boolean;
}

export declare interface HvRowInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<Row<D>, "cells" | "allCells" | "subRows" | "getRowProps">, Partial<Omit<UseGroupByRowProps<D>, "subRows" | "values">>, Partial<UseRowStateRowProps<D>>, Partial<Omit<UseHvRowExpandRowInstance<D>, "subRows">>, Partial<UseHvRowSelectionRowInstance> {
    cells: Array<HvCellInstance<D, H>>;
    allCells: Array<HvCellInstance<D, H>>;
    getRowProps: (propGetter?: HvRowPropGetter<D, H>) => HvUseTableRowProps;
    index: number;
    original: D;
    id: string;
    subRows: Array<HvRowInstance<D, H>>;
}

declare type HvRowPropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableRowProps, {
    row: HvRowInstance<D, H>;
}>;

/**
 * The horizontal scroll to element can be used to quickly navigate in a page.
 */
export declare const HvScrollToHorizontal: (props: HvScrollToHorizontalProps) => JSX_2.Element;

export declare type HvScrollToHorizontalClasses = ExtractNames<typeof useClasses_110>;

export declare interface HvScrollToHorizontalOption {
    key?: string;
    label: string;
    value: string;
    offset?: number;
}

export declare type HvScrollToHorizontalPositions = "sticky" | "fixed" | "relative";

export declare interface HvScrollToHorizontalProps extends HvBaseProps<HTMLOListElement, "onChange" | "onClick"> {
    /** An Array of Objects with Label and Value. Label is the displayed Element and Value is the local navigation location applied */
    options: HvScrollToHorizontalOption[];
    /** True if the href location link should be applied. It will create an a element around every list item */
    href?: boolean;
    /** Default selected index passed from the parent. */
    defaultSelectedIndex?: number;
    /**
     * The Id of the scrollable container containing displayed elements.
     *
     * Defaults to `window` if unspecified.
     */
    scrollElementId?: string;
    /**
     * Defines the offset from the top of each element for getting an optimal viewing region in the container.
     * This allows to exclude regions of the container that are obscured by other content (such as fixed-positioned toolbars or titles)
     * or to put more breathing room between the targeted element and the edges of the container.
     *
     * Each element can also have a specific offset via the options property.
     */
    offset?: number;
    /** Position of the Horizontal scroll to. */
    position?: HvScrollToHorizontalPositions;
    /** Position of tooltip identifying the current item. */
    tooltipPosition?: HvScrollToTooltipPositions;
    /** A function called each time the selected index changes. */
    onChange?: (event: Event | React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>, index: number) => void;
    /** A function called each time an user clicks on a tab element. */
    onClick?: (event: React.MouseEvent<HTMLDivElement>, index: number) => void;
    /** A function called each time an user press enter on a tab element. */
    onEnter?: (event: React.KeyboardEvent<HTMLDivElement>, index: number) => void;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvScrollToHorizontalClasses;
}

export declare type HvScrollToTooltipPositions = "left" | "right" | "top" | "bottom";

/**
 * The vertical scroll to element can be used to quickly navigate in a page.
 */
export declare const HvScrollToVertical: (props: HvScrollToVerticalProps) => JSX_2.Element;

export declare type HvScrollToVerticalClasses = ExtractNames<typeof useClasses_108>;

export declare interface HvScrollToVerticalOption {
    key?: string;
    label: string;
    value: string;
    offset?: number;
}

export declare type HvScrollToVerticalPositions = "absolute" | "fixed" | "relative";

export declare interface HvScrollToVerticalProps extends HvBaseProps<HTMLOListElement, "onChange" | "onClick"> {
    /** An Array of Objects with Label and Value. Label is the displayed Element and Value is the local navigation location applied */
    options: HvScrollToVerticalOption[];
    /** True if the href location link should be applied. It will create an a element around every list item */
    href?: boolean;
    /** Default selected index passed from the parent. */
    defaultSelectedIndex?: number;
    /**
     * The Id of the scrollable container containing displayed elements.
     *
     * Defaults to `window` if unspecified.
     */
    scrollElementId?: string;
    /**
     * Defines the offset from the top of each element for getting an optimal viewing region in the container.
     * This allows to exclude regions of the container that are obscured by other content (such as fixed-positioned toolbars or titles)
     * or to put more breathing room between the targeted element and the edges of the container.
     *
     * Each element can also have a specific offset via the options property.
     */
    offset?: number;
    /** Position of the Vertical scroll to. */
    position?: HvScrollToVerticalPositions;
    /** Position of tooltip identifying the current item. */
    tooltipPosition?: HvScrollToTooltipPositions;
    /** A function called each time the selected index changes. */
    onChange?: (event: Event | React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>, index: number) => void;
    /** A function called each time an user clicks on a tab element. */
    onClick?: (event: React.MouseEvent<HTMLDivElement>, index: number) => void;
    /** A function called each time an user press enter on a tab element. */
    onEnter?: (event: React.KeyboardEvent<HTMLDivElement>, index: number) => void;
    /** A Jss Object used to override or extend the styles applied. */
    classes?: HvScrollToVerticalClasses;
}

/**
 * Allows the user to select one or more items from a list of choices.
 *
 * Although it supports multi-selection, DS recommends the use of a selection list
 * when it’s clear that the user can only select just one option from the range provided.
 */
export declare const HvSelectionList: (props: HvSelectionListProps) => JSX_2.Element;

export declare type HvSelectionListClasses = ExtractNames<typeof useClasses_11>;

export declare interface HvSelectionListProps extends HvBaseProps<HTMLUListElement, "onChange"> {
    /** The form element name. */
    name?: string;
    /**
     * The value of the form element. It must be represented in the child list items.
     *
     * Can either be a single value (when multiple = false) or an
     * array of values (when multiple = true).
     *
     * When defined the selection list state becomes controlled.
     */
    value?: any | any[];
    /** When uncontrolled, defines the initial value. */
    defaultValue?: any | any[];
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React_2.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React_2.ReactNode;
    /** Indicates that the form element is disabled. If `true` the state is propagated to the children list items. */
    disabled?: boolean;
    /** Indicates that the form element is not editable. */
    readOnly?: boolean;
    /** Indicates that user input is required on the form element. */
    required?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: string;
    /** Indicates that the user may select more than one item from the current selectable list items. */
    multiple?: boolean;
    /** If `true`, selection can be toggled when single selection. */
    singleSelectionToggle?: boolean;
    /** Indicates whether the list orientation is horizontal or vertical. Defaults to vertical. */
    orientation?: "vertical" | "horizontal";
    /** The callback fired when the value changes. */
    onChange?: (event: React_2.MouseEvent, value: any) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSelectionListClasses;
}

export { HvSemanticColor }

export declare type HvSemanticColorKeys = HvSemanticColor;

export declare type HvSemanticColors = Record<HvSemanticColorKeys, string>;

export declare type HvSequentialColorKeys = "cat1" | "cat1_100" | "cat1_200" | "cat1_300" | "cat1_400" | "cat1_500" | "cat1_600" | "cat1_700" | "cat1_800" | "cat1_900";

export declare const HvSimpleGrid: (props: HvSimpleGridProps) => JSX_2.Element;

export declare type HvSimpleGridClasses = ExtractNames<typeof useClasses_44>;

/** Grid component that enables you to create columns of equal width and define your own breakpoints and responsive behavior. */
export declare interface HvSimpleGridProps extends HvBaseProps {
    /**
     * Spacing with pre-defined values according the values defined in the theme
     */
    spacing?: Spacing;
    /**
     * Provide an array to define responsive behavior:
     *
     *    maxWidth or minWidth: max-width or min-width at which media query will work
     *
     *    cols: number of columns per row at given max-width
     *
     *    spacing: optional spacing at given max-width, if not provided spacing from component prop will be used instead
     */
    breakpoints?: Breakpoint[];
    /**
     * Number of how many columns the content will be displayed
     */
    cols?: number;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSimpleGridClasses;
}

export { HvSize }

/**
 * Sliders reflect a range of values along a bar, from which users may select a single value. They are ideal for adjusting settings such as volume, brightness, or applying image filters.
 */
export declare const HvSlider: (props: HvSliderProps) => JSX_2.Element;

export declare type HvSliderClasses = ExtractNames<typeof useClasses_103>;

export declare interface HvSliderProps extends HvBaseProps<HTMLDivElement, "onChange" | "onBlur"> {
    /**
     * The slider name.
     */
    name?: string;
    /**
     * The label of the slider.
     *
     * If not provided, an aria-label or aria-labelledby must be inputted via sliderProps.
     */
    label?: React_2.ReactNode;
    /**
     * Indicates that the slider is disabled.
     */
    disabled?: boolean;
    /**
     * Indicates that the slider is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that user slider is required on the form element.
     */
    required?: boolean;
    /**
     * What message to render when the value is required.
     */
    requiredMessage?: string;
    /**
     * If `true` the input that controls the slider is hidden.
     */
    hideInput?: boolean;
    /**
     * Attributes applied to the slider element.
     */
    sliderProps?: SliderProps;
    /**
     * The status of the slider element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus | HvFormStatus[];
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: React_2.ReactNode;
    /**
     * The values array to apply to the component
     */
    values?: number[];
    /**
     * The default values array to apply to the component
     */
    defaultValues?: (number | undefined)[];
    /**
     * The object used to set the knob properties,
     * for every item in the array a new knob will be created.
     */
    knobProperties?: HvKnobProperty[];
    /**
     * The object used to set the mark properties individually.
     */
    markProperties?: HvMarkProperty[];
    /**
     * The function executed before a change will occur in the slider.
     */
    onBeforeChange?: (value: number[]) => void;
    /**
     * The function executed while a change is occurring in the slider.
     */
    onChange?: (value: number[]) => void;
    /**
     * The function executed after a change ocurred in the slider.
     */
    onAfterChange?: (value: number[]) => void;
    /**
     * The function executed after a blur ocurred in the slider.
     */
    onBlur?: (event: React_2.FocusEvent, knobsValues: number[], status?: HvFormStatus | HvFormStatus[]) => void;
    /**
     * The separation in points between marks.
     * example: if 10 divisions and a markstep of 2 there will be 5 marks.
     */
    markStep?: number;
    /**
     * How many subdivisions there are in the slider.
     */
    divisionQuantity?: number;
    /**
     * The value of the first point in the slider from left to right.
     */
    minPointValue?: number;
    /**
     * The value of the last point in the slider from left to right.
     */
    maxPointValue?: number;
    /**
     * The nax number of decimals if no format function is applied
     */
    markDigits?: number;
    /**
     * A formatting function used to add format to the marks in the track,
     * the function receives the mark text
     */
    formatMark?: (label: React_2.ReactNode) => React_2.ReactNode;
    /**
     * A formatting function used to add format to the tooltip in the track,
     * the function receives the mark text
     */
    formatTooltip?: (label: React_2.ReactNode) => React_2.ReactNode;
    /**
     * If `true` the knobs can't have the same value, if `false` knobs can have the same value.
     */
    noOverlap?: boolean;
    /**
     * Attributes applied to the input element.
     */
    inputProps?: HvInputProps[];
    /**
     * Attributes applied to the knob element.
     */
    knobProps?: React_2.HTMLAttributes<HTMLDivElement>[];
    /**
     * The classes object to be applied into the root object.
     */
    classes?: HvSliderClasses;
}

/**
 * A Snackbar provides brief messages about app processes.
 * It is dismissed automatically after a given interval.
 *
 * Snackbar can be built with two different components.
 * One is the HvSnackbar, which wraps all the positioning, transition, auto hide, etc.
 * The other is the HvSnackbarContent, which allows a finer control and customization of the content of the Snackbar.
 */
export declare const HvSnackbar: ({ classes: classesProp, className, id, open, onClose, label, anchorOrigin, autoHideDuration, variant, showIcon, customIcon, action, actionCallback, transitionDuration, transitionDirection, offset, snackbarContentProps, ...others }: HvSnackbarProps) => JSX_2.Element;

export declare type HvSnackbarClasses = ExtractNames<typeof useClasses_75>;

export declare const HvSnackbarContent: ForwardRefExoticComponent<Omit<HvSnackbarContentProps, "ref"> & RefAttributes<HTMLDivElement>>;

export declare type HvSnackbarContentClasses = ExtractNames<typeof useClasses_76>;

export declare interface HvSnackbarContentProps extends Omit<SnackbarContentProps, "variant" | "action" | "classes">, HvBaseProps {
    /** The message to display. */
    label?: React.ReactNode;
    /** Variant of the snackbar. */
    variant?: HvSnackbarVariant;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Action to display. */
    action?: React.ReactNode | HvActionGeneric;
    /** The callback function ran when an action is triggered, receiving `action` as param */
    actionCallback?: (event: React.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSnackbarContentClasses;
}

export declare interface HvSnackbarProps extends Omit<SnackbarProps, "action" | "classes">, Omit<HvBaseProps, "children"> {
    /** If true, Snackbar is open. */
    open?: boolean;
    /** Callback fired when the component requests to be closed. Typically onClose is used to set state in the parent component, which is used to control the Snackbar open prop. The reason parameter can optionally be used to control the response to onClose, for example ignoring clickaway. */
    onClose?: ((event: Event | SyntheticEvent<any, Event>, reason: SnackbarCloseReason) => void) | undefined;
    /** The message to display. */
    label?: React.ReactNode;
    /** The anchor of the Snackbar. vertical: "top", "bottom" | horizontal: "left","center","right. It defines where the snackbar will end his animation */
    anchorOrigin?: SnackbarOrigin;
    /** The number of milliseconds to wait before automatically calling the onClose function. onClose should then set the state of the open prop to hide the Snackbar */
    autoHideDuration?: number;
    /** Variant of the snackbar. */
    variant?: HvSnackbarVariant;
    /** Custom icon to replace the variant default. */
    customIcon?: React.ReactNode;
    /** Controls if the associated icon to the variant should be shown. */
    showIcon?: boolean;
    /** Action to display. */
    action?: React.ReactNode | HvActionGeneric;
    /** The callback function ran when an action is triggered, receiving `action` as param */
    actionCallback?: (event: React.SyntheticEvent, id: string, action: HvActionGeneric) => void;
    /** Duration of transition in milliseconds. */
    transitionDuration?: number;
    /** Direction of slide transition. */
    transitionDirection?: "up" | "down" | "left" | "right";
    /** Custom offset from top/bottom of the page, in px. */
    offset?: number;
    /** Others applied to the content of the snackbar. */
    snackbarContentProps?: HvSnackbarContentProps;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSnackbarClasses;
    /** @ignore */
    ref?: SnackbarProps["ref"];
}

export declare const HvSnackbarProvider: ({ children, notistackClassesOverride, maxSnack, autoHideDuration, anchorOrigin, classes: classesProp, className, ...others }: HvSnackbarProviderProps) => JSX_2.Element;

export declare type HvSnackbarProviderClasses = ExtractNames<typeof useClasses_77>;

export declare interface HvSnackbarProviderProps {
    /** Your component tree. */
    children: React.ReactNode;
    /** Max visible snackbars. */
    maxSnack?: number;
    /** How much time the snackbar remains visible in milliseconds. */
    autoHideDuration?: number;
    /** Where is the snackbar placed. */
    anchorOrigin?: SnackbarOrigin;
    /** Class object used to override notistack classes. */
    notistackClassesOverride?: Partial<ClassNameMap<CombinedClassKey>>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSnackbarProviderClasses;
    className?: string;
}

export declare type HvSnackbarVariant = "default" | "success" | "warning" | "error";

/**
 * A Stack component allows the organization of its children in a vertical or horizontal layout.
 *
 * It also allows the specification of the spacing between the stack elements and the addition of a divider between the elements.
 */
export declare const HvStack: (props: HvStackProps) => JSX_2.Element;

export declare interface HvStackBreakpoints extends Record<HvBreakpoints, string> {
}

export declare type HvStackClasses = ExtractNames<typeof useClasses_45>;

export declare type HvStackDirection = "column" | "row" | Partial<HvStackBreakpoints>;

export declare interface HvStackProps extends HvBaseProps {
    /** The direction of the stack. Can be either a string or an object that states the direction for each breakpoint. */
    direction?: HvStackDirection;
    /** The spacing between elements of the stack. */
    spacing?: HvBreakpoints;
    /** The divider component to be used between the stack elements.
     * - If `true` the Material-UI Divider component will be used.
     * - If a React node is passed then the custom divider will be used.
     */
    divider?: boolean | React_2.ReactNode;
    /** The properties to pass on to the Material-UI component. */
    dividerProps?: DividerProps;
    /** Sets whether or not there should be arrow navigation between the stack elements. */
    withNavigation?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvStackClasses;
}

export declare const hvStringFallback: (value: any) => string;

export declare interface HvSuggestion {
    id?: string;
    label: React_2.ReactNode;
    value?: string;
    disabled?: boolean;
}

export declare const HvSuggestions: React_2.ForwardRefExoticComponent<HvSuggestionsProps & React_2.RefAttributes<unknown>>;

export declare type HvSuggestionsClasses = ExtractNames<typeof useClasses_12>;

export declare interface HvSuggestionsProps extends HvBaseProps {
    /** Whether suggestions is visible. */
    expanded?: boolean;
    /** The HTML element Suggestions attaches to. */
    anchorEl?: HTMLElement | null;
    /** Array of { id, label, ...others } values to display in the suggestion list */
    suggestionValues?: HvSuggestion[] | null;
    /** Function called when a suggestion is selected */
    onSuggestionSelected?: (event: React_2.MouseEvent, value: HvSuggestion) => void;
    /** Function called when suggestion list is closed */
    onClose?: (event: HvClickOutsideEvent) => void;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvSuggestionsClasses;
}

export { HvSupportColor }

export declare type HvSupportColorKeys = HvSupportColor;

export declare type HvSupportColors = Record<HvSupportColorKeys, string>;

/**
 * A Switch is <b>binary</b> and work as a digital on/off button.
 *
 * Use when two states are <b>opposite</b> and to trigger immediate
 * changes in the system.
 */
export declare const HvSwitch: (props: HvSwitchProps) => JSX_2.Element;

export declare type HvSwitchClasses = ExtractNames<typeof useClasses_58>;

export declare function hvSwitchColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, switchLabel: string, falseLabel?: string, trueLabel?: string, switchProps?: HvBaseSwitchProps): HvTableColumnConfig<D, H>;

export declare const HvSwitchColumnCell: ({ checked, value, switchLabel, falseLabel, trueLabel, switchProps, }: HvSwitchColumnCellProp) => JSX.Element;

export declare interface HvSwitchColumnCellProp {
    /** Whether the switch is checked or not. */
    checked: boolean;
    /** The switch label. */
    value: number | string | undefined;
    /** The value of the switch. */
    switchLabel: string;
    /** The right switch label. */
    falseLabel?: string;
    /** The left switch label. */
    trueLabel?: string;
    /** Extra props to be passed to the switch. */
    switchProps?: HvBaseSwitchProps;
}

export declare interface HvSwitchProps extends Omit<SwitchProps_2, "onChange" | "classes">, HvBaseProps<HTMLButtonElement, "onChange" | "color"> {
    /**
     * A Jss Object used to override or extend the styles applied to the switch.
     */
    classes?: HvSwitchClasses;
    /**
     * The form element name.
     */
    name?: string;
    /**
     * The value of the form element.
     *
     * Is up to the application's logic when to consider the submission of this value.
     * Generally it should be used only when the switch is neither unchecked nor indeterminate.
     *
     * The default value is "on".
     */
    value?: any;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React_2.ReactNode;
    /**
     * Properties passed on to the label element.
     */
    labelProps?: HvLabelProps;
    /**
     * Indicates that the form element is disabled.
     */
    disabled?: boolean;
    /**
     * Indicates that the form element is not editable.
     */
    readOnly?: boolean;
    /**
     * Indicates that user input is required on the form element.
     */
    required?: boolean;
    /**
     * If `true` the switch is selected, if set to `false` the switch is not selected.
     *
     * When defined the switch state becomes controlled.
     */
    checked?: boolean;
    /**
     * When uncontrolled, defines the initial checked state.
     */
    defaultChecked?: boolean;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to `checked`, depending of the values of both `required` and `checked`.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when the validation status is "invalid".
     *
     * Defaults to "Required" when the status is uncontrolled and no `aria-errormessage` is provided.
     */
    statusMessage?: string;
    /**
     * Identifies the element that provides an error message for the switch.
     *
     * Will only be used when the validation status is invalid.
     */
    "aria-errormessage"?: string;
    /**
     * The callback fired when the switch is pressed.
     */
    onChange?: (event: React_2.ChangeEvent, checked: boolean, value: any) => void;
    /**
     * Properties passed on to the input element.
     */
    inputProps?: React_2.InputHTMLAttributes<HTMLInputElement>;
    /** @ignore */
    ref?: SwitchProps_2["ref"];
    /** @ignore */
    component?: SwitchProps_2["component"];
}

export declare const HvTab: (props: HvTabProps) => JSX_2.Element;

export declare type HvTabClasses = ExtractNames<typeof useClasses_46>;

/**
 * A table gathers relational data. It displays values arranged to allow quick numerical analysis like comparison and sorting.
 *
 * The **HvTable** component offers a set of HTML-equivalent elements, **styled to Design System's specification**,
 * for building tables.
 * You can rely on these **elements** when your table doesn’t have many interactions or you need it to be very lightweight.
 *
 * For better data handling and **advanced features** we recommend the use of the utility hooks collection.
 * See the <a href="?id=guides-table-table-hooks--use-hv-hooks&viewMode=docs" target="_self">Table Hooks documentation</a> for more details.
 */
export declare const HvTable: ForwardRefExoticComponent<HvTableProps & RefAttributes<HTMLElement>>;

/**
 * HvTableBody acts as a `tbody` element.
 * `HvTableCell` and `HvTableRow` elements in it inherit body-specific styles
 */
export declare const HvTableBody: React_2.ForwardRefExoticComponent<HvTableBodyProps & React_2.RefAttributes<HTMLElement>>;

export declare type HvTableBodyClasses = ExtractNames<typeof useClasses_84>;

export declare interface HvTableBodyProps extends HvBaseProps<HTMLTableSectionElement, "children"> {
    /**
     * Content to be rendered
     */
    children: React_2.ReactNode;
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to tbody.
     */
    component?: React_2.ElementType;
    /** Sets whether or not there should be arrow navigation between the table rows */
    withNavigation?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableBodyClasses;
}

export declare interface HvTAbleBulkActionsProps extends TableCommonProps {
    numTotal: number;
    numSelected: number;
    showSelectAllPages: boolean;
    onSelectAll: () => void;
    onSelectAllPages: () => void;
    labels?: Record<string, string>;
}

/**
 * `HvTableCell` acts as a `td` element and inherits styles from its context
 */
export declare const HvTableCell: ForwardRefExoticComponent<HvTableCellProps & RefAttributes<HTMLElement>>;

export declare type HvTableCellAlign = "center" | "inherit" | "justify" | "left" | "right";

export declare type HvTableCellClasses = ExtractNames<typeof useClasses_88>;

export declare interface HvTableCellProps extends Omit<TdHTMLAttributes<HTMLTableCellElement>, "align"> {
    /** The component used for the root node. Either a string to use a HTML element or a component. Defaults to td. */
    component?: React.ElementType;
    /** Content to be rendered */
    children?: React.ReactNode;
    /** Inline styles to be applied to the root element. */
    style?: CSSProperties;
    /** Set the text-align on the table cell content. */
    align?: HvTableCellAlign;
    /** Sets the cell's variant. */
    variant?: HvTableCellVariant | "listcheckbox" | "listactions";
    /** Specify the cell's type. The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components. */
    type?: HvTableCellType;
    /** Whether or not the cell is part of a sorted column. */
    sorted?: boolean;
    /** The cell is part of a sticky column. */
    stickyColumn?: boolean;
    /** The cell is part of the last sticky to the left column. */
    stickyColumnMostLeft?: boolean;
    /** The cell is part of the first sticky to the right column. */
    stickyColumnLeastRight?: boolean;
    /** The cell is part of the first column in the group. */
    groupColumnMostLeft?: boolean;
    /** The cell is part of the last column in the group. */
    groupColumnMostRight?: boolean;
    /** Whether or not the cell is resizable */
    resizable?: boolean;
    /** Whether or not the cell is being resized */
    resizing?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableCellClasses;
}

export declare type HvTableCellType = "body" | "footer" | "head";

export declare type HvTableCellVariant = "checkbox" | "expand" | "actions" | "default" | "none";

export declare type HvTableClasses = ExtractNames<typeof useClasses_82>;

export declare type HvTableColumnConfig<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvColumnGroup<D, H> | HvColumnWithLooseAccessor<D, H> | HvColumnWithStrictAccessor<D, H>;

export declare interface HvTableColumnOptions<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<ColumnInterface<D>, "Header" | "Footer">, Partial<UseFiltersColumnOptions<D>>, Partial<UseGroupByColumnOptions<D>>, Partial<UseResizeColumnsColumnOptions<D>>, Partial<UseSortByColumnOptions<D>>, Partial<UseGlobalFiltersColumnOptions<D>>, Partial<UseHvTableStylesColumnOptions> {
    Header?: H;
    Footer?: Renderer<HvFooterProps_2<D>>;
    originalId?: IdType<D>;
}

/**
 * HvTableContainer is a container for the HvTable
 */
export declare const HvTableContainer: ForwardRefExoticComponent<HvTableContainerProps & RefAttributes<HTMLElement>>;

export declare type HvTableContainerClasses = ExtractNames<typeof useClasses_83>;

export declare interface HvTableContainerProps extends HvBaseProps<HTMLDivElement, "children"> {
    /**
     * Content to be rendered
     */
    children: React.ReactNode;
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to tbody.
     */
    component?: React.ElementType;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableContainerClasses;
}

export declare type HvTableDefinitionConfig<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvTableOptions<D, H>;

/**
 * HvTableHead acts as a `thead` element.
 * `HvTableCell` and `HvTableRow` elements in it inherit header-specific styles
 */
export declare const HvTableHead: ForwardRefExoticComponent<HvTableHeadProps & RefAttributes<HTMLElement>>;

export declare type HvTableHeadClasses = ExtractNames<typeof useClasses_85>;

/**
 * `HvTableHeader` acts as a `th` element and inherits styles from its context
 */
export declare const HvTableHeader: ForwardRefExoticComponent<HvTableHeaderProps & RefAttributes<HTMLElement>>;

export declare type HvTableHeaderClasses = ExtractNames<typeof useClasses_86>;

export declare interface HvTableHeaderProps extends Omit<ThHTMLAttributes<HTMLTableCellElement>, "align"> {
    /** The component used for the root node. Either a string to use a HTML element or a component. Defaults to th. */
    component?: React.ElementType;
    /** Content to be rendered */
    children?: React.ReactNode;
    /** The scope of cells that the header element relates to. */
    scope?: "col" | "row" | "colgroup" | "rowgroup";
    /** Set the text-align on the table cell content. */
    align?: HvTableCellAlign;
    /** Sets the cell's variant. */
    variant?: HvTableCellVariant;
    /** Specify the cell type. The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components. */
    type?: HvTableCellType;
    /** The cell is part of a sticky column. */
    stickyColumn?: boolean;
    /** The cell is part of the last sticky to the left column. */
    stickyColumnMostLeft?: boolean;
    /** The cell is part of the first sticky to the right column. */
    stickyColumnLeastRight?: boolean;
    /** The cell is part of the first column in the group. */
    groupColumnMostLeft?: boolean;
    /** The cell is part of the last column in the group. */
    groupColumnMostRight?: boolean;
    /** Whether or not the cell is sorted */
    sorted?: boolean;
    /** Whether or not the cell is sortable */
    sortable?: boolean;
    /** Set sort direction icon and aria-sort. */
    sortDirection?: "ascending" | "descending" | false;
    /** Extra props to be passed onto the text in the header. */
    headerTextProps?: HvTypographyProps;
    /** Whether or not the cell is resizable */
    resizable?: boolean;
    /** Whether or not the cell is being resized */
    resizing?: boolean;
    /** The resize props injected in the resize handler */
    resizerProps?: HTMLAttributes<HTMLDivElement>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableHeaderClasses;
    /** Extra props to be passed onto the sort button in the header. */
    sortButtonProps?: HvButtonProps;
}

export declare type HvTableHeaderRenderer<D extends object = Record<string, unknown>> = Renderer<HvHeaderProps_2<D>>;

export declare type HvTableHeadPropGetter<D extends object> = PropGetter<D, UseHvTableStickyTableHeadProps>;

export declare interface HvTableHeadProps extends HvBaseProps<HTMLTableSectionElement, "children"> {
    /**
     * Content to be rendered
     */
    children: React.ReactNode;
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to thead.
     */
    component?: React.ElementType;
    /**
     * The table has sticky headers.
     */
    stickyHeader?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableHeadClasses;
}

export declare interface HvTableInstance<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<TableInstance<D>, "pageCount" | "data" | "columns" | "rows" | "allColumns" | "visibleColumns" | "headers" | "flatHeaders" | "rowsById" | "prepareRow" | "flatRows" | "headerGroups" | "footerGroups" | "defaultColumn" | "stateReducer" | "useControlledState" | "getRowId" | "getHooks" | "getTableProps">, Omit<HvTableOptions<D, H>, "pageCount" | "columns">, Partial<UseColumnOrderInstanceProps<D>>, Partial<Omit<UseExpandedInstanceProps<D>, "rows">>, Partial<Omit<UseFiltersInstanceProps<D>, "rows" | "rowsById" | "flatRows">>, Partial<Omit<UseGlobalFiltersInstanceProps<D>, "rows" | "rowsById" | "flatRows">>, Partial<Omit<UseGroupByInstanceProps<D>, "rows" | "rowsById" | "flatRows">>, Partial<Omit<UsePaginationInstanceProps<D>, "page">>, Partial<Omit<UseSortByInstanceProps<D>, "rows">>, Partial<UseRowStateInstanceProps<D>>, Partial<Omit<UseHvRowSelectionTableInstance<D>, "selectedFlatRows">>, Partial<UseHvTableStickyTableInstance<D>>, Partial<UseHvHeaderGroupsInstance>, Partial<UseHvPaginationTableInstance<D>>, Partial<UseHvBulkActionsTableInstanceProps<D>> {
    initialState: Partial<HvTableState<D>>;
    state: HvTableState<D>;
    columns: Array<HvColumnInstance<D, H>>;
    allColumns: Array<HvColumnInstance<D, H>>;
    visibleColumns: Array<HvColumnInstance<D, H>>;
    headers: Array<HvColumnInstance<D, H>>;
    flatHeaders: Array<HvColumnInstance<D, H>>;
    rows: Array<HvRowInstance<D, H>>;
    page: Array<HvRowInstance<D, H>>;
    rowsById: Record<string, HvRowInstance<D, H>>;
    flatRows: Array<HvRowInstance<D, H>>;
    getHooks: () => HvHooks<D>;
    getTableProps: (propGetter?: HvTablePropGetter<D, H>) => HvUseTableProps;
    prepareRow: (row: HvRowInstance<D, H>) => void;
    selectedFlatRows: Array<HvRowInstance<D, H>>;
    initialRows: Array<HvRowInstance<D, H>>;
    initialRowsById: Record<string, HvRowInstance<D, H>>;
    labels: Record<string, string>;
    headerGroups: Array<HvHeaderGroup<D, H>>;
    footerGroups: Array<HvHeaderGroup<D, H>>;
}

export declare interface HvTableOptions<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> extends Omit<TableOptions<D>, "columns" | "data" | "defaultColumn" | "stateReducer" | "useControlledState" | "getRowId">, Partial<UseExpandedOptions<D>>, Partial<UseFiltersOptions<D>>, Partial<UseGlobalFiltersOptions<D>>, Partial<UseGroupByOptions<D>>, Partial<UsePaginationOptions<D>>, Partial<UseResizeColumnsOptions<D>>, Partial<UseSortByOptions<D>>, Partial<UseRowStateOptions<D>>, Partial<UseHvTableStylesTableOptions>, Partial<UseHvRowSelectionTableOptions>, Partial<UseHvTableStickyTableOptions>, Partial<UseHvBulkActionsTableOptions>, Partial<UseHvRowExpandTableOptions> {
    columns?: Array<HvTableColumnConfig<D, H>>;
    data?: D[];
    initialState?: Partial<HvTableState<D>>;
    labels?: Record<string, string>;
    defaultColumn?: Partial<HvTableColumnConfig<D, H>>;
    stateReducer?: (newState: HvTableState<D>, action: ActionType, previousState: HvTableState<D>, instance?: HvTableInstance<D, H>) => HvTableState<D>;
    useControlledState?: (state: HvTableState<D>, meta: HvMeta<D, H>) => HvTableState<D>;
    getRowId?: (originalRow: D, relativeIndex: number, parent?: HvRowInstance<D, H>) => string;
}

export declare interface HvTablePaginationProps extends TableCommonProps {
    canPrevious: boolean;
    canNext: boolean;
    pages: number;
    page: number;
    pageSize: number;
    onPageChange?: (updater: ((pageIndex: number) => number) | number) => void;
    onPageSizeChange?: (pageSize: number) => void;
    labels?: Record<string, string>;
}

export { HvTablePluginHook }

declare type HvTablePropGetter<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer> = HvPropGetter<D, H, HvUseTableProps>;

export declare interface HvTableProps extends TableHTMLAttributes<HTMLTableElement> {
    /**
     * The component used for the root node. Either a string to use a HTML element or a component.
     * Defaults to `table`.
     *
     * When using non-table elements, layout is up to the developer using the component.
     */
    component?: React.ElementType;
    /** Content to be rendered */
    children: React.ReactNode;
    /** Whether the `HvTable` has a sticky header row. */
    stickyHeader?: boolean;
    /** Whether the `HvTable` has sticky columns. */
    stickyColumns?: boolean;
    /** Whether the `HvTable` has the list row styles or the default. */
    variant?: HvTableVariant;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableClasses;
}

/**
 * `HvTableRow` acts as a `tr` element and inherits styles from its context
 */
export declare const HvTableRow: ForwardRefExoticComponent<HvTableRowProps & RefAttributes<HTMLElement>>;

export declare type HvTableRowClasses = ExtractNames<typeof useClasses_87>;

export declare interface HvTableRowProps extends HvBaseProps<HTMLTableRowElement, "children"> {
    /** Content to be rendered */
    children: React.ReactNode;
    /** The component used for the root node. Either a string to use a HTML element or a component. Defaults to tbody. */
    component?: React.ElementType;
    /** Whether the table row will shade on hover. */
    hover?: boolean;
    /** Whether the table row will have the selected shading. */
    selected?: boolean;
    /** Whether the table row is expanded. */
    expanded?: boolean;
    /** Whether the table row background is striped. */
    striped?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTableRowClasses;
}

export declare interface HvTableState<D extends object = Record<string, unknown>> extends TableState<D>, Partial<UseColumnOrderState<D>>, Partial<UseExpandedState<D>>, Partial<UseFiltersState<D>>, Partial<UseGlobalFiltersState<D>>, Partial<UseGroupByState<D>>, Partial<UsePaginationState<D>>, Partial<UseResizeColumnsState<D>>, Partial<UseSortByState<D>>, Partial<UseRowStateState<D>>, Partial<UseHvRowSelectionState<D>> {
    rowCount: number;
}

export declare type HvTableVariant = "listrow" | "default";

export declare interface HvTabProps extends Omit<TabProps, "children">, HvBaseProps<HTMLDivElement, "children"> {
    /** If `true`, the tab will be disabled. */
    disabled?: boolean;
    /** The icon element. */
    icon?: React.ReactElement | string;
    /** The label element. */
    label?: React.ReactNode;
    /** The position of the icon relative to the label. */
    iconPosition?: "bottom" | "end" | "start" | "top";
    /** A Jss Object used to override or extend the component styles. */
    classes?: HvTabClasses;
}

/**
 * A Tab is a graphical control element that allows multiple documents or panels to be contained within a single window.
 * Tabs can be used as a navigational widget for switching between sets of documents.
 */
export declare const HvTabs: (props: HvTabsProps) => JSX_2.Element;

export declare type HvTabsClasses = ExtractNames<typeof useClasses_47>;

export declare interface HvTabsProps extends Omit<TabsProps, "onChange"> {
    /**
     * The value of the currently selected Tab. If you don't want any selected Tab, you can set this property to `false`.
     */
    value?: any;
    /**
     * Callback fired when the value changes.
     */
    onChange?: (event: React.SyntheticEvent, value: any) => void;
    /**
     * A Jss Object used to override or extend the component styles.
     */
    classes?: HvTabsClasses;
    /** @ignore */
    ref?: TabsProps["ref"];
    /** @ignore */
    component?: TabsProps["component"];
}

/**
 * A Tag is one word that describes a specific aspect of an asset. A single asset can have
 * multiple tags.
 * Use tags to highlight an item's status for quick recognition and navigation
 * Use color to indicate meanings that users can learn and recognize across products
 *
 * It leverages the Chip component from Material UI
 */
export declare const HvTag: (props: HvTagProps) => JSX_2.Element;

export declare type HvTagClasses = ExtractNames<typeof useClasses_48>;

export declare function hvTagColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer, A extends object = Record<string, unknown>>(col: HvTableColumnConfig<D, H>, valueDataKey: keyof A, colorDataKey: keyof A, textColorDataKey: keyof A, fromRowData?: boolean, tagProps?: HvTagProps): HvTableColumnConfig<D, H>;

export declare interface HvTagProps extends Omit<ChipProps, "color" | "classes"> {
    /** The label of the tag element. */
    label?: React.ReactNode;
    /** Indicates that the form element is disabled. */
    disabled?: boolean;
    /** The type of the tag element. A tag can be of semantic or categoric type. */
    type?: "semantic" | "categorical";
    /** Background color to be applied to the tag */
    color?: HvColorAny;
    /** Icon used to customize the delete icon in the Chip element */
    deleteIcon?: React.ReactElement;
    /**
     * The callback fired when the delete icon is pressed.
     * This function has to be provided to the component, in order to render the delete icon
     * */
    onDelete?: (event: React.MouseEvent<HTMLElement>) => void;
    /** Callback triggered when any item is clicked. */
    onClick?: (event: React.MouseEvent<HTMLElement>) => void;
    /** Aria properties to apply to delete button in tag
     * @deprecated no longer used
     */
    deleteButtonArialLabel?: string;
    /** Props to apply to delete icon */
    deleteButtonProps?: HTMLAttributes<HTMLDivElement>;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTagClasses;
    /** @ignore */
    ref?: ChipProps["ref"];
    /** @ignore */
    component?: ChipProps["component"];
}

/**
 * A tags input is a single or multiline control that allows the input of tags.
 */
export declare const HvTagsInput: (props: HvTagsInputProps) => JSX_2.Element;

export declare type HvTagsInputClasses = ExtractNames<typeof useClasses_61>;

export declare interface HvTagsInputProps extends HvBaseProps<HTMLElement, "onChange" | "onBlur" | "onFocus" | "onKeyDown" | "color" | "defaultValue"> {
    /** The form element name. */
    name?: string;
    /** The value of the form element. */
    value?: string[] | HvTagProps[];
    /** When uncontrolled, defines the initial input value. */
    defaultValue?: string[] | HvTagProps[];
    /**
     * The label of the form element.
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be inputted via inputProps.
     */
    label?: React_2.ReactNode;
    /** Provide additional descriptive text for the form element. */
    description?: React_2.ReactNode;
    /** Indicates that the form element is disabled. */
    disabled?: boolean;
    /** Indicates that the form element is not editable. */
    readOnly?: boolean;
    /** Indicates that the form element is required. */
    required?: boolean;
    /** The function that will be executed onChange. */
    onChange?: (event: React_2.ChangeEvent<HTMLInputElement> | React_2.KeyboardEvent<HTMLInputElement> | React_2.MouseEvent<HTMLButtonElement> | React_2.MouseEvent<HTMLElement, MouseEvent> | React_2.KeyboardEventHandler<HTMLElement>, value: HvTagProps[]) => void;
    /** The function that will be executed when the element is focused. */
    onFocus?: (event: React_2.FocusEvent<HTMLInputElement>, value: string) => void;
    /** The function that will be executed when the element is blurred. */
    onBlur?: (event: React_2.FocusEvent<HTMLInputElement>, value: string) => void;
    /** The function that will be executed when a tag is deleted. */
    onDelete?: (event: React_2.ChangeEvent<HTMLInputElement> | React_2.KeyboardEvent<HTMLInputElement> | React_2.MouseEvent<HTMLButtonElement> | React_2.MouseEvent<HTMLElement, MouseEvent> | React_2.KeyboardEventHandler<HTMLElement>, value: HvTagProps, index: number) => void;
    /** The function that will be executed when a tag is added. */
    onAdd?: (event: React_2.ChangeEvent<HTMLInputElement> | React_2.KeyboardEvent<HTMLInputElement> | React_2.MouseEvent<HTMLButtonElement> | React_2.MouseEvent<HTMLElement, MouseEvent> | React_2.KeyboardEventHandler<HTMLElement>, value: HvTagProps, index: number) => void;
    /** The placeholder value of the input. */
    placeholder?: string;
    /** If `true` the character counter isn't shown even if maxTagsQuantity is set. */
    hideCounter?: boolean;
    /** Text between the current char counter and max value. */
    middleCountLabel?: string;
    /** The maximum allowed length of the characters, if this value is null no check will be performed. */
    maxTagsQuantity?: number;
    /** Attributes applied to the input element. */
    inputProps?: InputBaseComponentProps;
    /** If `true` it should autofocus. */
    autoFocus?: boolean;
    /** If `true` the component is resizable. */
    resizable?: boolean;
    /** Props passed to the HvCharCount component. */
    countCharProps?: Partial<HvCharCounterProps>;
    /** If `true` the component is in multiline mode. */
    multiline?: boolean;
    /** The status of the form element. */
    status?: HvFormStatus;
    /** The error message to show when `status` is "invalid". */
    statusMessage?: React_2.ReactNode;
    /** An Object containing the various texts associated with the input. */
    validationMessages?: HvValidationMessages;
    /** An array of strings that represent the character used to input a tag. This character is the string representation of the event.code from the input event. */
    commitTagOn?: string[];
    /** If `true` the tag will be committed when the blur event occurs. */
    commitOnBlur?: boolean;
    /** The function that will be executed to received an array of objects that has a label and id to create list of suggestion */
    suggestionListCallback?: (value: string) => HvTagSuggestion[] | null;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTagsInputClasses;
}

export declare interface HvTagSuggestion extends HvInputSuggestion {
}

/**
 * A text area is a multiline text input box, with an optional character counter when there is a length limit.
 */
export declare const HvTextArea: ForwardRefExoticComponent<Omit<HvTextAreaProps, "ref"> & RefAttributes<any>>;

export declare type HvTextAreaClasses = ExtractNames<typeof useClasses_60>;

export declare interface HvTextAreaProps extends Omit<HvBaseInputProps, "onChange" | "onBlur" | "rows" | "classes" | "onFocus" | "placeholder"> {
    /** The placeholder value of the text area. */
    placeholder?: string;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
    /**
     * The status of the form element.
     *
     * Valid is correct, invalid is incorrect and standBy means no validations have run.
     *
     * When uncontrolled and unspecified it will default to "standBy" and change to either "valid"
     * or "invalid" after any change to the state.
     */
    status?: HvFormStatus;
    /**
     * The error message to show when `status` is "invalid".
     */
    statusMessage?: React.ReactNode;
    /**
     * Text between the current char counter and max value.
     */
    middleCountLabel?: string;
    /**
     * An Object containing the various texts associated with the input.
     */
    validationMessages?: HvValidationMessages;
    /**
     * The custom validation function, it receives the value and must return
     * either `true` for valid or `false` for invalid, default validations would only
     * occur if this function is null or undefined
     */
    validation?: (value: string) => boolean;
    /**
     * The maximum allowed length of the characters, if this value is null no check
     * will be performed.
     */
    maxCharQuantity?: number;
    /**
     * The minimum allowed length of the characters, if this value is null no check
     * will be perform.
     */
    minCharQuantity?: number;
    /**
     * If `true` it should autofocus.
     */
    autoFocus?: boolean;
    /**
     * The number of rows of the text area
     */
    rows?: number;
    /**
     * If `true` the component is resizable.
     */
    resizable?: boolean;
    /**
     * Auto-scroll: automatically scroll to the end on value changes.
     * Will stop if the user scrolls up and resume if scrolled to the bottom.
     */
    autoScroll?: boolean;
    /**
     * If true it isn't possible to pass the `maxCharQuantity`
     */
    blockMax?: boolean;
    /**
     * If `true` the character counter isn't shown even if maxCharQuantity is set.
     */
    hideCounter?: boolean;
    /**
     * Props passed to the char count.
     */
    countCharProps?: Partial<HvCharCounterProps>;
    /**
     * Called back when the value is changed.
     */
    onChange?: (event: React.ChangeEvent<HTMLTextAreaElement>, value: string) => void;
    /**
     * Called back when the value is changed.
     */
    onBlur?: (event: React.FocusEvent<HTMLTextAreaElement>, value: string, validationState: HvInputValidity) => void;
    /**
     * The function that will be executed onBlur, allows checking the value state,
     * it receives the value.
     */
    onFocus?: (event: React.FocusEvent<HTMLTextAreaElement>, value: string) => void;
    /**
     * A Jss Object used to override or extend the component styles applied.
     */
    classes?: HvTextAreaClasses;
}

export declare function hvTextColumn<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(col: HvTableColumnConfig<D, H>, overflowTooltipProps?: Omit<HvOverflowTooltipProps, "data">): HvTableColumnConfig<D, H>;

export { HvTheme }

export { HvThemeBreakpoint }

export { HvThemeColorMode }

export { HvThemeContext }

export { HvThemeContextValue }

export declare type HvThemeCustomizationProps = HvExtraDeepPartialProps<Omit<HvThemeStructure, "colors" | "name" | "base">> & {
    colors?: {
        modes?: {
            [key: string]: Partial<HvThemeColorModeStructure> & {
                [key: string]: string;
            };
        };
    };
};

export declare interface HvThemePalette {
    accent: HvAccentColors;
    atmosphere: HvAtmosphereColors;
    base: HvBaseColors;
    semantic: HvSemanticColors;
    support: HvSupportColors;
}

export declare const HvThemeProvider: ({ children, themes: themesList, theme, emotionCache, colorMode, themeRootId: rootId, }: HvThemeProviderProps) => JSX_2.Element;

declare interface HvThemeProviderProps {
    children: React.ReactNode;
    themes: (HvTheme | HvThemeStructure)[];
    theme: string;
    emotionCache: EmotionCache;
    colorMode: string;
    themeRootId?: string;
}

/**
 * The HvTimeAgo component implements the Design System relative time format guidelines.
 */
export declare const HvTimeAgo: <C extends React.ElementType = "p">(props: HvTimeAgoProps<C>) => React.ReactElement | null;

export declare type HvTimeAgoClasses = ExtractNames<typeof useClasses_112>;

export declare type HvTimeAgoProps<C extends React.ElementType = "p"> = PolymorphicComponentRef<C, {
    /**
     * The timestamp to format, in seconds or milliseconds.
     * Defaults to `emptyElement` if value is null or 0
     */
    timestamp?: number;
    /**
     * The locale to be used. Should be on of the dayjs supported locales and explicitly imported
     * @see https://day.js.org/docs/en/i18n/i18n
     */
    locale?: string;
    /**
     * The element to render when the timestamp is null or 0
     * Defaults to `—` (Em Dash)
     */
    emptyElement?: React.ReactNode;
    /** Disables periodic date refreshes */
    disableRefresh?: boolean;
    /** Whether to show seconds in the rendered time */
    showSeconds?: boolean;
    /**
     * Whether the component should render just the string
     * Consider using `useTimeAgo` instead
     */
    justText?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTimeAgoClasses;
}>;

/**
 * A Time Picker allows the user to choose a specific time or a time range.
 */
export declare const HvTimePicker: (props: HvTimePickerProps) => JSX_2.Element;

export declare type HvTimePickerClasses = ExtractNames<typeof useClasses_117>;

export declare type HvTimePickerClassKey = "root" | "input" | "label" | "placeholder" | "timePopperContainer" | "separator" | "periodContainer" | "formElementRoot" | "dropdownPlaceholder" | "iconBaseRoot" | "error" | "labelContainer" | "description" | "dropdownHeaderInvalid" | "dropdownPlaceholderDisabled" | "dropdownHeaderOpen";

export declare interface HvTimePickerProps extends Omit<HvFormElementProps, "classes" | "value" | "defaultValue" | "onChange" | "onFocus" | "onBlur"> {
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTimePickerClasses;
    /** Current value of the element when _controlled_. Follows the 24-hour format. */
    value?: HvTimePickerValue;
    /** Initial value of the element when _uncontrolled_. Follows the 24-hour format. */
    defaultValue?: HvTimePickerValue;
    /** The placeholder value when no time is selected. */
    placeholder?: string;
    /** The placeholder of the hours input. */
    hoursPlaceholder?: string;
    /** The placeholder of the minutes input. */
    minutesPlaceholder?: string;
    /** The placeholder of the seconds input. */
    secondsPlaceholder?: string;
    /**
     * Whether the time picker should show the AM/PM 12-hour clock or the 24-hour one.
     * If undefined, the component will use a format according to the passed locale.
     */
    timeFormat?: TimeFormat;
    /** Whether to show the seconds when using the native time picker */
    showSeconds?: boolean;
    /** Locale that will provide the time format(12 or 24 hour format). It is "overwritten" by `showAmPm` */
    locale?: string;
    /** Whether the dropdown is expandable. */
    disableExpand?: boolean;
    /**
     * Callback function to be triggered when the input value is changed.
     * It is invoked with a `{hours, minutes, seconds}` object, always in the 24h format
     */
    onChange?: (value: HvTimePickerValue) => void;
    /** Callback called when dropdown changes the expanded state. */
    onToggle?: (event: Event, isOpen: boolean) => void;
    /** Disable the portal behavior. The children stay within it's parent DOM hierarchy. */
    disablePortal?: boolean;
    /** Sets if the calendar container should follow the date picker input out of the screen or stay visible. */
    escapeWithReference?: boolean;
    /** Extra properties to be passed to the TimePicker's dropdown. */
    dropdownProps?: Partial<HvBaseDropdownProps>;
    /**
     * The label of the form element.
     *
     * The form element must be labeled for accessibility reasons.
     * If not provided, an aria-label or aria-labelledby must be provided instead.
     */
    label?: React.ReactNode;
    /**
     * Provide additional descriptive text for the form element.
     */
    description?: React.ReactNode;
}

export declare type HvTimePickerValue = {
    hours: number;
    minutes: number;
    seconds: number;
};

export declare const HvToggleButton: ForwardRefExoticComponent<HvToggleButtonProps & RefAttributes<HTMLButtonElement>>;

export declare interface HvToggleButtonProps extends HvBaseProps<HTMLButtonElement, "onClick"> {
    /** When uncontrolled, defines the initial selected state. */
    defaultSelected?: boolean;
    /** Defines if the button is selected. When defined the button state becomes controlled. */
    selected?: boolean;
    /** Defines if the button is disabled. */
    disabled?: boolean;
    /** Icon for when not selected. Ignored if the component has children. */
    notSelectedIcon?: React.ReactNode;
    /** Icon for when selected. Ignored if the component has children. */
    selectedIcon?: React.ReactNode;
    /** Function called when icon is clicked. */
    onClick?: (event: React.MouseEvent<HTMLButtonElement>, selected: boolean) => void;
}

/**
 * Tooltips display informative text when users hover over, focus on, or tap an element.
 * Accessibility-wise, the tooltip automatically labels the `children` content.
 */
export declare const HvTooltip: ForwardRefExoticComponent<Omit<HvTooltipProps, "ref"> & RefAttributes<unknown>>;

export declare type HvTooltipClasses = ExtractNames<typeof useClasses_49>;

export declare type HvTooltipPlacementType = TooltipProps["placement"];

export declare interface HvTooltipProps extends Omit<TooltipProps, "classes"> {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvTooltipClasses;
    /**
     * If true, the tooltip is shown.
     */
    open?: boolean;
    /**
     * Tooltip placement.
     */
    placement?: HvTooltipPlacementType;
    /**
     * The number of milliseconds to wait before showing the tooltip.
     * This property won't impact the enter touch delay (enterTouchDelay).
     */
    enterDelay?: number;
    /** @inheritdoc */
    title: TooltipProps["title"];
    /** @inheritdoc */
    TransitionComponent?: TooltipProps["TransitionComponent"];
    /** @inheritdoc */
    TransitionProps?: TooltipProps["TransitionProps"];
    /**
     * Defines if should use a single or multiline tooltip.
     */
    useSingle?: boolean;
    /**
     * Node to apply the tooltip.
     */
    children: ReactElement;
    /**
     * Id attribute value of an HTML Element to have the tooltip appended to it.
     */
    containerId?: string;
}

/**
 * Typography component is used to render text and paragraphs within an interface.
 */
export declare const HvTypography: <C extends React.ElementType = "p">(props: HvTypographyProps<C>) => React.ReactElement | null;

export declare type HvTypographyClasses = ExtractNames<typeof useClasses>;

/** @deprecated */
export declare type HvTypographyLegacyVariants = "5xlTitle" | "4xlTitle" | "3xlTitle" | "xxlTitle" | "xlTitle" | "lTitle" | "mTitle" | "sTitle" | "xsTitle" | "xxsTitle" | "sectionTitle" | "highlightText" | "normalText" | "placeholderText" | "link" | "disabledText" | "selectedNavText" | "vizText" | "vizTextDisabled" | "xsInlineLink";

export declare type HvTypographyProps<C extends React.ElementType = "p"> = PolymorphicComponentRef<C, {
    /** Use the variant prop to change the visual style of the Typography. */
    variant?: HvTypographyVariants | HvTypographyLegacyVariants;
    /** If `true` the typography will display the look of a link. */
    link?: boolean;
    /** If `true` the typography will display the look of a disabled state. */
    disabled?: boolean;
    /** If `true`, the text will have a bottom margin. */
    paragraph?: boolean;
    /**
     * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
     *
     * Note that text overflow can only happen with block or inline-block level elements
     * (the element needs to have a width in order to overflow).
     */
    noWrap?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvTypographyClasses;
}>;

export declare type HvTypographyVariants = (typeof typographyVariants)[number];

export declare type HvUndefinedStateColorKeys = "atmo4";

export declare interface HvUseTableCellProps extends Omit<TableCellProps, "role">, Omit<UseHvTableStylesTableCellProps, "variant" | "classes">, UseHvTableStickyCellProps, UseHvHeaderGroupsCellProps, UseHvResizeTableCellProps, UseHvSortByTableCellProps, HvTableCellProps {
}

export declare interface HvUseTableFooterProps extends TableFooterProps, UseHvTableStylesTableCellProps {
}

export declare interface HvUseTableHeaderProps extends Omit<TableHeaderProps, "role">, Omit<UseHvTableStylesTableCellProps, "classes">, UseHvTableStickyColumnProps, UseHvHeaderGroupsColumnProps, UseHvResizeColumnProps, Omit<UseHvSortByColumnProps, "sortDirection">, HvTableHeaderProps {
}

export declare interface HvUseTableProps extends Omit<TableProps, "role">, UseHvTableStickyTableProps, HvTableProps {
}

export declare interface HvUseTableRowProps extends Omit<TableRowProps, "role">, UseHvTableStylesTableRowProps, UseHvRowSelectionTableRowProps, UseHvRowExpandTableRowProps, HvTableRowProps {
}

export declare interface HvValidationMessages {
    /** The value when a validation fails. */
    error?: string;
    /** The message that appears when there are too many characters. */
    maxCharError?: string;
    /** The message that appears when there are too few characters. */
    minCharError?: string;
    /** The message that appears when the input is empty and required. */
    requiredError?: string;
    /** The message that appears when the input is value is incompatible with the expected type. */
    typeMismatchError?: string;
}

/**
 * Navigation enables users to move through an app to complete tasks.
 *
 * It is recommended to use vertical navigation when your application requires global navigation that is displayed on the left.
 * While vertical navigation menus generally consume more space than their horizontal counterparts, they have become more popular as desktop monitors move to wide-screen formats.
 *
 * Although both the hierarchically organized data and the visual style resemble a treeview-like structure, the [Treeview Design Pattern](https://w3c.github.io/aria-practices/#TreeView)
 * isn't necessarily the most appropriate.
 *
 * The tree role provides complex functionality that is not needed for typical site navigation, and changes the most common keyboard navigation using TAB.
 *
 * The [Disclosure Design Pattern](https://w3c.github.io/aria-practices/#disclosure) is more suited for typical site navigation, with expandable groups of links.
 * However it can be tedious to TAB through all navigation items to reach the actions panel.
 *
 * Both modes are available via the `mode` property and each app should choose the most appropriate.
 */
export declare const HvVerticalNavigation: (props: HvVerticalNavigationProps) => JSX_2.Element;

export declare const HvVerticalNavigationAction: ({ className, classes: classesProp, id, label, icon, onClick, ...others }: HvVerticalNavigationActionProps) => JSX_2.Element;

export declare type HvVerticalNavigationActionClasses = ExtractNames<typeof useClasses_98>;

export declare interface HvVerticalNavigationActionProps {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvVerticalNavigationActionClasses;
    /**
     * Id to be applied to the action.
     */
    id?: string;
    /**
     * Visual label.
     */
    label?: string;
    /**
     * Icon.
     */
    icon?: React.ReactNode;
    /**
     * Callback called when clicked.
     */
    onClick?: MouseEventHandler<HTMLElement>;
}

export declare const HvVerticalNavigationActions: ({ className, classes: classesProp, id, children, ...others }: HvVerticalNavigationActionsProps) => JSX_2.Element;

export declare type HvVerticalNavigationActionsClasses = ExtractNames<typeof useClasses_97>;

export declare interface HvVerticalNavigationActionsProps {
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvVerticalNavigationActionsClasses;
    /**
     * Id to be applied to the actions container.
     */
    id?: string;
    /**
     * Node to be rendered
     */
    children?: React.ReactNode;
}

export declare type HvVerticalNavigationClasses = ExtractNames<typeof useClasses_95>;

export declare const HvVerticalNavigationHeader: ({ title, openIcon, closeIcon, collapseButtonProps, backButtonProps, className, classes: classesProp, onCollapseButtonClick, ...others }: HvVerticalNavigationHeaderProps) => JSX_2.Element | null;

export declare type HvVerticalNavigationHeaderClasses = ExtractNames<typeof useClasses_96>;

export declare interface HvVerticalNavigationHeaderProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * The title text to show on Header.
     */
    title?: string;
    /**
     * Icon to show when Vertical Navigation is collapsed.
     */
    openIcon?: React.ReactNode;
    /**
     * Icon to show when Vertical Navigation is expanded.
     */
    closeIcon?: React.ReactNode;
    /**
     * Props for the collapse button.
     */
    collapseButtonProps?: HvButtonProps;
    /**
     * Props for the back button.
     */
    backButtonProps?: HvButtonProps;
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvVerticalNavigationHeaderClasses;
    /**
     * Handler for the collapse button.
     */
    onCollapseButtonClick?: MouseEventHandler<HTMLElement>;
}

export declare type HvVerticalNavigationMode = "icon" | "simple";

export declare type HvVerticalNavigationPosition = "static" | "relative" | "fixed" | "absolute";

export declare interface HvVerticalNavigationProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvVerticalNavigationClasses;
    /**
     * Current State of the Vertical Navigation Collapse
     */
    open?: boolean;
    /**
     * Collpased Mode for the Vertical Navigation, the default value is "simple".
     *
     * @deprecated - `useIcons` property should be used instead.
     */
    collapsedMode?: HvVerticalNavigationMode;
    /**
     * Boolean to determine if treeview is in slider mode (for mobile navigation), the default value is false.
     */
    slider?: boolean;
    /**
     * The content inside the actions container.
     */
    children?: React.ReactNode;
    /**
     * Boolean to determine if icons should be displayed in the navigation menu.
     * When `true` a icon will always be displayed, if no icon is provided the first letter of the label will be
     * displayed inside an Avatar component.
     * When `false` no icons will be shown, even if an icon is provided.
     */
    useIcons?: boolean;
}

export declare const HvVerticalNavigationSlider: ({ id, classes: classesProp, data, selected, onNavigateToTarget, onNavigateToChild, forwardButtonAriaLabel, }: HvVerticalNavigationSliderProps) => JSX_2.Element;

export declare type HvVerticalNavigationSliderClasses = ExtractNames<typeof useClasses_100>;

export declare interface HvVerticalNavigationSliderProps {
    /**
     * Id to be applied to the root node of the panel.
     */
    id?: string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvVerticalNavigationSliderClasses;
    /**
     * An array containing the data for each menu item.
     *
     * id - the id to be applied to the root element.
     * label - the label to be rendered on the menu item.
     * icon - the icon react element
     * data - sub-menu items
     * href - the url used for navigation.
     * target - the behavior when opening an url.
     */
    data?: NavigationData[];
    /**
     * The selected item id.
     */
    selected?: string;
    /**
     * Triggered when the item is clicked.
     */
    onNavigateToTarget?: (event: React.MouseEvent<HTMLLIElement>, item: NavigationData) => void;
    /**
     * Triggered when the navigate to child button is clicked.
     */
    onNavigateToChild?: (event: React.MouseEvent<HTMLButtonElement>, item: NavigationData) => void;
    /** Aria label to apply to the navigate to submenu button on the list items. */
    forwardButtonAriaLabel?: string;
}

export declare const HvVerticalNavigationTree: ({ id, className, classes: classesProp, data, mode, collapsible, expanded: expandedProp, defaultExpanded, onToggle, selected: selectedProp, defaultSelected, onChange, sliderForwardButtonAriaLabel, ...others }: HvVerticalNavigationTreeProps) => JSX_2.Element;

export declare type HvVerticalNavigationTreeClasses = ExtractNames<typeof useClasses_99>;

export declare interface HvVerticalNavigationTreeProps extends HvBaseProps<HTMLDivElement, "onChange"> {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied.
     */
    classes?: HvVerticalNavigationTreeClasses;
    /**
     * Modus operandi (role) of the widget instance.
     */
    mode?: NavigationMode;
    /**
     * Can non-leaf nodes be collapsed / expanded.
     */
    collapsible?: boolean;
    /**
     * The ID of the selected page.
     */
    selected?: string;
    /**
     * When uncontrolled, defines the initial selected page ID.
     */
    defaultSelected?: string;
    /**
     * Callback fired when a navigation item is selected.
     *
     * @param {object} event The event source of the callback.
     * @param {object} page The data of the selected page.
     */
    onChange?: (event: any, page: any) => void;
    /**
     * Expanded nodes' ids.
     */
    expanded?: string[];
    /**
     * When uncontrolled, defines the initial expanded nodes' ids.
     *
     * It also supports `true` for starting with all nodes expanded.
     * With `false` all nodes will be collapsed.
     *
     * By default it expands the needed nodes to display the current selection, if any.
     */
    defaultExpanded?: string[] | boolean;
    /**
     * Callback fired when tree items are expanded/collapsed.
     *
     * @param {object} event The event source of the callback.
     * @param {array} nodeIds The ids of the expanded nodes (old and new).
     */
    onToggle?: (event: any, nodeIds: any) => void;
    /**
     * An array containing the data for each menu item.
     *
     * id - the id to be applied to the root element.
     * label - the label to be rendered on the menu item.
     * data - sub-menu items
     * href - the url used for navigation.
     * target - the behavior when opening an url.
     */
    data?: NavigationData[];
    /** Aria label to apply to the navigate to submenu button on the navigation slider list items. */
    sliderForwardButtonAriaLabel?: string;
}

export declare const HvVerticalNavigationTreeView: ForwardRefExoticComponent<HvVerticalNavigationTreeViewProps & RefAttributes<unknown>>;

export declare type HvVerticalNavigationTreeViewClasses = ExtractNames<typeof useClasses_101>;

export declare const HvVerticalNavigationTreeViewItem: ForwardRefExoticComponent<HvVerticalNavigationTreeViewItemProps & RefAttributes<unknown>>;

export declare type HvVerticalNavigationTreeViewItemClasses = ExtractNames<typeof useClasses_102>;

export declare interface HvVerticalNavigationTreeViewItemProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the Radio button.
     */
    classes?: HvVerticalNavigationTreeViewItemClasses;
    /**
     * Is the node disabled.
     */
    disabled?: boolean;
    /**
     * Can the node be selected.
     */
    selectable?: boolean;
    /**
     * The id of the node.
     */
    nodeId?: string;
    /**
     * The icon to display next to the node's label.
     */
    icon?: React.ReactNode;
    /**
     * The item label.
     */
    label?: React.ReactNode;
    /**
     * The url for the link.
     */
    href?: string;
    /**
     * The behavior when opening a link.
     */
    target?: string;
    /**
     * The node payload.
     */
    payload?: any;
    /**
     * @ignore
     */
    onClick?: any;
    /**
     * @ignore
     */
    onMouseDown?: any;
    /**
     * @ignore
     */
    onFocus?: any;
    /**
     * The content of the component.
     */
    children?: React.ReactNode;
    /**
     * @ignore
     */
    onMouseEnter?: any;
    /**
     * Disables the appearence of a tooltip on hovering an element ( Only applicable when the in collapsed mode)
     */
    disableTooltip?: boolean;
}

export declare interface HvVerticalNavigationTreeViewProps {
    /**
     * Id to be applied to the root node.
     */
    id?: string;
    /**
     * Class names to be applied.
     */
    className?: string;
    /**
     * A Jss Object used to override or extend the styles applied to the component.
     */
    classes?: HvVerticalNavigationTreeViewClasses;
    /**
     * Modus operandi (role) of the widget instance.
     */
    mode?: NavigationMode;
    /**
     * Enables selection.
     * @default false
     */
    selectable?: boolean;
    /**
     * Enables the simultaneous selection of multiple items.
     * @default false
     */
    multiSelect?: boolean;
    /**
     * The selected nodes' ids.
     *
     * When `multiSelect` is true this takes an array of strings; when false (default) a string.
     */
    selected?: string[] | string;
    /**
     * When uncontrolled, defines the initial selected nodes' ids.
     *
     * When `multiSelect` is true this takes an array of strings; when false (default) a string.
     * @default []
     */
    defaultSelected?: string[] | string;
    /**
     * Can non-leaf nodes be collapsed / expanded.
     */
    collapsible?: boolean;
    /**
     * Callback fired when a tree item is selected.
     *
     * @param {object} event The event source of the callback.
     * @param {string} nodeId The id of the selected node.
     */
    onChange?: any;
    /**
     * Expanded nodes' ids.
     */
    expanded?: string[];
    /**
     * When uncontrolled, defines the initial expanded nodes' ids.
     * @default []
     */
    defaultExpanded?: string[];
    /**
     * Callback fired when tree items are expanded/collapsed.
     *
     * @param {object} event The event source of the callback.
     * @param {array} nodeIds The ids of the expanded nodes (old and new).
     */
    onToggle?: (event: any, nodeIds: any) => void;
    /**
     * If `true`, will allow focus on disabled items.
     * @default false
     */
    disabledItemsFocusable?: boolean;
    /**
     * @ignore
     */
    onFocus?: (event: React.FocusEvent<any>) => void;
    /**
     * @ignore
     */
    onBlur?: (event: any) => void;
    /**
     * @ignore
     */
    onKeyDown?: (event: KeyboardEvent) => void;
    /**
     * The content of the component.
     */
    children?: React.ReactNode;
}

export declare type HvVerticalScrollListItemClasses = ExtractNames<typeof useClasses_107>;

/**
 * Provides the user with a descriptive text, signaling an error, for when the form element is in an invalid state.
 */
export declare const HvWarningText: (props: HvWarningTextProps) => JSX_2.Element;

export declare type HvWarningTextClasses = ExtractNames<typeof useClasses_10>;

export declare interface HvWarningTextProps extends HvBaseProps {
    /** Icon to be rendered alongside the warning text. */
    adornment?: React.ReactNode;
    /** If `true` the text is not rendered. */
    isVisible?: boolean;
    /** If `true` the text is disabled. */
    disabled?: boolean;
    /** If `true` the text won't include a gutter. */
    disableGutter?: boolean;
    /** If `true` the text won't include the top border. */
    disableBorder?: boolean;
    /** If `true` the adornment icon isn't shown. */
    disableAdornment?: boolean;
    /** If `true` the text isn't shown. */
    hideText?: boolean;
    /** A Jss Object used to override or extend the styles applied to the component. */
    classes?: HvWarningTextClasses;
}

export declare const iconVariant: (variant: "success" | "warning" | "error" | "info" | "default", color?: IconBaseProps["color"], semantic?: true) => JSX_2.Element | null;

declare type IdType<D> = StringKey<D> | string;

export declare const increaseSize: (size: string) => "L" | "M" | "S" | "XL";

export declare const infoMessageClasses: {
    root: "HvInfoMessage-root";
    gutter: "HvInfoMessage-gutter";
    infoDisabled: "HvInfoMessage-infoDisabled";
};

export declare const inlineEditorClasses: {
    button: "HvInlineEditor-button";
    input: "HvInlineEditor-input";
    text: "HvInlineEditor-text";
    root: "HvInlineEditor-root";
    icon: "HvInlineEditor-icon";
    inputBorderContainer: "HvInlineEditor-inputBorderContainer";
    inputRoot: "HvInlineEditor-inputRoot";
    largeText: "HvInlineEditor-largeText";
    textEmpty: "HvInlineEditor-textEmpty";
    iconVisible: "HvInlineEditor-iconVisible";
};

export declare const inputClasses: {
    input: "HvInput-input";
    label: "HvInput-label";
    root: "HvInput-root";
    icon: "HvInput-icon";
    error: "HvInput-error";
    inputBorderContainer: "HvInput-inputBorderContainer";
    inputRoot: "HvInput-inputRoot";
    inputRootFocused: "HvInput-inputRootFocused";
    inputRootDisabled: "HvInput-inputRootDisabled";
    inputRootMultiline: "HvInput-inputRootMultiline";
    description: "HvInput-description";
    labelContainer: "HvInput-labelContainer";
    adornmentsBox: "HvInput-adornmentsBox";
    adornmentButton: "HvInput-adornmentButton";
    iconClear: "HvInput-iconClear";
    hasSuggestions: "HvInput-hasSuggestions";
    suggestionsContainer: "HvInput-suggestionsContainer";
    suggestionList: "HvInput-suggestionList";
    inputExtension: "HvInput-inputExtension";
};

declare type InputElement = HTMLInputElement | HTMLTextAreaElement;

export declare const isBrowser: (browsers: any) => boolean | null;

export declare const isInvalid: (compareState: HvFormStatus) => boolean;

/** Check whether a keyboard `event` is pressing the `keyCode` key. */
export declare const isKey: (event: any, keyCode: Key) => boolean;

export declare const isOneOfKeys: (event: any, keys: Key[]) => boolean;

export declare const isValid: (compareState: HvFormStatus) => boolean;

declare type Key = keyof typeof keyboardCodes;

/** Map of keys to key `code` @see https://mdn.io/event/code */
declare const keyboardCodes: {
    readonly Backspace: "Backspace";
    readonly Tab: "Tab";
    readonly Enter: "Enter";
    readonly Shift: "ShiftLeft";
    readonly Ctrl: "ControlLeft";
    readonly Alt: "AltLeft";
    readonly Delete: "Delete";
    readonly Esc: "Escape";
    readonly ArrowLeft: "ArrowLeft";
    readonly ArrowUp: "ArrowUp";
    readonly ArrowRight: "ArrowRight";
    readonly ArrowDown: "ArrowDown";
    readonly Space: "Space";
    readonly PageUp: "PageUp";
    readonly PageDown: "PageDown";
    readonly Home: "Home";
    readonly End: "End";
};

export declare const kpiClasses: {
    root: "HvKpi-root";
    visualIndicatorContainer: "HvKpi-visualIndicatorContainer";
    comparisons: "HvKpi-comparisons";
    comparisonContainer: "HvKpi-comparisonContainer";
    comparisonComposition: "HvKpi-comparisonComposition";
    indicatorsContainer: "HvKpi-indicatorsContainer";
    indicatorText: "HvKpi-indicatorText";
    indicatorUnit: "HvKpi-indicatorUnit";
    spacingToTheRight: "HvKpi-spacingToTheRight";
    trendLine: "HvKpi-trendLine";
};

export declare const labelClasses: {
    root: "HvLabel-root";
    labelDisabled: "HvLabel-labelDisabled";
    childGutter: "HvLabel-childGutter";
};

export declare const leftControlClasses: {
    root: "HvLeftControl-root";
};

export declare const linkClasses: {
    a: "HvLink-a";
};

export declare const listClasses: {
    link: "HvList-link";
    root: "HvList-root";
    item: "HvList-item";
    virtualizedRoot: "HvList-virtualizedRoot";
    selectorRoot: "HvList-selectorRoot";
    selectorContainer: "HvList-selectorContainer";
    box: "HvList-box";
    truncate: "HvList-truncate";
    itemSelector: "HvList-itemSelector";
    selectAllSelector: "HvList-selectAllSelector";
};

export declare const listContainerClasses: {
    root: "HvListContainer-root";
};

export declare const listItemClasses: {
    root: "HvListItem-root";
    condensed: "HvListItem-condensed";
    disabled: "HvListItem-disabled";
    selected: "HvListItem-selected";
    focus: "HvListItem-focus";
    interactive: "HvListItem-interactive";
    endAdornment: "HvListItem-endAdornment";
    startAdornment: "HvListItem-startAdornment";
    gutters: "HvListItem-gutters";
    withStartAdornment: "HvListItem-withStartAdornment";
    withEndAdornment: "HvListItem-withEndAdornment";
};

export declare const loadingClasses: {
    hidden: "HvLoading-hidden";
    small: "HvLoading-small";
    label: "HvLoading-label";
    root: "HvLoading-root";
    overlay: "HvLoading-overlay";
    blur: "HvLoading-blur";
    barContainer: "HvLoading-barContainer";
    loadingBar: "HvLoading-loadingBar";
    regular: "HvLoading-regular";
    smallColor: "HvLoading-smallColor";
    regularColor: "HvLoading-regularColor";
};

export declare const loginClasses: {
    root: "HvLogin-root";
    formContainer: "HvLogin-formContainer";
};

export declare const multiButtonClasses: {
    button: "HvMultiButton-button";
    root: "HvMultiButton-root";
    vertical: "HvMultiButton-vertical";
    selected: "HvMultiButton-selected";
};

export declare const multiSelectionEventHandler: (evt: any, index: any, selectionAnchor: any, allValues: any, selectedState: any, selectionCheck: any) => any[];

export declare type NavigationData<T extends React.ElementType = "a"> = ComponentProps<T> & Record<string, any> & {
    /** The id to be applied to the root element. */
    id: string;
    /** The label to be rendered on the menu item. */
    label: string;
    /** The icon to be rendered. */
    icon?: React.ReactNode;
    /** The Data children subset. */
    data?: NavigationData<T>[];
    /** Whether the item is disabled and not interactive. */
    disabled?: boolean;
    /** Whether the item has a selected state. */
    selectable?: boolean;
};

export declare type NavigationMode = "treeview" | "navigation" | "slider";

export declare const normalizeProgressBar: (value: number, max: number) => number;

declare interface NumericRange {
    from: number | string;
    to: number | string;
}

export declare const outlineStyles: {
    outlineColor: string;
    outlineStyle: string;
    outlineWidth: string;
    outlineOffset: string;
    boxShadow: string;
};

export declare const overflowTooltipClasses: {
    tooltipData: "HvOverflowTooltip-tooltipData";
    tooltipAnchor: "HvOverflowTooltip-tooltipAnchor";
    tooltipAnchorParagraph: "HvOverflowTooltip-tooltipAnchorParagraph";
};

export declare const paginationClasses: {
    root: "HvPagination-root";
    icon: "HvPagination-icon";
    pageSizeOptions: "HvPagination-pageSizeOptions";
    iconContainer: "HvPagination-iconContainer";
    pageSizeTextContainer: "HvPagination-pageSizeTextContainer";
    pageSizeOptionsSelect: "HvPagination-pageSizeOptionsSelect";
    pageNavigator: "HvPagination-pageNavigator";
    pageInfo: "HvPagination-pageInfo";
    pageJump: "HvPagination-pageJump";
    pageSizeInput: "HvPagination-pageSizeInput";
    pageSizeInputRoot: "HvPagination-pageSizeInputRoot";
    pageSizeInputContainer: "HvPagination-pageSizeInputContainer";
};

export declare const panelClasses: {
    root: "HvPanel-root";
};

declare type PolymorphicComponent<C extends React.ElementType, Props = {}> = React.PropsWithChildren<Props & AsProp<C>> & Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>;

export declare type PolymorphicComponentRef<C extends React.ElementType, Props = {}> = PolymorphicComponent<C, Props> & {
    ref?: PolymorphicRef<C>;
};

export declare type PolymorphicRef<C extends React.ElementType> = React.ComponentPropsWithRef<C>["ref"];

export declare function prepareRow(row: any, { instance }: {
    instance: any;
}): void;

/**
 * Process the themes provided to the HvProvider:
 *  - Cleans themes with the same name
 *  - Returns the default if the list is empty (ds5)
 */
export declare const processThemes: (themesList?: (HvTheme | HvThemeStructure)[]) => (HvTheme | HvThemeStructure)[];

export declare const progressBarClasses: {
    progress: "HvProgressBar-progress";
    root: "HvProgressBar-root";
    progressBar: "HvProgressBar-progressBar";
    progressBarLabel: "HvProgressBar-progressBarLabel";
    progressContainer: "HvProgressBar-progressContainer";
    progressDone: "HvProgressBar-progressDone";
    progressBarContainer: "HvProgressBar-progressBarContainer";
    progressError: "HvProgressBar-progressError";
};

declare type PropsToOmit<C extends React.ElementType, P> = keyof (AsProp<C> & P);

declare interface Query {
    id?: number;
    combinator: string;
    rules: Array<QueryRule>;
}

export declare const queryBuilderClasses: {
    root: "HvQueryBuilder-root";
    removeButton: "HvQueryBuilder-removeButton";
    topGroup: "HvQueryBuilder-topGroup";
    subGroup: "HvQueryBuilder-subGroup";
    combinator: "HvQueryBuilder-combinator";
    topCombinator: "HvQueryBuilder-topCombinator";
    combinatorButton: "HvQueryBuilder-combinatorButton";
    topRemoveButton: "HvQueryBuilder-topRemoveButton";
    topRemoveButtonDisabled: "HvQueryBuilder-topRemoveButtonDisabled";
    rulesContainer: "HvQueryBuilder-rulesContainer";
    subRulesContainer: "HvQueryBuilder-subRulesContainer";
    actionButtonContainer: "HvQueryBuilder-actionButtonContainer";
    topActionButtonContainer: "HvQueryBuilder-topActionButtonContainer";
    topRulesContainer: "HvQueryBuilder-topRulesContainer";
    buttonBackground: "HvQueryBuilder-buttonBackground";
};

declare interface QueryBuilderLabels {
    query?: {
        delete?: {
            ariaLabel: string;
            tooltip?: string;
        } & DialogLabels;
        addRule?: {
            label: string;
        };
        addGroup?: {
            label: string;
        };
    };
    rule: {
        attribute: {
            exists: string;
            label: string;
            placeholder: string;
        };
        operator: {
            label: string;
            placeholder: string;
        };
        value: {
            distance: {
                label: string;
                placeholder?: string;
                connectorText: string;
                button: string;
                validation: {
                    required: string;
                    invalid: string;
                };
            };
            text: {
                label: string;
                placeholder: string;
                validation: {
                    required: string;
                };
            };
            boolean: {
                label: string;
                placeholder: string;
                options: Record<string, string>;
            };
            numeric: {
                label: string;
                placeholder: string;
                validation: {
                    required: string;
                    invalid: string;
                    equal: string;
                    greaterThan: string;
                };
                range: {
                    leftLabel: string;
                    rightLabel: string;
                };
            };
            datetime: {
                dateLabel: string;
                datePlaceholder: string;
                timeLabel: string;
                timePlaceholder: string;
                startDateLabel: string;
                startDatePlaceholder: string;
                startTimeLabel: string;
                startTimePlaceholder: string;
                endDateLabel: string;
                endDatePlaceholder: string;
                endTimeLabel: string;
                endTimePlaceholder: string;
                validation: {
                    required: string;
                    invalidInterval: string;
                };
            };
        };
        delete: {
            ariaLabel: string;
            tooltip?: string;
        } & DialogLabels;
    };
    group: {
        delete: {
            ariaLabel: string;
            tooltip?: string;
        } & DialogLabels;
        reset: {
            ariaLabel: string;
            tooltip?: string;
        } & DialogLabels;
        addRule: {
            label: string;
        };
        addGroup: {
            label: string;
        };
    };
    empty: {
        title: string;
        createCondition: string;
        createGroup: string;
        spacer: string;
    };
}

declare interface QueryCombinator {
    operand: string;
    label: string;
}

declare interface QueryOperator {
    operator: string;
    label: string;
    combinators: string[];
}

declare interface QueryRule {
    id?: number | string;
    attribute?: string;
    operator?: string;
    value?: QueryRuleValue;
}

declare type QueryRuleValue = string | number | boolean | NumericRange | DateTimeStrings | DateTimeRange;

export declare const radioClasses: {
    label: "HvRadio-label";
    root: "HvRadio-root";
    container: "HvRadio-container";
    radio: "HvRadio-radio";
    disabled: "HvRadio-disabled";
    focusVisible: "HvRadio-focusVisible";
    invalidContainer: "HvRadio-invalidContainer";
    invalidRadio: "HvRadio-invalidRadio";
};

export declare const radioGroupClasses: {
    label: "HvRadioGroup-label";
    root: "HvRadioGroup-root";
    group: "HvRadioGroup-group";
    horizontal: "HvRadioGroup-horizontal";
    vertical: "HvRadioGroup-vertical";
    error: "HvRadioGroup-error";
    invalid: "HvRadioGroup-invalid";
};

export declare class Random {
    i: number;
    max: number;
    min: number;
    constructor(seed?: number, max?: number, min?: number);
    next(max?: number, min?: number): number;
}

export declare function reducer(state: any, action: any, previousState: any, instance: any): any;

/** Given a `stylesObj`, replaces its keys' `$myClass` with `.{name}-myClass`. */
export declare const replace$: <T extends object>(stylesObj: T, name: string) => T;

export declare const rightControlClasses: {
    root: "HvRightControl-root";
    sortDropdown: "HvRightControl-sortDropdown";
};

export declare const scrollToHorizontalClasses: {
    root: "HvScrollToHorizontal-root";
    selected: "HvScrollToHorizontal-selected";
    positionSticky: "HvScrollToHorizontal-positionSticky";
    positionFixed: "HvScrollToHorizontal-positionFixed";
    notSelectedRoot: "HvScrollToHorizontal-notSelectedRoot";
    notSelected: "HvScrollToHorizontal-notSelected";
};

export declare const scrollToVerticalClasses: {
    root: "HvScrollToVertical-root";
    positionFixed: "HvScrollToVertical-positionFixed";
    positionAbsolute: "HvScrollToVertical-positionAbsolute";
};

export declare const selectionListClasses: {
    label: "HvSelectionList-label";
    root: "HvSelectionList-root";
    listbox: "HvSelectionList-listbox";
    horizontal: "HvSelectionList-horizontal";
    vertical: "HvSelectionList-vertical";
    error: "HvSelectionList-error";
    invalid: "HvSelectionList-invalid";
    description: "HvSelectionList-description";
};

/**
 * Sets the element attributes and style for a theme and color mode.
 */
export declare const setElementAttrs: (themeName: string, modeName: string, colorScheme: string, themeRootId?: string) => void;

export declare const setId: (...args: any[]) => string | undefined;

export declare const setUid: (id: any, suffix: any) => string | undefined;

export declare const simpleGridClasses: {
    root: "HvSimpleGrid-root";
};

export declare const sliderClasses: {
    label: "HvSlider-label";
    root: "HvSlider-root";
    error: "HvSlider-error";
    rootDisabled: "HvSlider-rootDisabled";
    labelContainer: "HvSlider-labelContainer";
    sliderBase: "HvSlider-sliderBase";
    sliderContainer: "HvSlider-sliderContainer";
    trackDragging: "HvSlider-trackDragging";
    trackStandBy: "HvSlider-trackStandBy";
    sliderRoot: "HvSlider-sliderRoot";
    rootRange: "HvSlider-rootRange";
    handleContainer: "HvSlider-handleContainer";
    handle: "HvSlider-handle";
    handleContainerDisabled: "HvSlider-handleContainerDisabled";
    handleHiddenContainer: "HvSlider-handleHiddenContainer";
    labelIncluded: "HvSlider-labelIncluded";
    onlyInput: "HvSlider-onlyInput";
    sliderTooltip: "HvSlider-sliderTooltip";
};

export declare const snackbarClasses: {
    root: "HvSnackbar-root";
    anchorOriginTopCenter: "HvSnackbar-anchorOriginTopCenter";
    anchorOriginBottomCenter: "HvSnackbar-anchorOriginBottomCenter";
    anchorOriginTopRight: "HvSnackbar-anchorOriginTopRight";
    anchorOriginBottomRight: "HvSnackbar-anchorOriginBottomRight";
    anchorOriginTopLeft: "HvSnackbar-anchorOriginTopLeft";
    anchorOriginBottomLeft: "HvSnackbar-anchorOriginBottomLeft";
};

export declare const snackbarContentClasses: {
    root: "HvSnackbar-Content-root";
    default: "HvSnackbar-Content-default";
    warning: "HvSnackbar-Content-warning";
    action: "HvSnackbar-Content-action";
    error: "HvSnackbar-Content-error";
    success: "HvSnackbar-Content-success";
    message: "HvSnackbar-Content-message";
    messageSpan: "HvSnackbar-Content-messageSpan";
    messageText: "HvSnackbar-Content-messageText";
    iconVariant: "HvSnackbar-Content-iconVariant";
};

export declare const snackbarProviderClasses: {
    snackItemRoot: "HvSnackbarProvider-snackItemRoot";
};

export declare type Spacing = "sm" | "md" | "lg" | "xl";

export declare const stackClasses: {
    root: "HvStack-root";
    row: "HvStack-row";
    column: "HvStack-column";
    xs: "HvStack-xs";
    sm: "HvStack-sm";
    md: "HvStack-md";
    lg: "HvStack-lg";
    xl: "HvStack-xl";
};

declare type StringKey<D> = Extract<keyof D, string>;

export declare const suggestionsClasses: {
    root: "HvSuggestions-root";
    popper: "HvSuggestions-popper";
    list: "HvSuggestions-list";
};

export declare const switchClasses: {
    label: "HvSwitch-label";
    root: "HvSwitch-root";
    error: "HvSwitch-error";
    switchContainer: "HvSwitch-switchContainer";
    invalidSwitch: "HvSwitch-invalidSwitch";
};

declare type SxProps = React.CSSProperties | ((theme: HvTheme_2) => React.CSSProperties);

export declare const tabClasses: {
    root: "HvTab-root";
    disabled: "HvTab-disabled";
    selected: "HvTab-selected";
    focusVisible: "HvTab-focusVisible";
};

export declare const tableBodyClasses: {
    root: "HvTableBody-root";
};

export declare const tableCellClasses: {
    body: "HvTableCell-body";
    footer: "HvTableCell-footer";
    head: "HvTableCell-head";
    root: "HvTableCell-root";
    resizable: "HvTableCell-resizable";
    sorted: "HvTableCell-sorted";
    stickyColumn: "HvTableCell-stickyColumn";
    stickyColumnMostLeft: "HvTableCell-stickyColumnMostLeft";
    stickyColumnLeastRight: "HvTableCell-stickyColumnLeastRight";
    groupColumnMostLeft: "HvTableCell-groupColumnMostLeft";
    groupColumnMostRight: "HvTableCell-groupColumnMostRight";
    resizing: "HvTableCell-resizing";
    alignLeft: "HvTableCell-alignLeft";
    alignCenter: "HvTableCell-alignCenter";
    alignRight: "HvTableCell-alignRight";
    alignJustify: "HvTableCell-alignJustify";
    variantNone: "HvTableCell-variantNone";
    variantCheckbox: "HvTableCell-variantCheckbox";
    variantActions: "HvTableCell-variantActions";
    variantExpand: "HvTableCell-variantExpand";
    variantList: "HvTableCell-variantList";
    variantListHead: "HvTableCell-variantListHead";
    variantListactions: "HvTableCell-variantListactions";
    variantListcheckbox: "HvTableCell-variantListcheckbox";
};

export declare const tableClasses: {
    root: "HvTable-root";
    stickyHeader: "HvTable-stickyHeader";
    stickyColumns: "HvTable-stickyColumns";
    listRow: "HvTable-listRow";
};

export declare const tableContainerClasses: {
    root: "HvTableContainer-root";
};

export declare const tableHeadClasses: {
    root: "HvTableHead-root";
    stickyHeader: "HvTableHead-stickyHeader";
};

export declare const tableHeaderClasses: {
    body: "HvTableHeader-body";
    footer: "HvTableHeader-footer";
    head: "HvTableHeader-head";
    root: "HvTableHeader-root";
    resizer: "HvTableHeader-resizer";
    resizable: "HvTableHeader-resizable";
    sortable: "HvTableHeader-sortable";
    sorted: "HvTableHeader-sorted";
    stickyColumn: "HvTableHeader-stickyColumn";
    stickyColumnMostLeft: "HvTableHeader-stickyColumnMostLeft";
    stickyColumnLeastRight: "HvTableHeader-stickyColumnLeastRight";
    groupColumnMostLeft: "HvTableHeader-groupColumnMostLeft";
    groupColumnMostRight: "HvTableHeader-groupColumnMostRight";
    resizing: "HvTableHeader-resizing";
    alignLeft: "HvTableHeader-alignLeft";
    alignCenter: "HvTableHeader-alignCenter";
    alignRight: "HvTableHeader-alignRight";
    alignJustify: "HvTableHeader-alignJustify";
    variantNone: "HvTableHeader-variantNone";
    variantCheckbox: "HvTableHeader-variantCheckbox";
    variantActions: "HvTableHeader-variantActions";
    variantExpand: "HvTableHeader-variantExpand";
    variantList: "HvTableHeader-variantList";
    headerContent: "HvTableHeader-headerContent";
    headerText: "HvTableHeader-headerText";
    headerParagraph: "HvTableHeader-headerParagraph";
    sortableHeaderText: "HvTableHeader-sortableHeaderText";
    sortButton: "HvTableHeader-sortButton";
    sortIcon: "HvTableHeader-sortIcon";
    alignFlexLeft: "HvTableHeader-alignFlexLeft";
    alignFlexRight: "HvTableHeader-alignFlexRight";
    alignFlexCenter: "HvTableHeader-alignFlexCenter";
    alignFlexJustify: "HvTableHeader-alignFlexJustify";
};

export declare const tableRowClasses: {
    body: "HvTableRow-body";
    footer: "HvTableRow-footer";
    head: "HvTableRow-head";
    root: "HvTableRow-root";
    expanded: "HvTableRow-expanded";
    selected: "HvTableRow-selected";
    hover: "HvTableRow-hover";
    striped: "HvTableRow-striped";
    variantList: "HvTableRow-variantList";
    variantListHead: "HvTableRow-variantListHead";
};

export declare const tabsClasses: {
    root: "HvTabs-root";
    indicator: "HvTabs-indicator";
    scroller: "HvTabs-scroller";
    flexContainer: "HvTabs-flexContainer";
};

export declare const tagClasses: {
    button: "HvTag-button";
    label: "HvTag-label";
    root: "HvTag-root";
    disabled: "HvTag-disabled";
    focusVisible: "HvTag-focusVisible";
    chipRoot: "HvTag-chipRoot";
    clickable: "HvTag-clickable";
    categorical: "HvTag-categorical";
    deleteIcon: "HvTag-deleteIcon";
    tagButton: "HvTag-tagButton";
    disabledDeleteIcon: "HvTag-disabledDeleteIcon";
    categoricalFocus: "HvTag-categoricalFocus";
    categoricalDisabled: "HvTag-categoricalDisabled";
};

export declare const tagsInputClasses: {
    input: "HvTagsInput-input";
    label: "HvTagsInput-label";
    root: "HvTagsInput-root";
    disabled: "HvTagsInput-disabled";
    readOnly: "HvTagsInput-readOnly";
    error: "HvTagsInput-error";
    invalid: "HvTagsInput-invalid";
    resizable: "HvTagsInput-resizable";
    description: "HvTagsInput-description";
    labelContainer: "HvTagsInput-labelContainer";
    suggestionsContainer: "HvTagsInput-suggestionsContainer";
    suggestionList: "HvTagsInput-suggestionList";
    inputExtension: "HvTagsInput-inputExtension";
    chipRoot: "HvTagsInput-chipRoot";
    listItemGutters: "HvTagsInput-listItemGutters";
    listItemRoot: "HvTagsInput-listItemRoot";
    characterCounter: "HvTagsInput-characterCounter";
    tagsList: "HvTagsInput-tagsList";
    tagInputContainerRoot: "HvTagsInput-tagInputContainerRoot";
    tagInputRoot: "HvTagsInput-tagInputRoot";
    tagSelected: "HvTagsInput-tagSelected";
    tagInputBorderContainer: "HvTagsInput-tagInputBorderContainer";
    tagInputRootFocused: "HvTagsInput-tagInputRootFocused";
    tagInputRootEmpty: "HvTagsInput-tagInputRootEmpty";
    singleLine: "HvTagsInput-singleLine";
};

export declare const textAreaClasses: {
    input: "HvTextArea-input";
    label: "HvTextArea-label";
    root: "HvTextArea-root";
    disabled: "HvTextArea-disabled";
    baseInput: "HvTextArea-baseInput";
    error: "HvTextArea-error";
    invalid: "HvTextArea-invalid";
    resizable: "HvTextArea-resizable";
    inputResizable: "HvTextArea-inputResizable";
    description: "HvTextArea-description";
    labelContainer: "HvTextArea-labelContainer";
    characterCounter: "HvTextArea-characterCounter";
};

export { theme }

export { themes }

export declare const timeAgoClasses: {
    root: "HvTimeAgo-root";
};

export declare type TimeFormat = "12" | "24";

export declare const timePickerClasses: {
    placeholder: "HvTimePicker-placeholder";
    label: "HvTimePicker-label";
    root: "HvTimePicker-root";
    icon: "HvTimePicker-icon";
    error: "HvTimePicker-error";
    description: "HvTimePicker-description";
    labelContainer: "HvTimePicker-labelContainer";
    dropdownHeaderInvalid: "HvTimePicker-dropdownHeaderInvalid";
    dropdownHeaderOpen: "HvTimePicker-dropdownHeaderOpen";
    dropdownHeader: "HvTimePicker-dropdownHeader";
    placeholderDisabled: "HvTimePicker-placeholderDisabled";
    dropdownPanel: "HvTimePicker-dropdownPanel";
    timePopperContainer: "HvTimePicker-timePopperContainer";
};

export declare const tooltipClasses: {
    title: "HvTooltip-title";
    color: "HvTooltip-color";
    root: "HvTooltip-root";
    tooltip: "HvTooltip-tooltip";
    tooltipMulti: "HvTooltip-tooltipMulti";
    popper: "HvTooltip-popper";
    valuesContainer: "HvTooltip-valuesContainer";
    values: "HvTooltip-values";
    separatorColor: "HvTooltip-separatorColor";
    separator: "HvTooltip-separator";
    valueWrapper: "HvTooltip-valueWrapper";
};

export declare const treeViewClasses: {
    root: "HvVerticalNavigationTreeView-root";
};

export declare const treeViewItemClasses: {
    content: "HvVerticalNavigationTreeViewItem-content";
    unselectable: "HvVerticalNavigationTreeViewItem-unselectable";
    link: "HvVerticalNavigationTreeViewItem-link";
    label: "HvVerticalNavigationTreeViewItem-label";
    group: "HvVerticalNavigationTreeViewItem-group";
    hide: "HvVerticalNavigationTreeViewItem-hide";
    expanded: "HvVerticalNavigationTreeViewItem-expanded";
    disabled: "HvVerticalNavigationTreeViewItem-disabled";
    selected: "HvVerticalNavigationTreeViewItem-selected";
    node: "HvVerticalNavigationTreeViewItem-node";
    focused: "HvVerticalNavigationTreeViewItem-focused";
    selectable: "HvVerticalNavigationTreeViewItem-selectable";
    labelIcon: "HvVerticalNavigationTreeViewItem-labelIcon";
    collapsed: "HvVerticalNavigationTreeViewItem-collapsed";
    minimized: "HvVerticalNavigationTreeViewItem-minimized";
    expandable: "HvVerticalNavigationTreeViewItem-expandable";
    unselected: "HvVerticalNavigationTreeViewItem-unselected";
    labelExpandable: "HvVerticalNavigationTreeViewItem-labelExpandable";
};

export declare const typographyClasses: {
    link: "HvTypography-link";
    body: "HvTypography-body";
    label: "HvTypography-label";
    root: "HvTypography-root";
    display: "HvTypography-display";
    disabled: "HvTypography-disabled";
    noWrap: "HvTypography-noWrap";
    title1: "HvTypography-title1";
    title2: "HvTypography-title2";
    title3: "HvTypography-title3";
    title4: "HvTypography-title4";
    caption1: "HvTypography-caption1";
    caption2: "HvTypography-caption2";
    "5xlTitle": "HvTypography-5xlTitle";
    "4xlTitle": "HvTypography-4xlTitle";
    "3xlTitle": "HvTypography-3xlTitle";
    xxlTitle: "HvTypography-xxlTitle";
    xlTitle: "HvTypography-xlTitle";
    lTitle: "HvTypography-lTitle";
    mTitle: "HvTypography-mTitle";
    sTitle: "HvTypography-sTitle";
    xsTitle: "HvTypography-xsTitle";
    xxsTitle: "HvTypography-xxsTitle";
    sectionTitle: "HvTypography-sectionTitle";
    highlightText: "HvTypography-highlightText";
    normalText: "HvTypography-normalText";
    placeholderText: "HvTypography-placeholderText";
    disabledText: "HvTypography-disabledText";
    selectedNavText: "HvTypography-selectedNavText";
    vizText: "HvTypography-vizText";
    vizTextDisabled: "HvTypography-vizTextDisabled";
    xsInlineLink: "HvTypography-xsInlineLink";
    isLink: "HvTypography-isLink";
};

export declare const typographyVariants: readonly ["display", "title1", "title2", "title3", "title4", "body", "label", "caption1", "caption2"];

export declare type UseBulkActionsProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

declare const useClasses: (classesProp?: Partial<Record<"link" | "body" | "label" | "root" | "display" | "disabled" | "noWrap" | "title1" | "title2" | "title3" | "title4" | "caption1" | "caption2" | "5xlTitle" | "4xlTitle" | "3xlTitle" | "xxlTitle" | "xlTitle" | "lTitle" | "mTitle" | "sTitle" | "xsTitle" | "xxsTitle" | "sectionTitle" | "highlightText" | "normalText" | "placeholderText" | "disabledText" | "selectedNavText" | "vizText" | "vizTextDisabled" | "xsInlineLink" | "isLink", string>>, addStatic?: boolean) => {
    classes: {
        link: string;
        body: string;
        label: string;
        root: string;
        display: string;
        disabled: string;
        noWrap: string;
        title1: string;
        title2: string;
        title3: string;
        title4: string;
        caption1: string;
        caption2: string;
        "5xlTitle": string;
        "4xlTitle": string;
        "3xlTitle": string;
        xxlTitle: string;
        xlTitle: string;
        lTitle: string;
        mTitle: string;
        sTitle: string;
        xsTitle: string;
        xxsTitle: string;
        sectionTitle: string;
        highlightText: string;
        normalText: string;
        placeholderText: string;
        disabledText: string;
        selectedNavText: string;
        vizText: string;
        vizTextDisabled: string;
        xsInlineLink: string;
        isLink: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_10: (classesProp?: Partial<Record<"root" | "show" | "hideText" | "defaultIcon" | "warningText" | "topGutter" | "topBorder", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        show: string;
        hideText: string;
        defaultIcon: string;
        warningText: string;
        topGutter: string;
        topBorder: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_100: (classesProp?: Partial<Record<"root" | "listItemSelected" | "listItemFocus", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        listItemSelected: string;
        listItemFocus: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_101: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_102: (classesProp?: Partial<Record<"content" | "unselectable" | "link" | "label" | "group" | "hide" | "expanded" | "disabled" | "selected" | "node" | "focused" | "selectable" | "labelIcon" | "collapsed" | "minimized" | "expandable" | "unselected" | "labelExpandable", string>>, addStatic?: boolean) => {
    classes: {
        content: string;
        unselectable: string;
        link: string;
        label: string;
        group: string;
        hide: string;
        expanded: string;
        disabled: string;
        selected: string;
        node: string;
        focused: string;
        selectable: string;
        labelIcon: string;
        collapsed: string;
        minimized: string;
        expandable: string;
        unselected: string;
        labelExpandable: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_103: (classesProp?: Partial<Record<"label" | "root" | "error" | "rootDisabled" | "labelContainer" | "sliderBase" | "sliderContainer" | "trackDragging" | "trackStandBy" | "sliderRoot" | "rootRange" | "handleContainer" | "handle" | "handleContainerDisabled" | "handleHiddenContainer" | "labelIncluded" | "onlyInput" | "sliderTooltip", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        error: string;
        rootDisabled: string;
        labelContainer: string;
        sliderBase: string;
        sliderContainer: string;
        trackDragging: string;
        trackStandBy: string;
        sliderRoot: string;
        rootRange: string;
        handleContainer: string;
        handle: string;
        handleContainerDisabled: string;
        handleHiddenContainer: string;
        labelIncluded: string;
        onlyInput: string;
        sliderTooltip: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_104: (classesProp?: Partial<Record<"label" | "root" | "error" | "description" | "labelContainer", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        error: string;
        description: string;
        labelContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_105: (classesProp?: Partial<Record<"header" | "root" | "space" | "actionBar" | "dropdown" | "panel" | "baseDropdownSelection" | "rightSidePanel" | "leftSidePanel" | "applyButton", string>>, addStatic?: boolean) => {
    classes: {
        header: string;
        root: string;
        space: string;
        actionBar: string;
        dropdown: string;
        panel: string;
        baseDropdownSelection: string;
        rightSidePanel: string;
        leftSidePanel: string;
        applyButton: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_106: (classesProp?: Partial<Record<"label" | "root" | "icon" | "dropdown" | "action" | "error" | "actionContainer" | "panel" | "description" | "labelContainer" | "leftContainer" | "rightContainer" | "dropdownHeaderInvalid" | "dropdownHeaderOpen", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        icon: string;
        dropdown: string;
        action: string;
        error: string;
        actionContainer: string;
        panel: string;
        description: string;
        labelContainer: string;
        leftContainer: string;
        rightContainer: string;
        dropdownHeaderInvalid: string;
        dropdownHeaderOpen: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_107: (classesProp?: Partial<Record<"button" | "text" | "root" | "notSelected", string>>, addStatic?: boolean) => {
    classes: {
        button: string;
        text: string;
        root: string;
        notSelected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_108: (classesProp?: Partial<Record<"root" | "positionFixed" | "positionAbsolute", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        positionFixed: string;
        positionAbsolute: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_109: (classesProp?: Partial<Record<"button" | "text" | "root" | "selected", string>>, addStatic?: boolean) => {
    classes: {
        button: string;
        text: string;
        root: string;
        selected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_11: (classesProp?: Partial<Record<"label" | "root" | "listbox" | "horizontal" | "vertical" | "error" | "invalid" | "description", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        listbox: string;
        horizontal: string;
        vertical: string;
        error: string;
        invalid: string;
        description: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_110: (classesProp?: Partial<Record<"root" | "selected" | "positionSticky" | "positionFixed" | "notSelectedRoot" | "notSelected", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        selected: string;
        positionSticky: string;
        positionFixed: string;
        notSelectedRoot: string;
        notSelected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_111: (classesProp?: Partial<Record<"button" | "input" | "text" | "root" | "icon" | "inputBorderContainer" | "inputRoot" | "largeText" | "textEmpty" | "iconVisible", string>>, addStatic?: boolean) => {
    classes: {
        button: string;
        input: string;
        text: string;
        root: string;
        icon: string;
        inputBorderContainer: string;
        inputRoot: string;
        largeText: string;
        textEmpty: string;
        iconVisible: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_112: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_113: (classesProp?: Partial<Record<"root" | "removeButton" | "topGroup" | "subGroup" | "combinator" | "topCombinator" | "combinatorButton" | "topRemoveButton" | "topRemoveButtonDisabled" | "rulesContainer" | "subRulesContainer" | "actionButtonContainer" | "topActionButtonContainer" | "topRulesContainer" | "buttonBackground", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        removeButton: string;
        topGroup: string;
        subGroup: string;
        combinator: string;
        topCombinator: string;
        combinatorButton: string;
        topRemoveButton: string;
        topRemoveButtonDisabled: string;
        rulesContainer: string;
        subRulesContainer: string;
        actionButtonContainer: string;
        topActionButtonContainer: string;
        topRulesContainer: string;
        buttonBackground: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_114: (classesProp?: Partial<Record<"label" | "root" | "colorPicker" | "panel" | "description" | "labelContainer" | "headerColorValue" | "headerColorIcon" | "colorPickerIcon" | "recommendedColorsRoot" | "dropdownRootIconOnly" | "headerColorIconOnly" | "pickerFields", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        colorPicker: string;
        panel: string;
        description: string;
        labelContainer: string;
        headerColorValue: string;
        headerColorIcon: string;
        colorPickerIcon: string;
        recommendedColorsRoot: string;
        dropdownRootIconOnly: string;
        headerColorIconOnly: string;
        pickerFields: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_115: (classesProp?: Partial<Record<"title" | "main" | "root" | "dot" | "controls" | "xs" | "actions" | "panel" | "fullscreen" | "closeButton" | "mainContainer" | "pageCounter" | "mainXs" | "mainFullscreen" | "counterContainer" | "counter" | "slideControls" | "slidesViewport" | "slidesContainer" | "dots" | "dotsXs" | "dotSelected" | "thumbnail" | "thumbnailSelected", string>>, addStatic?: boolean) => {
    classes: {
        title: string;
        main: string;
        root: string;
        dot: string;
        controls: string;
        xs: string;
        actions: string;
        panel: string;
        fullscreen: string;
        closeButton: string;
        mainContainer: string;
        pageCounter: string;
        mainXs: string;
        mainFullscreen: string;
        counterContainer: string;
        counter: string;
        slideControls: string;
        slidesViewport: string;
        slidesContainer: string;
        dots: string;
        dotsXs: string;
        dotSelected: string;
        thumbnail: string;
        thumbnailSelected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_116: (classesProp?: Partial<Record<"image" | "slide", string>>, addStatic?: boolean) => {
    classes: {
        image: string;
        slide: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_117: (classesProp?: Partial<Record<"placeholder" | "label" | "root" | "icon" | "error" | "description" | "labelContainer" | "dropdownHeaderInvalid" | "dropdownHeaderOpen" | "dropdownHeader" | "placeholderDisabled" | "dropdownPanel" | "timePopperContainer", string>>, addStatic?: boolean) => {
    classes: {
        placeholder: string;
        label: string;
        root: string;
        icon: string;
        error: string;
        description: string;
        labelContainer: string;
        dropdownHeaderInvalid: string;
        dropdownHeaderOpen: string;
        dropdownHeader: string;
        placeholderDisabled: string;
        dropdownPanel: string;
        timePopperContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_12: (classesProp?: Partial<Record<"root" | "popper" | "list", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        popper: string;
        list: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_13: (classesProp?: Partial<Record<"input" | "root" | "disabled" | "readOnly" | "invalid" | "resizable" | "inputBorderContainer" | "inputRootInvalid" | "inputRootReadOnly" | "inputRoot" | "inputRootFocused" | "inputRootDisabled" | "inputRootMultiline" | "inputDisabled" | "inputReadOnly" | "inputResizable", string>>, addStatic?: boolean) => {
    classes: {
        input: string;
        root: string;
        disabled: string;
        readOnly: string;
        invalid: string;
        resizable: string;
        inputBorderContainer: string;
        inputRootInvalid: string;
        inputRootReadOnly: string;
        inputRoot: string;
        inputRootFocused: string;
        inputRootDisabled: string;
        inputRootMultiline: string;
        inputDisabled: string;
        inputReadOnly: string;
        inputResizable: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_14: (classesProp?: Partial<Record<"placeholder" | "arrow" | "anchor" | "header" | "root" | "container" | "rootDisabled" | "headerOpen" | "headerOpenUp" | "headerOpenDown" | "headerDisabled" | "headerReadOnly" | "arrowContainer" | "selection" | "selectionDisabled" | "panel" | "panelOpenedUp" | "panelOpenedDown" | "inputExtensionOpen" | "inputExtensionLeftPosition" | "inputExtensionOpenShadow" | "inputExtensionFloatRight" | "inputExtensionFloatLeft", string>>, addStatic?: boolean) => {
    classes: {
        placeholder: string;
        arrow: string;
        anchor: string;
        header: string;
        root: string;
        container: string;
        rootDisabled: string;
        headerOpen: string;
        headerOpenUp: string;
        headerOpenDown: string;
        headerDisabled: string;
        headerReadOnly: string;
        arrowContainer: string;
        selection: string;
        selectionDisabled: string;
        panel: string;
        panelOpenedUp: string;
        panelOpenedDown: string;
        inputExtensionOpen: string;
        inputExtensionLeftPosition: string;
        inputExtensionOpenShadow: string;
        inputExtensionFloatRight: string;
        inputExtensionFloatLeft: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_15: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_16: (classesProp?: Partial<Record<"hidden" | "label" | "root" | "container" | "disabled", string>>, addStatic?: boolean) => {
    classes: {
        hidden: string;
        label: string;
        root: string;
        container: string;
        disabled: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_17: (classesProp?: Partial<Record<"img" | "root" | "container" | "status" | "square" | "xs" | "sm" | "md" | "lg" | "xl" | "fallback" | "avatar" | "badge" | "circular", string>>, addStatic?: boolean) => {
    classes: {
        img: string;
        root: string;
        container: string;
        status: string;
        square: string;
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
        fallback: string;
        avatar: string;
        badge: string;
        circular: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_18: (classesProp?: Partial<Record<"root" | "badge" | "badgeContainer" | "badgePosition" | "showCount" | "showLabel" | "badgeIcon" | "badgeOneDigit", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        badge: string;
        badgeContainer: string;
        badgePosition: string;
        showCount: string;
        showLabel: string;
        badgeIcon: string;
        badgeOneDigit: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_19: (classesProp?: Partial<Record<"root" | "icon" | "disabled" | "startIcon" | "endIcon" | "focusVisible", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        icon: string;
        disabled: string;
        startIcon: string;
        endIcon: string;
        focusVisible: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_2: (classesProp?: Partial<Record<"root" | "disabled" | "selected" | "focus" | "focused" | "focusDisabled" | "externalReference" | "falseFocus", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        disabled: string;
        selected: string;
        focus: string;
        focused: string;
        focusDisabled: string;
        externalReference: string;
        falseFocus: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_20: (classesProp?: Partial<Record<"root" | "icon" | "selected" | "selectable" | "semanticContainer" | "semanticBar", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        icon: string;
        selected: string;
        selectable: string;
        semanticContainer: string;
        semanticBar: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_21: (classesProp?: Partial<Record<"title" | "content" | "root" | "action" | "titleShort" | "subheader", string>>, addStatic?: boolean) => {
    classes: {
        title: string;
        content: string;
        root: string;
        action: string;
        titleShort: string;
        subheader: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_22: (classesProp?: Partial<Record<"content", string>>, addStatic?: boolean) => {
    classes: {
        content: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_23: (classesProp?: Partial<Record<"root" | "media", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        media: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_24: (classesProp?: Partial<Record<"fixed" | "root" | "disableGutters" | "maxWidthXs" | "maxWidthSm" | "maxWidthMd" | "maxWidthLg" | "maxWidthXl", string>>, addStatic?: boolean) => {
    classes: {
        fixed: string;
        root: string;
        disableGutters: string;
        maxWidthXs: string;
        maxWidthSm: string;
        maxWidthMd: string;
        maxWidthLg: string;
        maxWidthXl: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_25: (classesProp?: Partial<Record<"root" | "fullscreen" | "messageContainer" | "textWithIcon", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        fullscreen: string;
        messageContainer: string;
        textWithIcon: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_26: (classesProp?: Partial<Record<"root" | "textContent", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        textContent: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_27: (classesProp?: Partial<Record<"root" | "spacing" | "fullscreen", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        spacing: string;
        fullscreen: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_28: (classesProp?: Partial<Record<"root" | "background" | "warning" | "error" | "success" | "fullscreen" | "closeButton" | "paper" | "statusBar", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        background: string;
        warning: string;
        error: string;
        success: string;
        fullscreen: string;
        closeButton: string;
        paper: string;
        statusBar: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_29: (classesProp?: Partial<Record<"root" | "background" | "closeButton" | "paper", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        background: string;
        closeButton: string;
        paper: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_3: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_30: (classesProp?: Partial<Record<"root" | "container" | "actionContainer" | "containerMessageOnly" | "iconContainer" | "titleContainer" | "textContainer" | "messageContainer", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        container: string;
        actionContainer: string;
        containerMessageOnly: string;
        iconContainer: string;
        titleContainer: string;
        textContainer: string;
        messageContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_31: (classesProp?: Partial<Record<"small" | "root" | "separator" | "name" | "rightContainer" | "copyright", string>>, addStatic?: boolean) => {
    classes: {
        small: string;
        root: string;
        separator: string;
        name: string;
        rightContainer: string;
        copyright: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_32: (classesProp?: Partial<Record<"root" | "container" | "item" | "zeroMinWidth" | "direction-xs-column" | "direction-xs-reverse" | "direction-xs-row-reverse" | "wrap-xs-nowrap" | "wrap-xs-wrap-reverse" | "spacing-xs-1" | "spacing-xs-2" | "spacing-xs-3" | "spacing-xs-4" | "spacing-xs-5" | "spacing-xs-6" | "spacing-xs-7" | "spacing-xs-8" | "spacing-xs-9" | "spacing-xs-10" | "grid-xs-auto" | "grid-xs-true" | "grid-xs-1" | "grid-xs-2" | "grid-xs-3" | "grid-xs-4" | "grid-xs-5" | "grid-xs-6" | "grid-xs-7" | "grid-xs-8" | "grid-xs-9" | "grid-xs-10" | "grid-xs-11" | "grid-xs-12", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        container: string;
        item: string;
        zeroMinWidth: string;
        "direction-xs-column": string;
        "direction-xs-reverse": string;
        "direction-xs-row-reverse": string;
        "wrap-xs-nowrap": string;
        "wrap-xs-wrap-reverse": string;
        "spacing-xs-1": string;
        "spacing-xs-2": string;
        "spacing-xs-3": string;
        "spacing-xs-4": string;
        "spacing-xs-5": string;
        "spacing-xs-6": string;
        "spacing-xs-7": string;
        "spacing-xs-8": string;
        "spacing-xs-9": string;
        "spacing-xs-10": string;
        "grid-xs-auto": string;
        "grid-xs-true": string;
        "grid-xs-1": string;
        "grid-xs-2": string;
        "grid-xs-3": string;
        "grid-xs-4": string;
        "grid-xs-5": string;
        "grid-xs-6": string;
        "grid-xs-7": string;
        "grid-xs-8": string;
        "grid-xs-9": string;
        "grid-xs-10": string;
        "grid-xs-11": string;
        "grid-xs-12": string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_33: (classesProp?: Partial<Record<"header" | "root" | "backgroundColor", string>>, addStatic?: boolean) => {
    classes: {
        header: string;
        root: string;
        backgroundColor: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_34: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_35: (classesProp?: Partial<Record<"root" | "separator", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        separator: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_36: (classesProp?: Partial<Record<"link" | "button" | "menu" | "root" | "menubar" | "selected", string>>, addStatic?: boolean) => {
    classes: {
        link: string;
        button: string;
        menu: string;
        root: string;
        menubar: string;
        selected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation_2[]): string;
        (...args: CSSInterpolation_2[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_37: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_38: (classesProp?: Partial<Record<"root" | "visualIndicatorContainer" | "comparisons" | "comparisonContainer" | "comparisonComposition" | "indicatorsContainer" | "indicatorText" | "indicatorUnit" | "spacingToTheRight" | "trendLine", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        visualIndicatorContainer: string;
        comparisons: string;
        comparisonContainer: string;
        comparisonComposition: string;
        indicatorsContainer: string;
        indicatorText: string;
        indicatorUnit: string;
        spacingToTheRight: string;
        trendLine: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_39: (classesProp?: Partial<Record<"a", string>>, addStatic?: boolean) => {
    classes: {
        a: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_4: (classesProp?: Partial<Record<"root" | "condensed" | "disabled" | "selected" | "focus" | "interactive" | "endAdornment" | "startAdornment" | "gutters" | "withStartAdornment" | "withEndAdornment", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        condensed: string;
        disabled: string;
        selected: string;
        focus: string;
        interactive: string;
        endAdornment: string;
        startAdornment: string;
        gutters: string;
        withStartAdornment: string;
        withEndAdornment: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_40: (classesProp?: Partial<Record<"hidden" | "small" | "label" | "root" | "overlay" | "blur" | "barContainer" | "loadingBar" | "regular" | "smallColor" | "regularColor", string>>, addStatic?: boolean) => {
    classes: {
        hidden: string;
        small: string;
        label: string;
        root: string;
        overlay: string;
        blur: string;
        barContainer: string;
        loadingBar: string;
        regular: string;
        smallColor: string;
        regularColor: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_41: (classesProp?: Partial<Record<"button" | "root" | "vertical" | "selected", string>>, addStatic?: boolean) => {
    classes: {
        button: string;
        root: string;
        vertical: string;
        selected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_42: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_43: (classesProp?: Partial<Record<"progress" | "root" | "progressBar" | "progressBarLabel" | "progressContainer" | "progressDone" | "progressBarContainer" | "progressError", string>>, addStatic?: boolean) => {
    classes: {
        progress: string;
        root: string;
        progressBar: string;
        progressBarLabel: string;
        progressContainer: string;
        progressDone: string;
        progressBarContainer: string;
        progressError: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_44: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_45: (classesProp?: Partial<Record<"root" | "row" | "column" | "xs" | "sm" | "md" | "lg" | "xl", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        row: string;
        column: string;
        xs: string;
        sm: string;
        md: string;
        lg: string;
        xl: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_46: (classesProp?: Partial<Record<"root" | "disabled" | "selected" | "focusVisible", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        disabled: string;
        selected: string;
        focusVisible: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_47: (classesProp?: Partial<Record<"root" | "indicator" | "scroller" | "flexContainer", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        indicator: string;
        scroller: string;
        flexContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_48: (classesProp?: Partial<Record<"button" | "label" | "root" | "disabled" | "focusVisible" | "chipRoot" | "clickable" | "categorical" | "deleteIcon" | "tagButton" | "disabledDeleteIcon" | "categoricalFocus" | "categoricalDisabled", string>>, addStatic?: boolean) => {
    classes: {
        button: string;
        label: string;
        root: string;
        disabled: string;
        focusVisible: string;
        chipRoot: string;
        clickable: string;
        categorical: string;
        deleteIcon: string;
        tagButton: string;
        disabledDeleteIcon: string;
        categoricalFocus: string;
        categoricalDisabled: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_49: (classesProp?: Partial<Record<"title" | "color" | "root" | "tooltip" | "tooltipMulti" | "popper" | "valuesContainer" | "values" | "separatorColor" | "separator" | "valueWrapper", string>>, addStatic?: boolean) => {
    classes: {
        title: string;
        color: string;
        root: string;
        tooltip: string;
        tooltipMulti: string;
        popper: string;
        valuesContainer: string;
        values: string;
        separatorColor: string;
        separator: string;
        valueWrapper: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_5: (classesProp?: Partial<Record<"root" | "counterDisabled" | "gutter" | "overloaded", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        counterDisabled: string;
        gutter: string;
        overloaded: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_50: (classesProp?: Partial<Record<"tooltipData" | "tooltipAnchor" | "tooltipAnchorParagraph", string>>, addStatic?: boolean) => {
    classes: {
        tooltipData: string;
        tooltipAnchor: string;
        tooltipAnchorParagraph: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_51: (classesProp?: Partial<Record<"root" | "icon" | "disabled" | "focusVisible", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        icon: string;
        disabled: string;
        focusVisible: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_52: (classesProp?: Partial<Record<"root" | "icon" | "disabled" | "focusVisible", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        icon: string;
        disabled: string;
        focusVisible: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_53: (classesProp?: Partial<Record<"title" | "open" | "root" | "single" | "item" | "itemSelected" | "itemDisabled" | "itemTrigger" | "itemIcon" | "itemTitle" | "itemInfoIcon" | "actionsContainer" | "footerContainer" | "closed" | "dual" | "fluid", string>>, addStatic?: boolean) => {
    classes: {
        title: string;
        open: string;
        root: string;
        single: string;
        item: string;
        itemSelected: string;
        itemDisabled: string;
        itemTrigger: string;
        itemIcon: string;
        itemTitle: string;
        itemInfoIcon: string;
        actionsContainer: string;
        footerContainer: string;
        closed: string;
        dual: string;
        fluid: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_54: (classesProp?: Partial<Record<"title" | "root" | "typography" | "icon" | "disabled" | "selected" | "iconUrl" | "iconInfo", string>>, addStatic?: boolean) => {
    classes: {
        title: string;
        root: string;
        typography: string;
        icon: string;
        disabled: string;
        selected: string;
        iconUrl: string;
        iconInfo: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_55: (classesProp?: Partial<Record<"track" | "switch" | "root" | "disabled" | "checked" | "readOnly" | "focusVisible" | "thumb" | "switchBase", string>>, addStatic?: boolean) => {
    classes: {
        track: string;
        switch: string;
        root: string;
        disabled: string;
        checked: string;
        readOnly: string;
        focusVisible: string;
        thumb: string;
        switchBase: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_56: (classesProp?: Partial<Record<"label" | "root" | "container" | "checkbox" | "disabled" | "focusVisible" | "invalidContainer" | "invalidCheckbox", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        container: string;
        checkbox: string;
        disabled: string;
        focusVisible: string;
        invalidContainer: string;
        invalidCheckbox: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_57: (classesProp?: Partial<Record<"input" | "label" | "root" | "icon" | "error" | "inputBorderContainer" | "inputRoot" | "inputRootFocused" | "inputRootDisabled" | "inputRootMultiline" | "description" | "labelContainer" | "adornmentsBox" | "adornmentButton" | "iconClear" | "hasSuggestions" | "suggestionsContainer" | "suggestionList" | "inputExtension", string>>, addStatic?: boolean) => {
    classes: {
        input: string;
        label: string;
        root: string;
        icon: string;
        error: string;
        inputBorderContainer: string;
        inputRoot: string;
        inputRootFocused: string;
        inputRootDisabled: string;
        inputRootMultiline: string;
        description: string;
        labelContainer: string;
        adornmentsBox: string;
        adornmentButton: string;
        iconClear: string;
        hasSuggestions: string;
        suggestionsContainer: string;
        suggestionList: string;
        inputExtension: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_58: (classesProp?: Partial<Record<"label" | "root" | "error" | "switchContainer" | "invalidSwitch", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        error: string;
        switchContainer: string;
        invalidSwitch: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_59: (classesProp?: Partial<Record<"label" | "root" | "container" | "radio" | "disabled" | "focusVisible" | "invalidContainer" | "invalidRadio", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        container: string;
        radio: string;
        disabled: string;
        focusVisible: string;
        invalidContainer: string;
        invalidRadio: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_6: (classesProp?: Partial<Record<"root" | "icon" | "adornment" | "adornmentButton" | "adornmentIcon" | "hideIcon", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        icon: string;
        adornment: string;
        adornmentButton: string;
        adornmentIcon: string;
        hideIcon: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_60: (classesProp?: Partial<Record<"input" | "label" | "root" | "disabled" | "baseInput" | "error" | "invalid" | "resizable" | "inputResizable" | "description" | "labelContainer" | "characterCounter", string>>, addStatic?: boolean) => {
    classes: {
        input: string;
        label: string;
        root: string;
        disabled: string;
        baseInput: string;
        error: string;
        invalid: string;
        resizable: string;
        inputResizable: string;
        description: string;
        labelContainer: string;
        characterCounter: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_61: (classesProp?: Partial<Record<"input" | "label" | "root" | "disabled" | "readOnly" | "error" | "invalid" | "resizable" | "description" | "labelContainer" | "suggestionsContainer" | "suggestionList" | "inputExtension" | "chipRoot" | "listItemGutters" | "listItemRoot" | "characterCounter" | "tagsList" | "tagInputContainerRoot" | "tagInputRoot" | "tagSelected" | "tagInputBorderContainer" | "tagInputRootFocused" | "tagInputRootEmpty" | "singleLine", string>>, addStatic?: boolean) => {
    classes: {
        input: string;
        label: string;
        root: string;
        disabled: string;
        readOnly: string;
        error: string;
        invalid: string;
        resizable: string;
        description: string;
        labelContainer: string;
        suggestionsContainer: string;
        suggestionList: string;
        inputExtension: string;
        chipRoot: string;
        listItemGutters: string;
        listItemRoot: string;
        characterCounter: string;
        tagsList: string;
        tagInputContainerRoot: string;
        tagInputRoot: string;
        tagSelected: string;
        tagInputBorderContainer: string;
        tagInputRootFocused: string;
        tagInputRootEmpty: string;
        singleLine: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_62: (classesProp?: Partial<Record<"label" | "root" | "group" | "horizontal" | "vertical" | "error" | "invalid" | "selectAll", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        group: string;
        horizontal: string;
        vertical: string;
        error: string;
        invalid: string;
        selectAll: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_63: (classesProp?: Partial<Record<"link" | "root" | "item" | "virtualizedRoot" | "selectorRoot" | "selectorContainer" | "box" | "truncate" | "itemSelector" | "selectAllSelector", string>>, addStatic?: boolean) => {
    classes: {
        link: string;
        root: string;
        item: string;
        virtualizedRoot: string;
        selectorRoot: string;
        selectorContainer: string;
        box: string;
        truncate: string;
        itemSelector: string;
        selectAllSelector: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_64: (classesProp?: Partial<Record<"label" | "root" | "group" | "horizontal" | "vertical" | "error" | "invalid", string>>, addStatic?: boolean) => {
    classes: {
        label: string;
        root: string;
        group: string;
        horizontal: string;
        vertical: string;
        error: string;
        invalid: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_65: (classesProp?: Partial<Record<"overlay" | "previewButton", string>>, addStatic?: boolean) => {
    classes: {
        overlay: string;
        previewButton: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_66: (classesProp?: Partial<Record<"root" | "progressbar" | "icon" | "removeButton" | "fail" | "progressbarContainer" | "progressbarBack" | "nameText" | "progressTextContainer" | "previewContainer", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        progressbar: string;
        icon: string;
        removeButton: string;
        fail: string;
        progressbarContainer: string;
        progressbarBack: string;
        nameText: string;
        progressTextContainer: string;
        previewContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_67: (classesProp?: Partial<Record<"root" | "container" | "icon" | "baseContainer" | "iconSelected" | "menuListRoot" | "menuList", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        container: string;
        icon: string;
        baseContainer: string;
        iconSelected: string;
        menuListRoot: string;
        menuList: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_68: (classesProp?: Partial<Record<"root" | "icon" | "pageSizeOptions" | "iconContainer" | "pageSizeTextContainer" | "pageSizeOptionsSelect" | "pageNavigator" | "pageInfo" | "pageJump" | "pageSizeInput" | "pageSizeInputRoot" | "pageSizeInputContainer", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        icon: string;
        pageSizeOptions: string;
        iconContainer: string;
        pageSizeTextContainer: string;
        pageSizeOptionsSelect: string;
        pageNavigator: string;
        pageInfo: string;
        pageJump: string;
        pageSizeInput: string;
        pageSizeInputRoot: string;
        pageSizeInputContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_69: (classesProp?: Partial<Record<"button" | "root" | "dropDownMenu" | "actionContainer" | "dropDownMenuButton" | "dropDownMenuButtonSelected", string>>, addStatic?: boolean) => {
    classes: {
        button: string;
        root: string;
        dropDownMenu: string;
        actionContainer: string;
        dropDownMenuButton: string;
        dropDownMenuButtonSelected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_7: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_70: (classesProp?: Partial<Record<"link" | "a" | "root" | "orderedList" | "currentPage" | "centerContainer" | "separatorContainer", string>>, addStatic?: boolean) => {
    classes: {
        link: string;
        a: string;
        root: string;
        orderedList: string;
        currentPage: string;
        centerContainer: string;
        separatorContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_71: (classesProp?: Partial<Record<"root" | "radio" | "horizontal" | "icon" | "radioRoot", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        radio: string;
        horizontal: string;
        icon: string;
        radioRoot: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_72: (classesProp?: Partial<Record<"root" | "rootClosed" | "anchorOriginTopCenter" | "anchorOriginBottomCenter", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        rootClosed: string;
        anchorOriginTopCenter: string;
        anchorOriginBottomCenter: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_73: (classesProp?: Partial<Record<"actionContainer" | "iconContainer" | "actionsInnerContainer" | "closeAction", string>>, addStatic?: boolean) => {
    classes: {
        actionContainer: string;
        iconContainer: string;
        actionsInnerContainer: string;
        closeAction: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_74: (classesProp?: Partial<Record<"root" | "default" | "warning" | "action" | "error" | "success" | "message" | "baseVariant" | "outContainer", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        default: string;
        warning: string;
        action: string;
        error: string;
        success: string;
        message: string;
        baseVariant: string;
        outContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_75: (classesProp?: Partial<Record<"root" | "anchorOriginTopCenter" | "anchorOriginBottomCenter" | "anchorOriginTopRight" | "anchorOriginBottomRight" | "anchorOriginTopLeft" | "anchorOriginBottomLeft", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        anchorOriginTopCenter: string;
        anchorOriginBottomCenter: string;
        anchorOriginTopRight: string;
        anchorOriginBottomRight: string;
        anchorOriginTopLeft: string;
        anchorOriginBottomLeft: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_76: (classesProp?: Partial<Record<"root" | "default" | "warning" | "action" | "error" | "success" | "message" | "messageSpan" | "messageText" | "iconVariant", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        default: string;
        warning: string;
        action: string;
        error: string;
        success: string;
        message: string;
        messageSpan: string;
        messageText: string;
        iconVariant: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_77: (classesProp?: Partial<Record<"snackItemRoot", string>>, addStatic?: boolean) => {
    classes: {
        snackItemRoot: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_78: (classesProp?: Partial<Record<"root" | "semantic" | "actions" | "selectAllContainer" | "selectAll" | "selectAllPages" | "divider", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        semantic: string;
        actions: string;
        selectAllContainer: string;
        selectAll: string;
        selectAllPages: string;
        divider: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_79: (classesProp?: Partial<Record<"root" | "name" | "global" | "wrapper" | "actions" | "positionSticky" | "positionFixed" | "globalWrapperComplement" | "globalSectionArea" | "backButton", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        name: string;
        global: string;
        wrapper: string;
        actions: string;
        positionSticky: string;
        positionFixed: string;
        globalWrapperComplement: string;
        globalSectionArea: string;
        backButton: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_8: (classesProp?: Partial<Record<"root" | "labelDisabled" | "childGutter", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        labelDisabled: string;
        childGutter: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_80: (classesProp?: Partial<Record<"placeholder" | "arrow" | "label" | "root" | "dropdown" | "error" | "selectionDisabled" | "description" | "labelContainer" | "dropdownHeaderInvalid" | "dropdownHeaderOpen" | "dropdownHeader" | "dropdownListContainer" | "rootList", string>>, addStatic?: boolean) => {
    classes: {
        placeholder: string;
        arrow: string;
        label: string;
        root: string;
        dropdown: string;
        error: string;
        selectionDisabled: string;
        description: string;
        labelContainer: string;
        dropdownHeaderInvalid: string;
        dropdownHeaderOpen: string;
        dropdownHeader: string;
        dropdownListContainer: string;
        rootList: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_81: (classesProp?: Partial<Record<"selection" | "selectAllContainer" | "selectAll" | "dropdownListContainer" | "rootList" | "searchContainer" | "listBorderDown" | "listContainer", string>>, addStatic?: boolean) => {
    classes: {
        selection: string;
        selectAllContainer: string;
        selectAll: string;
        dropdownListContainer: string;
        rootList: string;
        searchContainer: string;
        listBorderDown: string;
        listContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_82: (classesProp?: Partial<Record<"root" | "stickyHeader" | "stickyColumns" | "listRow", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        stickyHeader: string;
        stickyColumns: string;
        listRow: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_83: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_84: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_85: (classesProp?: Partial<Record<"root" | "stickyHeader", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        stickyHeader: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_86: (classesProp?: Partial<Record<"body" | "footer" | "head" | "root" | "resizer" | "resizable" | "sortable" | "sorted" | "stickyColumn" | "stickyColumnMostLeft" | "stickyColumnLeastRight" | "groupColumnMostLeft" | "groupColumnMostRight" | "resizing" | "alignLeft" | "alignCenter" | "alignRight" | "alignJustify" | "variantNone" | "variantCheckbox" | "variantActions" | "variantExpand" | "variantList" | "headerContent" | "headerText" | "headerParagraph" | "sortableHeaderText" | "sortButton" | "sortIcon" | "alignFlexLeft" | "alignFlexRight" | "alignFlexCenter" | "alignFlexJustify", string>>, addStatic?: boolean) => {
    classes: {
        body: string;
        footer: string;
        head: string;
        root: string;
        resizer: string;
        resizable: string;
        sortable: string;
        sorted: string;
        stickyColumn: string;
        stickyColumnMostLeft: string;
        stickyColumnLeastRight: string;
        groupColumnMostLeft: string;
        groupColumnMostRight: string;
        resizing: string;
        alignLeft: string;
        alignCenter: string;
        alignRight: string;
        alignJustify: string;
        variantNone: string;
        variantCheckbox: string;
        variantActions: string;
        variantExpand: string;
        variantList: string;
        headerContent: string;
        headerText: string;
        headerParagraph: string;
        sortableHeaderText: string;
        sortButton: string;
        sortIcon: string;
        alignFlexLeft: string;
        alignFlexRight: string;
        alignFlexCenter: string;
        alignFlexJustify: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_87: (classesProp?: Partial<Record<"body" | "footer" | "head" | "root" | "expanded" | "selected" | "hover" | "striped" | "variantList" | "variantListHead", string>>, addStatic?: boolean) => {
    classes: {
        body: string;
        footer: string;
        head: string;
        root: string;
        expanded: string;
        selected: string;
        hover: string;
        striped: string;
        variantList: string;
        variantListHead: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_88: (classesProp?: Partial<Record<"body" | "footer" | "head" | "root" | "resizable" | "sorted" | "stickyColumn" | "stickyColumnMostLeft" | "stickyColumnLeastRight" | "groupColumnMostLeft" | "groupColumnMostRight" | "resizing" | "alignLeft" | "alignCenter" | "alignRight" | "alignJustify" | "variantNone" | "variantCheckbox" | "variantActions" | "variantExpand" | "variantList" | "variantListHead" | "variantListactions" | "variantListcheckbox", string>>, addStatic?: boolean) => {
    classes: {
        body: string;
        footer: string;
        head: string;
        root: string;
        resizable: string;
        sorted: string;
        stickyColumn: string;
        stickyColumnMostLeft: string;
        stickyColumnLeastRight: string;
        groupColumnMostLeft: string;
        groupColumnMostRight: string;
        resizing: string;
        alignLeft: string;
        alignCenter: string;
        alignRight: string;
        alignJustify: string;
        variantNone: string;
        variantCheckbox: string;
        variantActions: string;
        variantExpand: string;
        variantList: string;
        variantListHead: string;
        variantListactions: string;
        variantListcheckbox: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_89: (classesProp?: Partial<Record<"root" | "formContainer", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        formContainer: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_9: (classesProp?: Partial<Record<"root" | "gutter" | "infoDisabled", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        gutter: string;
        infoDisabled: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_90: (classesProp?: Partial<Record<"section" | "root" | "rightSection" | "leftSection", string>>, addStatic?: boolean) => {
    classes: {
        section: string;
        root: string;
        rightSection: string;
        leftSection: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_91: (classesProp?: Partial<Record<"root", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_92: (classesProp?: Partial<Record<"root" | "sortDropdown", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        sortDropdown: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_93: (classesProp?: Partial<Record<"root" | "rangeCalendarContainer" | "singleCalendar" | "focusSelection" | "calendarMonthlyCell" | "calendarMonthlyCellSelected", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        rangeCalendarContainer: string;
        singleCalendar: string;
        focusSelection: string;
        calendarMonthlyCell: string;
        calendarMonthlyCellSelected: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_94: (classesProp?: Partial<Record<"input" | "root" | "invalid" | "inputBorderContainer" | "headerDayOfWeek" | "headerDate" | "invalidMessageStyling", string>>, addStatic?: boolean) => {
    classes: {
        input: string;
        root: string;
        invalid: string;
        inputBorderContainer: string;
        headerDayOfWeek: string;
        headerDate: string;
        invalidMessageStyling: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_95: (classesProp?: Partial<Record<"root" | "slider" | "collapsed" | "childData", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        slider: string;
        collapsed: string;
        childData: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_96: (classesProp?: Partial<Record<"root" | "minimized" | "collapseButton", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        minimized: string;
        collapseButton: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_97: (classesProp?: Partial<Record<"root" | "hide", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        hide: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_98: (classesProp?: Partial<Record<"action" | "noIcon" | "minimized", string>>, addStatic?: boolean) => {
    classes: {
        action: string;
        noIcon: string;
        minimized: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

declare const useClasses_99: (classesProp?: Partial<Record<"root" | "list" | "popup" | "listItem" | "collapsed" | "navigationPopup", string>>, addStatic?: boolean) => {
    classes: {
        root: string;
        list: string;
        popup: string;
        listItem: string;
        collapsed: string;
        navigationPopup: string;
    };
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation[]): string;
        (...args: CSSInterpolation[]): string;
    };
    cx: (...args: any) => string;
};

export declare const useClickOutside: <T extends HTMLElement = HTMLElement>(ref: RefObject<T>, handler: (event: HvClickOutsideEvent) => void) => void;

export declare const useComputation: (valueFn: any, valueFallback?: any) => any[];

export declare const useControlled: (controlledProp: any, initialState: any) => any[];

export declare function useCss(): {
    css: {
        (template: TemplateStringsArray, ...args: CSSInterpolation_2[]): string;
        (...args: CSSInterpolation_2[]): string;
    };
    cx: (...args: any) => string;
};

/** Injects into `props` the props defined in the theme `componentName`. */
export declare function useDefaultProps<T extends Record<string, any>>(
/** Name of the theme component key to inject defaultProps */
componentName: string, // keyof HvThemeComponents,
props: T): T;

export declare const useEnhancedEffect: typeof useEffect;

export declare type UseFiltersProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useForkRef: (refA: any, refB: any) => ((refValue: any) => void) | null;

export declare type UseGlobalFilterProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useHvBulkActions: UseBulkActionsProps;

export declare interface UseHvBulkActionsHooks<D extends object> {
    getHvBulkActionsProps: Array<HvBulkActionsPropGetter<D>>;
}

export declare interface UseHvBulkActionsTableInstanceProps<D extends object> {
    getHvBulkActionsProps: (propGetter?: HvBulkActionsPropGetter<D>) => HvTAbleBulkActionsProps;
    invertedToggleAllRowsSelected: () => void;
}

export declare type UseHvBulkActionsTableOptions = {
    aditivePageBulkSelection?: boolean;
    subtractivePageBulkDeselection?: boolean;
    showSelectAllPages?: boolean;
};

export declare const useHvFilters: UseFiltersProps;

export declare const useHvGlobalFilter: UseGlobalFilterProps;

export declare const useHvHeaderGroups: UseHvHeaderGroupsProps;

export declare interface UseHvHeaderGroupsCellProps {
    groupColumnMostLeft?: boolean;
    groupColumnMostRight?: boolean;
}

export declare interface UseHvHeaderGroupsColumnProps {
    style?: CSSProperties;
    groupColumnMostLeft?: boolean;
    groupColumnMostRight?: boolean;
}

export declare interface UseHvHeaderGroupsInstance {
    hasGroupedColumns?: boolean;
}

export declare type UseHvHeaderGroupsProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useHvPagination: UsePaginationProps;

export declare interface UseHvPaginationHooks<D extends object> {
    getHvPaginationProps: Array<HvPaginationPropGetter<D>>;
}

export declare interface UseHvPaginationTableInstance<D extends object> {
    getHvPaginationProps: (propGetter?: HvPaginationPropGetter<D>) => HvTablePaginationProps;
}

export declare interface UseHvResizeColumnProps {
    resizable?: boolean;
    resizing?: boolean;
}

export declare const useHvResizeColumns: UseHvResizeColumnsProps;

export declare type UseHvResizeColumnsProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare interface UseHvResizeTableCellProps {
    resizable?: boolean;
    resizing?: boolean;
}

export declare const useHvRowExpand: UseRowExpandProps;

export declare interface UseHvRowExpandRowInstance<D extends object = Record<string, unknown>> extends UseExpandedRowProps<D> {
    getToggleRowExpandedProps: (props?: Partial<TableExpandedToggleProps>) => UseHvRowExpandRowToggleProps;
}

export declare interface UseHvRowExpandRowToggleProps extends TableExpandedToggleProps {
    onClick?: MouseEventHandler<unknown>;
}

export declare type UseHvRowExpandTableOptions = {
    disableCreateExpandButton?: boolean;
};

export declare interface UseHvRowExpandTableRowProps {
    expanded?: boolean;
}

export declare const useHvRowSelection: UseRowSelectionProps;

export declare interface UseHvRowSelectionBulkCheckboxProps {
    onChange?: (e: ChangeEvent, checked?: boolean) => void;
    checked?: boolean;
    indeterminate?: boolean;
}

export declare interface UseHvRowSelectionHooks<D extends object> {
    getToggleRowSelectedProps: Array<PropGetter<D, UseHvRowSelectionRowCheckboxProps>>;
    getToggleAllRowsSelectedProps: Array<PropGetter<D, UseHvRowSelectionBulkCheckboxProps>>;
    getToggleAllPageRowsSelectedProps: Array<PropGetter<D, UseHvRowSelectionBulkCheckboxProps>>;
}

export declare interface UseHvRowSelectionRowCheckboxProps {
    onChange?: (e: ChangeEvent, checked?: boolean) => void;
    checked?: boolean;
    disabled?: boolean;
    indeterminate?: boolean;
}

export declare interface UseHvRowSelectionRowInstance {
    isSelected: boolean;
    isSomeSelected: boolean;
    isSelectionLocked: boolean;
    toggleRowLockedSelection: (set?: boolean) => void;
    toggleRowSelected: (set?: boolean) => void;
    getToggleRowSelectedProps: (props?: Partial<UseHvRowSelectionRowCheckboxProps>) => UseHvRowSelectionRowCheckboxProps;
}

export declare interface UseHvRowSelectionState<D extends object> {
    selectedRowIds: Record<IdType_2<D>, boolean>;
    lockedSelectionRowIds: Record<IdType_2<D>, boolean>;
}

export declare interface UseHvRowSelectionTableInstance<D extends object> {
    toggleRowSelected: (rowId: IdType_2<D>, set?: boolean) => void;
    toggleAllRowsSelected: (value?: boolean) => void;
    toggleAllPageRowsSelected: (value?: boolean) => void;
    getToggleAllRowsSelectedProps: (props?: Partial<UseHvRowSelectionBulkCheckboxProps>) => UseHvRowSelectionBulkCheckboxProps;
    getToggleAllPageRowsSelectedProps: (props?: Partial<UseHvRowSelectionBulkCheckboxProps>) => UseHvRowSelectionBulkCheckboxProps;
    isNoRowsSelected: boolean;
    isNoPageRowsSelected: boolean;
    isAllRowsSelected: boolean;
    isAllPageRowsSelected: boolean;
    isAllSelectableRowsSelected: boolean;
    isAllSelectablePageRowsSelected: boolean;
    isAllSelectableRowsUnselected: boolean;
    isAllSelectablePageRowsUnselected: boolean;
    selectedFlatRows: Array<Row<D>>;
}

export declare type UseHvRowSelectionTableOptions = Partial<{
    autoResetSelectedRows: boolean;
    autoResetLockedSelectionRows: boolean;
    selectSubRows: boolean;
    manualRowSelectedKey: string;
    applyToggleAllRowsSelectedToPrefilteredRows: boolean;
}>;

export declare interface UseHvRowSelectionTableRowProps {
    selected?: boolean;
}

export declare const useHvSnackbar: () => {
    enqueueSnackbar: (message: ReactNode, options?: HvNotistackSnackMessageProps) => SnackbarKey;
    closeSnackbar: (key?: SnackbarKey | undefined) => void;
};

export declare const useHvSortBy: UseHvSortByProps;

export declare interface UseHvSortByColumnProps {
    sortable?: boolean;
    sorted?: boolean;
    sortDirection?: "descending" | "ascending";
    onClick?: (e: React.MouseEvent<HTMLTableCellElement>) => void;
}

export declare type UseHvSortByProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare interface UseHvSortByTableCellProps {
    sorted?: boolean;
}

declare function useHvTable<D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(options: HvTableOptions<D, H>, ...plugins: HvTablePluginHook<D>[]): HvTableInstance<D, H>;
export { useHvTable as useHvData }
export { useHvTable }

export declare type UseHvTableProps = <D extends object = Record<string, unknown>, H extends HvTableHeaderRenderer | undefined = HvTableHeaderRenderer>(options: HvTableOptions<D, H>, ...plugins: Array<HvTablePluginHook<D>>) => HvTableInstance<D, H>;

export declare type UseHvTableSticky = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useHvTableSticky: UseHvTableSticky;

export declare interface UseHvTableStickyCellProps {
    stickyColumn?: boolean;
    stickyColumnMostLeft?: boolean;
    stickyColumnLeastRight?: boolean;
}

export declare interface UseHvTableStickyColumnProps {
    stickyColumn?: boolean;
    stickyColumnMostLeft?: boolean;
    stickyColumnLeastRight?: boolean;
}

export declare interface UseHvTableStickyHooks<D extends object> {
    getTableHeadProps: Array<HvTableHeadPropGetter<D>>;
}

export declare interface UseHvTableStickyTableHeadProps extends TableCommonProps {
    stickyHeader?: boolean;
}

export declare interface UseHvTableStickyTableInstance<D extends object> {
    getTableHeadProps: (propGetter?: HvTableHeadPropGetter<D>) => UseHvTableStickyTableHeadProps;
    totalRight?: number;
    hasStickyColumns?: boolean;
}

export declare type UseHvTableStickyTableOptions = {
    stickyHeader?: boolean;
    stickyColumns?: boolean;
};

export declare interface UseHvTableStickyTableProps {
    stickyHeader?: boolean;
    stickyColumns?: boolean;
}

export declare const useHvTableStyles: UseTableStylesProps;

export declare interface UseHvTableStylesColumnOptions {
    variant?: "checkbox" | "expand" | "actions" | "default" | "none";
    align?: "center" | "inherit" | "justify" | "left" | "right";
    style?: CSSProperties;
    className?: string;
    classes?: Record<string, string>;
    headerStyle?: CSSProperties;
    headerClassName?: string;
    headerClasses?: Record<string, string>;
    cellStyle?: CSSProperties;
    cellClassName?: string;
    cellClasses?: Record<string, string>;
}

export declare interface UseHvTableStylesTableCellProps {
    style?: CSSProperties;
    className?: string;
    classes?: Record<string, string>;
    variant?: "checkbox" | "expand" | "actions" | "default" | "none";
    align?: "center" | "inherit" | "justify" | "left" | "right";
}

export declare type UseHvTableStylesTableOptions = {
    style?: CSSProperties;
    className?: string;
    classes?: Record<string, string>;
    component?: any;
};

export declare interface UseHvTableStylesTableRowProps {
    hover?: boolean;
}

export declare const useImageLoaded: (src: any, srcSet: any) => string | boolean;

export declare function useInstance(instance: any): void;

export declare const useIsMounted: () => React_2.MutableRefObject<boolean>;

export declare function useLabels<T>(defaultLabels: Partial<T>, labels: T): T;

export declare type UsePaginationProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare type UseRowExpandProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare type UseRowSelectionProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare function useSavedState<T>(defaultState: T): [T | undefined, (v?: T, s?: boolean) => void, () => void, T | undefined, T];

export declare const useScrollTo: (selectedIndexProp?: number, scrollElementId?: string | undefined, href?: boolean, offset?: number, options?: HvScrollToVerticalOption[], onChange?: ((event: Event | React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>, index: number) => void) | undefined, direction?: "column" | "row") => [number, (event: React.MouseEvent<HTMLDivElement> | React.KeyboardEvent<HTMLDivElement>, id: string, index: number, wrappedOnChange?: ((index: number) => void) | undefined) => void];

export declare const useSelectionPath: (data: HvHeaderNavigationItemProp[], selectedId?: string) => string[];

export declare type UseTableStylesProps = (<D extends object = Record<string, unknown>>(hooks: Hooks<D>) => void) & {
    pluginName: string;
};

export declare const useTheme: () => HvThemeContextValue & {
    /** Colors of the currently active theme and mode */
    colors?: HvThemeColorModeStructure;
};

export declare const useUniqueId: (id?: string, idPrefix?: string) => string;

export declare const useWidth: () => Breakpoint_2;

declare type ValueOf<T> = T[keyof T];

export declare const verticalNavigationClasses: {
    root: "HvVerticalNavigation-root";
    slider: "HvVerticalNavigation-slider";
    collapsed: "HvVerticalNavigation-collapsed";
    childData: "HvVerticalNavigation-childData";
};

export declare const VerticalNavigationContext: Context<VerticalNavigationContextValue>;

declare interface VerticalNavigationContextValue {
    isOpen: boolean;
    useIcons: boolean;
    slider?: boolean;
    headerTitle?: string;
    setHeaderTitle?: React.Dispatch<React.SetStateAction<string | undefined>>;
    parentItem?: any;
    setParentItem?: React.Dispatch<React.SetStateAction<any>>;
    withParentData?: any;
    navigateToChildHandler?: (event: any, item: any) => void;
    navigateToParentHandler?: () => void;
    parentData?: NavigationData[];
    setParentData?: React.Dispatch<React.SetStateAction<any>>;
    parentSelected?: any;
    setParentSelected?: React.Dispatch<React.SetStateAction<any>>;
    hasAnyChildWithData?: boolean;
}

export declare const verticalNavigationHeaderClasses: {
    root: "HvVerticalNavigationHeader-root";
    minimized: "HvVerticalNavigationHeader-minimized";
    collapseButton: "HvVerticalNavigationHeader-collapseButton";
};

export declare const verticalNavigationSliderClasses: {
    root: "HvVerticalNavigationSlider-root";
    listItemSelected: "HvVerticalNavigationSlider-listItemSelected";
    listItemFocus: "HvVerticalNavigationSlider-listItemFocus";
};

export declare const verticalNavigationTreeClasses: {
    root: "HvVerticalNavigationTree-root";
    list: "HvVerticalNavigationTree-list";
    popup: "HvVerticalNavigationTree-popup";
    listItem: "HvVerticalNavigationTree-listItem";
    collapsed: "HvVerticalNavigationTree-collapsed";
    navigationPopup: "HvVerticalNavigationTree-navigationPopup";
};

export declare const verticalScrollListItemClasses: {
    button: "HvVerticalScrollListItem-button";
    text: "HvVerticalScrollListItem-text";
    root: "HvVerticalScrollListItem-root";
    notSelected: "HvVerticalScrollListItem-notSelected";
};

export declare type VisibilitySelectorActions = "previous_month" | "next_month" | "previous_year" | "next_year" | "month" | "month_year";

export declare const warningTextClasses: {
    root: "HvWarningText-root";
    show: "HvWarningText-show";
    hideText: "HvWarningText-hideText";
    defaultIcon: "HvWarningText-defaultIcon";
    warningText: "HvWarningText-warningText";
    topGutter: "HvWarningText-topGutter";
    topBorder: "HvWarningText-topBorder";
};

export declare const withTooltip: (Component: React.FunctionComponent, label: string | undefined, placement: HvTooltipPlacementType, hideTooltip?: ((event: React.MouseEvent<HTMLDivElement>) => boolean) | undefined, tooltipProps?: Partial<HvTooltipProps>, tooltipContainerProps?: HvBaseProps) => (props: any) => JSX_2.Element;

export declare const wrapperTooltip: (hasTooltips: any, Component: any, label: any) => ((props: any) => JSX_2.Element) | (() => any);

export { }

import fs from "fs";
import path from "path";
import { getAppModules, getMainApp, getPublicPath } from "./config-utils.js";
var ViteCommand;
(function (ViteCommand) {
    ViteCommand["BUILD"] = "build";
    ViteCommand["SERVE"] = "serve";
})(ViteCommand || (ViteCommand = {}));
/**
 * Process configuration, executing several tasks:
 *  - Create rollup configuration to support module creation
 *  - Generates final transformed configuration json
 *  - "base" value is always "./" for build, and main app baseUrl for preview or dev
 * @param root Project root directory.
 * @param appShellConfig The original App Shell configuration json.
 * @param selfAppName The name of the application bundle being built.
 * @param buildEntryPoint If true, the index.html entry point will be added to the bundle.
 */
export default function processConfiguration(root, appShellConfig, selfAppName, buildEntryPoint, inlineConfig, generateEmptyShell) {
    const selfApp = getMainApp(appShellConfig);
    let finalAppShellConfig;
    return {
        name: "vite-plugin-appShell-configuration-processor",
        config(config, { command }) {
            const projectRoot = root ?? config.root;
            const publicPath = getPublicPath(appShellConfig);
            let appModules = {};
            if (!generateEmptyShell) {
                appModules = getAppModules(projectRoot, appShellConfig, selfAppName);
                console.info("Modules exported by the application bundle:", appModules);
            }
            return {
                build: {
                    rollupOptions: {
                        preserveEntrySignatures: "strict",
                        input: {
                            ...(buildEntryPoint &&
                                fs.existsSync(path.resolve(projectRoot, "index.html"))
                                ? { main: path.resolve(projectRoot, "index.html") }
                                : {}),
                            ...appModules
                        },
                        output: {
                            entryFileNames: "[name].js"
                        }
                    }
                },
                // if serve (preview/dev) it uses the baseUrl. Otherwise(build), use ./
                base: command === ViteCommand.SERVE ? publicPath : "./"
            };
        },
        /**
         * Rollup hook with the info for bundle generation
         * It will be used to create a new configuration with:
         *  - bundles replace with the final location (e.g. -> "bundle": "src/pages/Main" transformed to "bundle": "pages/Main.js",
         * @param options build options
         * @param bundle bundles information
         */
        async generateBundle(options, bundle) {
            if (generateEmptyShell) {
                return;
            }
            // obtain the directory (dist) where the new config file will be placed
            let targetDir;
            if (options.dir) {
                targetDir = options.dir;
            }
            else if (options.file) {
                targetDir = path.dirname(options.file);
            }
            if (!targetDir) {
                throw new Error("Please set outputPath, so we can know where to place the json file");
            }
            // create the targetDir if it does not exist
            if (!fs.existsSync(targetDir)) {
                fs.mkdirSync(targetDir, { recursive: true });
            }
            /**
             * Creating a map with each chunk and the final name. Only the bundles with type=chunk are important
             * Filename do not include the src path at the value
             */
            const chunks = {};
            Object.keys(bundle).forEach(key => {
                const chunk = bundle[key];
                if (chunk.type === "chunk") {
                    const outputChunk = chunk;
                    if (outputChunk.isEntry) {
                        const { fileName } = outputChunk;
                        const { name } = outputChunk;
                        chunks[name] = fileName;
                    }
                }
            });
            if (selfApp) {
                selfApp.views = selfApp.views?.map(view => {
                    const bundleName = view.bundle
                        .replace(/^src\//, "")
                        .replaceAll(/\$/g, "_");
                    return {
                        ...view,
                        bundle: chunks[bundleName]
                    };
                });
                selfApp.modules = selfApp.modules?.map(module => {
                    const bundleName = module.bundle.replace(/^src\//, "");
                    return {
                        ...module,
                        bundle: chunks[bundleName]
                    };
                });
                // replace references to @self with the name of this application bundle
                selfApp.id = selfAppName;
                // also replace implicit references to selfApp in other parts of the configuration
                const { theming } = appShellConfig;
                if (theming != null) {
                    theming.themes = theming.themes?.map(theme => {
                        if (theme.startsWith("@self/") ||
                            theme.startsWith(selfAppName) ||
                            theme.startsWith("/src/")) {
                            const bundleName = theme
                                .replace(/^@self\//, "")
                                .replace(new RegExp(`^${selfAppName}/`), "")
                                .replace(/^(\/?)src\//, "");
                            return `${selfAppName}/${chunks[bundleName]}`;
                        }
                        return theme;
                    });
                }
            }
            finalAppShellConfig = buildEntryPoint
                ? { ...appShellConfig }
                : {
                    name: appShellConfig.name,
                    apps: selfApp != null ? [selfApp] : undefined
                };
            if (!inlineConfig) {
                fs.writeFileSync(path.resolve(targetDir, "app-shell.config.json"), JSON.stringify(finalAppShellConfig));
            }
        },
        transformIndexHtml: {
            transform: html => {
                if (!inlineConfig) {
                    return undefined;
                }
                return {
                    html,
                    tags: [
                        {
                            tag: "script",
                            injectTo: "head-prepend",
                            children: `globalThis.__appshell_config__ = ${generateEmptyShell
                                ? "%%APPSHELL_CONFIG%%"
                                : JSON.stringify(finalAppShellConfig ?? appShellConfig)};`
                        }
                    ]
                };
            }
        }
    };
}
//# sourceMappingURL=vite-configuration-processor-plugin.js.map
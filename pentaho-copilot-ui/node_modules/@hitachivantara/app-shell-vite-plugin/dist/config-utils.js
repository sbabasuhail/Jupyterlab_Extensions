import fs from "fs";
import path from "path";
import { register, createEsmHooks } from "ts-node";
import { require } from "./nodeModule.js";
createEsmHooks(register({
    transpileOnly: true,
    moduleTypes: {
        "app-shell.config.ts": "cjs"
    }
}));
export const DEFAULT_CONFIG_FILES = [
    "app-shell.config.ts",
    "app-shell.config.js",
    "app-shell.config.json"
];
export function findAppShellConfigFile(root) {
    const filename = DEFAULT_CONFIG_FILES.find(file => fs.existsSync(path.resolve(root, file)));
    if (filename) {
        return path.resolve(root, filename);
    }
    return undefined;
}
export function loadConfigFile(appShellConfigFile, opts, env = {}) {
    if (!appShellConfigFile) {
        // an empty configuration is actually valid
        // and with the automatic views option, it can even make sense
        return {};
    }
    if (appShellConfigFile.endsWith(".json")) {
        let appShellConfigRaw = fs.readFileSync(appShellConfigFile, "utf-8");
        // token replacement is only supported for json files
        opts.configReplacements?.forEach(item => {
            appShellConfigRaw = appShellConfigRaw.replaceAll(`@@${item.token}@@`, item.value);
        });
        return JSON.parse(appShellConfigRaw);
    }
    // using require instead of import to avoid using --experimental-loader ts-node/esm
    // eslint-disable-next-line import/no-dynamic-require
    const loadedAppShellConfig = require(appShellConfigFile).default;
    if (typeof loadedAppShellConfig === "function") {
        return loadedAppShellConfig(opts, env);
    }
    return loadedAppShellConfig;
}
/**
 * Return the main app (identified by @self)
 * @param appShellConfig The App shell configuration
 */
export const getMainApp = (appShellConfig) => {
    return appShellConfig.apps?.filter(app => app.id === "@self")[0];
};
/**
 * Return the public path to be use by vite to launch the application.
 * Value is obtained by returning the baseUrl value of the main app {@link #getMainApp}
 * @param appShellConfig The App shell configuration
 */
export const getPublicPath = (appShellConfig) => {
    const mainApp = getMainApp(appShellConfig);
    if (!mainApp) {
        return "/";
    }
    const url = mainApp.baseUrl;
    try {
        return new URL(url).pathname;
    }
    catch {
        return url;
    }
};
/**
 *  Returns the modules to be created by the build of the app.
 *  The list of modules is defined by the app-shell-config.json file routes ( limited to the @self app)
 *  The bundles will be created following the original directories structure ( having the src folder path removed)
 *
 * @param root Project root directory.
 * @param appShellConfig The App Shell configuration.
 * @param selfAppName The name of the application bundle being built.
 */
export function getAppModules(root, appShellConfig, selfAppName) {
    const appModules = {};
    const selfApp = getMainApp(appShellConfig);
    if (selfApp != null) {
        const selfViews = selfApp.views?.map(view => {
            const bundleName = view.bundle.replace(/^src\//, "");
            return {
                ...view,
                bundleName
            };
        }) ?? [];
        selfViews.forEach(view => {
            appModules[view.bundleName] = path.resolve(root, view.bundle);
        });
        const selfModules = selfApp.modules?.map(module => {
            const bundleName = module.bundle.replace(/^src\//, "");
            return {
                ...module,
                bundleName
            };
        }) ?? [];
        selfModules.forEach(module => {
            appModules[module.bundleName] = path.resolve(root, module.bundle);
        });
    }
    const implicitThemeModules = appShellConfig?.theming?.themes?.map(theme => {
        if (theme.startsWith("/src/") ||
            theme.startsWith("@self/") ||
            theme.startsWith(selfAppName)) {
            const bundle = theme
                .replace(/^@self\//, "")
                .replace(new RegExp(`^${selfAppName}/`), "");
            const bundleName = bundle.replace(/^(\/?)src\//, "");
            return {
                bundle,
                bundleName
            };
        }
        return undefined;
    }) ?? [];
    implicitThemeModules.forEach(module => {
        if (module != null && appModules[module.bundleName] == null) {
            appModules[module.bundleName] = path.resolve(root, module.bundle);
        }
    });
    return appModules;
}
//# sourceMappingURL=config-utils.js.map